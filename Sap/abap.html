<html>
<head>
   <link rel="stylesheet" href="..\assets\css\main.css">
   <link rel='stylesheet' href='..\libs\jquery.jqTOC.css' type='text/css' />
   <script type="text/javascript" src="..\libs\jquery-3.3.1.js"></script>
   <script type="text/javascript" src="..\libs\jquery.jqTOC.js"></script>
   <script type="text/javascript">
      $(document).ready(function(){
         //$('#content1').jqTOC({tocContainer:'abc',tocShow:'show'});
         $('#content').jqTOC({
                tocWidth:800,
                tocTitle: "Table of Contents",
                tocStart: 1,
                tocEnd  : 4
        });
      });
   </script>
</head>
<body id="content1">
<p id="content">
    <h1  itemprop="headline">Introduction to  &nbsp;<b>ABAP</b>
        ( <b>A</b>dvanced &nbsp;<b>B</b>usiness &nbsp;<b>A</b>pplication &nbsp;<b>P</b>rogramming. ):
    </h1>
    <ul>
        <li>It is&nbsp; a programming language for developing applications for the <b>SAP R/3  system</b>.</li>
        <li>All functional modules of SAP are written in ABAP.</li>
        <li> The latest version of ABAP is&nbsp; called&nbsp; ABAP Objects and supports
            object-oriented programming.</li>
        <li> SAP system provides various predefined reports and interface, 
            but we can create  customized reports and interfaces as per business requirements.
        </li>
    </ul>
    <br><strong>Class Pool: </strong>
    <p>
    <br>  Class Pool are K programs type that represented with the keyword CLASS-POOL.
    <br> P/4, the earlier ABAP version, as well as applications using ABAP         Objects.
    </p>
    
    <h2>Types of ABAP 4 Programs</h2>
    <p>
        
        <b>Executable Programs (ABAP Reports):</b>
            are I programs type that represented with the keyword REPORT

        <b>INCLUDE Program:-</b>
            are I programs type that represented with the keyword INCLUDE

        <b>Module Pool/Dialogue programs:</b>
            are type M programs represented with the keyword PROGRAM.

        <b>Sub-Routine Pool: </b>
            are S programs type that represented with the keyword PROGRAM.

        <b>Interface Pool:</b>
            are J programs type that represented with the keyword INTERFACE-POOL.

        <b>Class Pool:</b>
            are K programs type that represented with the keyword CLASS-POOL.    

        <b>Function Group:</b>
            are F programs type that represented with the keyword FUNCTION-POOL.

        <b>Type group:</b> 
            are represented with the keyword TYPE-POOL.
        
    </p>
    <h2>Variables and Data Types</h2>
    <p>
        <h3>Declaring variable :</h3>
        <code>
            DATA Variable_Name Type Variable_Type
        </code>
        <p>Example:</p>
        <code>
        DATA employee_number Type I.
        </code>
        <br>
        <p>The following is a list of Data Types supported by ABAP</p>
        <br>
        <table border="1" cellspacing="1" class="table table-striped" style=
        " display: block; overflow: scroll;overflow-x: auto;overflow-y: auto;">
            <tbody>
            <tr>
                <th style="width:12%"><b>Data Type</b></th>
                <th style="width:18%"><b>Initial field length</b></th>
                <th style="width:18%"><b>Valid field length</b></th>
                <th style="width:18%"><b>Initial value</b></th>
                <th><b>Meaning</b></th>
            </tr>
            <tr>
                <td colspan="5"><em><b>Numeric types</b></em></td>
            </tr>
            <tr>
                <td>I</td>
                <td>4</td>
                <td>4</td>
                <td>0</td>
                <td>Integer (whole number)</td>
            </tr>
            <tr>
                <td>F</td>
                <td>8</td>
                <td>8</td>
                <td>0</td>
                <td>Floating point number</td>
            </tr>
            <tr>
                <td>P</td>
                <td>8</td>
                <td>1 - 16</td>
                <td>0</td>
                <td>Packed number</td>
            </tr>
            <tr>
                <td colspan="5"><em><b>Character types</b></em></td>
            </tr>
            <tr>
                <td>C</td>
                <td>1</td>
                <td>1 - 65535</td>
                <td>' ... '</td>
                <td v="">Text field(alphanumeric characters)</td>
            </tr>
            <tr>
                <td>D</td>
                <td>8</td>
                <td>8</td>
                <td>'00000000'</td>
                <td>Date field(Format: YYYYMMDD)</td>
            </tr>
            <tr>
                <td>N</td>
                <td>1</td>
                <td>1 - 65535</td>
                <td>'0 ... 0'</td>
                <td>Numeric text field(numeric characters)</td>
            </tr>
            <tr>
                <td>T</td>
                <td>6</td>
                <td>6</td>
                <td>'000000'</td>
                <td>Time field(format: HHMMSS)</td>
            </tr>
            <tr>
                <td colspan="5"><em><b>Hexadecimal type</b></em></td>
            </tr>
            <tr>
                <td>X</td>
                <td>1</td>
                <td>1 - 65535</td>
                <td>X'0 ... 0'</td>
                <td>Hexadecimal field</td>
            </tr>
            </tbody>
        </table>
        
        <h3> Assigning Values</h3>
        <p>
        a=16.
        move 16 to a.
        write a to b.
        </p>

        <h3> Arithmetic Operations</h3>
        <P>
        compute a = a*100.
        </P>
    </p>

    <h2>Control Statements</h2>
    <p>
        <h3> If ... EndIf Loop</h3>
        <P>
        if [not] exp [ and / or [not] exp ].
        ........
        [elseif exp.
        .......]
        [else.
        .......]
        Endif.
        </P>

        <h3>Case statement</h3>
        <P>
        Case variable.
        when value1.
        .........
        when value2.
        .........
        [ when others.
        .........]
        Endcase.
        Do.
        </P>

        <h3>While loop</h3>
        <P>
        While &lt;logical expression&gt;.
        .....
        .....
        Endwhile.
        </P>

        <h3> Do loop</h3>
        <P>
        Do &lt;n&gt; times.
        .....
        .....
        Enddo.
        </P>
    </p>
    <h2>Logical Operator</h2>
    <h3>A list of logical operators</h3>
    <ul>
        <li>GE or &gt;=</li>

        <li>GT or &gt;</li>

        <li>LE or &lt;=</li>

        <li>LT or &lt;</li>

        <li>EQ or =</li>

        <li>NE or &lt;&gt;</li>
    </ul>

    <h2>What is Data Dictionary?</h2>
    <p>
        Data Dictionary is a system independent interface to  the database (virtual database ) . 
        
        Its main function is to support the <b>creation and management</b>  of data definitions
        (or <b>"metadata"</b>).

        <h3>ABAP Dictionary 3 levels</h3>
    <p>
        Objects in the ABAP Dictionary resided on 3 levels :

            <b>Tables and structures</b>
                    <b>Tables</b>    
                        . Represent the Database Tables where data actually resides.
                        . Tables can be defined independently of the database in the ABAP Dictionary.
                        . The fields of the table are defined with their (database-independent) SAP ABAP data types and lengths.
                    <b>Structures</b>
                        . Are record declarations that do NOT correspond to a Database Table.
                        Just like user-defined data type.
                        Defined like a table and can then be addressed from ABAP programs.
                        Structures contain data only during the runtime of a program.        
            <b>Data elements</b>
                    . Describes the role played by a field in a technical context
                    . Fields of same semantic meaning can refer to the same data element
                    Contains the field information    
            <b>Domains</b>
                    . Describes the technical characteristics of a table field Specifies a value range .
                    . it describes allowed data values for the fields
                    . Fields referring to the same domain (via the data elements assigned to them) are changed when a change is made to the domain
                    Ensures consistency    
    </p>
    
    <h2>Aggregated Objects of ABAP Dictionary</h2>
    <p>
        .In the ABAP Dictionary, aggregated objects are objects which come from several different 
        transparent tables.

        <h3>Views</h3>
        <p>
            . Are same as database views.
            . Views are used to summarize data which is distributed among several tables
            . The data of a view is not actually physically stored.
            . The data of a view is instead derived from one or more other tables
            , It is tailored to the needs of a specific application
        </p>
        
        <h3>Search Help</h3>
        <p>
                . Search help is a tool to help you search for data records in the system
                . An efficient and user-friendly search assists users where the key of a record is unknown
        </p>
        
        <h3>Lock Objects</h3>
        <p>
        . Simultaneous accessing of the same data record by two users is synchronized by a lock mechanism.
        . Locks are set and released by calling certain function modules.
        . These function modules are generated automatically from the definition of so-called lock objects in the ABAP/4 Dictionary.
        
        <b>Function modules :</b>
            <b>Enqueue_<obj name></obj></b> : to lock the table
            <b>dequeue_<obj name></obj></b> : to release the lock
        </p>
        
    </p>
    <h2>Important Transactions</h2>
    <p>
            <table style="width:50%">
                <tr><td>SE11</td><td>Data Dictionary Initial Screen (SE12 Display only)</td></tr>  
                <tr><td>SE13</td><td> ABAP Dictionary : Technical Settings</td></tr>  
                <tr><td>SE14</td><td>Database Utility</td></tr>  
                <tr><td>SE15</td><td>Repository Information System</td></tr>  
                <tr><td>SE16</td><td>Data Browser</td></tr>  
                <tr><td>SE17</td><td>General table Display </td></tr>   
                <tr><td>SE55</td><td>Table View Maintenance</td></tr>  
                <tr><td>SM30</td><td>Table Maintenance</td></tr>  
            </table>
    </p>

    <h2>Module</h2>
    <p>
     Is a place to put a <b>sequence of ABAP statements</b>.
    Then, instead of placing all of the statements in your main program,
      you just call the module.    
    </p>
    
    <h2>macros</h2>
    <p>
         If you want to reuse the same set of statements more than once in a program, you can include them in a macro.
        . You can only use a macro within the program in which it is defined, 
        . It can only be called in lines of the program following the definition.
        . Macros can be useful for long calculations or complex WRITE statements.

        <h3>Syntax</h3>
        <pre>
            DEFINE <macro_name>
            'Macro Statements
            END-OF-DEFINITION
        </pre>

        Macros can use Parameters &N where N = 1,2,3...
        Example:
        <pre>
            DATA: number1 TYPE I VALUE 1.
            DEFINE increment.
            ADD 1 to &1.
            WRITE &1.
            END-OF-DEFINITION.

            Increment number1.
            WRITE number1.
        </pre>
        
    </p>
    <h2> Include Programs</h2>
    <p>
        . Include Programs are solely for modularizing source code, and have no parameter interface.
        . they  allow use of the same source code in different programs. 

        <h3>Syntax</h3>
        <pre>
                Include < include program Name >
        </pre>

        . Include programs cannot call themselves.
        . Include programs must contain complete statements.
        . Example:
        <pre>
                INCLUDE ZILX0004.
                WRITE: / 'User', SY-UNAME,/ 'Date', SY-DATUM.    
                ================================    
                PROGRAM ZRPM0001.     
                INCLUDE ZILX0004.
        </pre>
    
    </p>
    
    <h2>  Subroutines  </h2>
    <p>
        . Subroutines are procedures defined and used in program.
        . If you want a function to be reusable throughout the system, use a function module.
        
        <h4>Syntax :</h4>
        <pre>
            FORM < Subroutine > [< pass >].
                < Statement block >.   
            ENDFORM.
        </pre>
        <br>
    </p>
    
    <h2> Types of Subroutines </h2>
    <p>
        <h3>Internal</h3>
        <p>
                . Internal subroutine defined in same program being called.
                . they Can access all the data objects declared in the main ABAP/4 program.
        
            </p>
        
        <h3>External</h3>
        <p>
                . External subroutine defined outside the program being called.
                . they Need to use the < pass > option or declare data objects in common parts of memory.
        
        </p>
        
    </p>
    
    <h2> Calling a Subroutine Internal Subroutines</h2>
    <p>
        <pre>
            PERFORM < subroutine > [< pass >]
        </pre>
        which:
        < subroutine > = Name of the subroutine
        < pass >      = Parameters being passed
                
        . Data declared in main program is automatically available.

    </p>
    
    <h2>External Subroutines</h2>
    <p>
        <pre>
        PERFORM < subroutine >(< Program>) [< pass>].

        PERFORM < subroutine> (< Program>) [< pass>] [IF FOUND].

        PERFORM (< subroutine>) IN PROGRAM  (< Program>) [< pass>] [IF FOUND].

        PERFORM < index> OF < subroutine1> < subroutine2> < subroutine3> [< pass>]. 
        </pre>
        
        <h3>    Points to Note    </h3>
        <p>
                . <b>Nested calls</b> are allowed in subroutines (i.e. PERFORM within a FORM ... ENDFORM ).
                . <b>Recursive calls</b> are also possible.
                . To define <b>local data</b>, use the DATA statement after FORM .
                . To define <b>global data</b> used within a subroutine, use the LOCAL statement after FORM . 
                . The values are saved when you enter the subroutine and then released at the end (from the stack)
                . Each time you enter the subroutine,
                the data is recreated   (with an initial value)
                and released at the end (from the stack).

        </p>
    </p>

    <h2>Function Modules</h2>
    <p>
        Function Modules are <b>general purpose ABAP routines</b> that anyone can use.
        . Infact , there are a large number of <b>standard function Modules</b> available.
        . Function Modules are organized into <b>Function Groups</b>:
        . A Function module always belongs to a Function Group.
        Syntax
        <pre>
                FUNCTION < function module>  
                < Statements>  
                ENDFUNCTION
        </pre>
        <h3>Call a Function Module</h3>
        <p>
            To call a function module, use the CALL FUNCTION statement:
            <pre>
            CALL FUNCTION < module >
                [EXPORTING  f1 = a 1.... f n = a n] 
                [IMPORTING  f1 = a 1.... f n = a n] 
                [CHANGING   f1 = a 1.... f n = a n]
                [TABLES     f1 = a 1.... f n = a n]
                [EXCEPTIONS e1 = r 1.... e n = r n [ERROR_MESSAGE = r E]     
                [OTHERS = ro]].
            </pre>
        </p>
            
        <h3>How to create a Function Module</h3>
        <p>
            <ol>
                <li> Create a function Group (say "ZCAL").</li>   
                <li>    Create a function module, set the attributes like <br>
                (Function group, Application, Short Text and Process Type) and Save.</li>
                <li>Include file "LZCALU01" will have source code of first function module.</li>    
                <li>Include file "LZCALTOP" will have global data.</li>    
                <li>  Main program "SAPLZCAL" contains</li>  
                <li> Global data Include file "LZCALTOP"</li>   
                <li>Function modules include file "LZCALUXX"</li>    
                <li>   User defined Include files "LZCALF..", "LZCALO.." and "LZCALI.."</li> 
                <li>   Define interface parameters and Exceptions</li> 
                <li>   Write the source code</li> 
                <li> Activate Function Module</li>   
                <li>   Testing the Function Module - Single Test & Debugging</li> 
                <li>  Documenting and Releasing a Function Module</li>  
            </ol>
        </p>
    </p>
    
    <h2>Function Groups</h2>
    <p>
        . Function groups <b>are containers</b> for function modules.
        . There are a large number of <b>standard Function Groups</b>.
        . All of the function modules in a function group <b>can access the global data</b> of the group.
        . Like executable programs (type 1) and module pools (type M), 
            Function groups can contain screens, selection screens, and lists.

        <b>Points to Note</b>
            
                - Function Groups cannot be executed.
                - The name of a function group can be up to 26 characters long.
                - When you create a function group or function module, the main program and include programs are generated automatically.   
                - Function groups encapsulate data.
        <br>
        <b>How to create a Function Group</b>
        
            - Goto Transaction SE80.
            - Select Program in the DropDown.
            - Write the name of the Function Group That you want to create.
                Generally User made Function groups start with "Z". e.g. - <Z_FUNCTION_GROUP_NAME> . Hit Enter Key.
            - Note that The TOP Include is create by default if the user checks the option of creating a TOP include.   
    </p>

    <h2>Open SQL & Native SQL </h2>
        <h3>Types of SQL</h3>
        <p>
            In ABAP, there are 2 types of SQL :
            <b>OPEN SQL   </b> 
                    Open SQL allows to access the database tables declared in the ABAP dictionary <b>regardless of the database platform</b> 
                    that the system is using.
            
            <b> NATIVE SQL </b> 
            
                Native SQL allows to use <b>database-specific</b> SQL statements in an ABAP program. 
                This means that you can use database tables that are not administered by ABAP dictionary,
                and therefore integrate data that is not part of the R/3 system.
        </p>
        
        <h3>Open SQL </h3>
        <p>
            . Open SQL thus provides a uniform syntax and semantics for all of the database systems supported by SAP. 
            . Open SQL statements can only work with database tables that have been been created in the ABAP dictionary.
        
        </p>
        <h3>Basic Open SQL Commands</h3>
        <p>
            <ul>
            <li> SELECT</li>    
            <li>INSERT</li>     
            <li>UPDATE</li>    
            <li>MODIFY</li>     
            <li>DELETE</li>     
            <li>OPEN CURSOR,FETCH, CLOSE CURSOR</li>     
            </ul>
            
            Example that Output the passenger list for the Lufthansa flight 0400 on 28-02.1995:
            <pre>
                    TABLES SBOOK.
                    DATA C TYPE CURSOR,        
                    WA LIKE SBOOK.
                    OPEN CURSOR C FOR SELECT * FROM SBOOK WHERE CARRID = 'LH '
                    AND CONNID = '0400'
                    AND FLDATE = '19950228'
                    ORDER BY PRIMARY KEY.
                    DO.
                    FETCH NEXT CURSOR C INTO WA.
                    IF SY-SUBRC <> 0.
                    CLOSE CURSOR C.
                    EXIT.
                    ENDIF.
                    WRITE: / WA-BOOKID, WA-CUSTOMID, WA-CUSTTYPE,
                    WA-SMOKER, WA-LUGGWEIGHT, WA-WUNIT,
                    WA-INVOICE.
                    ENDDO.
            </pre>
            <br>
            <h4>Open SQL Return Codes</h4>
            <p>
                All Open SQL statements fill the following two system fields with return codes :
                <b>SY-SUBRC</b>
                After every Open SQL statement,
                the system field SY-SUBRC contains the <b>value 0 if the operation was successful</b>, a value other than 0 if not.
                <b>SY-DBCNT</b>
                After an Open SQL statement, the system field SY-DBCNT contains the <b>number of database lines processed</b>.    
                <br>    
            </p>
        </p>
        
        <h3>Native SQL</h3>
        <p>        
            As already mentioned, Native SQL allows you to use database-specific SQL statements in an ABAP program.
            To use Native SQL statement, you must precede it with the EXEC SQL statement, and follow it with the ENDEXEC statement.

            Syntax
            <pre>
                EXEC SQL [PERFORMING < form>].
                    < Native SQL statement>
                ENDEXEC.
            </pre>
            . There is no <b>period</b> after Native SQL statements. 
            . <b>Comments:</b> using inverted commas (") or an asterisk (*) at the beginning of a line in a native SQL statement
            does not introduce a comment as it would in normal ABAP syntax. 
            . <b>Casee sensivity:</b>You need to know whether table and field names are case-sensitive in your chosen database.
            . <b> host variables</b> :In Native SQL statements, the data is transported between the database table and the ABAP program using<b> host variables</b>.
            These are declared in the ABAP program, and preceded in the Native SQL statement by a colon (:).
            . You can use elementary structures as host variables. 
            . Exceptionally, structures in an INTO clause are treated as though all of their fields were listed inpidually.

            . As in Open SQL, after the ENDEXEC statement,<b>SY-DBCNT</b>  contains the number of lines processed.
            . In nearly all cases, <b>SY-SUBRC</b>  contains the value 0 after the ENDEXEC statement.

        </p>
    

    <h2>Open SQL - Performance Rules</h2>
    <p>
        To improve the performance of the SQL and in turn of the ABAP program, one should take care of the following rules :

        <h3>Keep the Result Set Small</h3>
        Using the where clause
        If only one record is required from the database, use SELECT SINGLE whenever possible

        <h3>Minimize the Amount of Data Transferred</h3>
        <ul> <li>Restrict the number of lines</li>
            <li>If only certain fields are required from a table, use the SELECT &lt;field1&gt; &lt;field2&gt; INTO ... statement</li>
            <li>Restrict no of columns</li>
            <li>Use aggregate functions</li>
        </ul>
        <br>
        <h3>Minimize the Number of Data Transfers</h3>
            <ul> <li>Avoid nested select loops</li>
                <li>An alternative option is to use the SELECT .. FOR ALL ENTRIES statement.
                    This statement can often be a lot more efficient than performing a large number 
                    of SELECT or SELECT SINGLE statements during a LOOP of an internal table.</li> 
            </ul>
            <ul>
                <li>Use dictionary views</li>
                <li>Use Joins in the FROM clause</li> 
                <li>Use subqueries in the where clause</li> 
            </ul>
        <br>
        <h3>Minimize the Search Overhead</h3>
            <ul> <li>Use index fields in the where clause</li>
                <li>When accessing databases, always ensure that the correct index is being used .</li>
            </ul>
        <br>
        <h3>Reduce the Database Load</h3>
            <ul>
                <li>Buffering</li> <li>Logical databases</li> <li>Avoid repeated database access</li>
            </ul>

            <h3>Using Internal Tables to Buffer Records</h3>
            <ul> <li>To avoid executing the same SELECT multiple times (and therefore have duplicate selects),
                an internal table of type HASHED can be used to improve performance.</li>
            </ul>
    </p>

    <h2> Internal Table</h2>
    <p> Internal tables are <b>used to obtain data</b> from a fixed structure for dynamic use in ABAP.
                Each line in the internal table has the same field structure. 
                The main use for internal tables is for storing and formatting data from a database table 
                within a program. 
        <h3> Work Area </h3>
        <p> Work areas are single rows of data. 
                    They should have the same format as any of the internal tables. 
                    It is used to process the data in an internal table  one line at a time.
        </p>
        <h3> Difference Between Internal Table and a Work Area ?</h3>
        <p>
            <p align="center">
                 <a href="http://guru99.com/images/sap/2011/01/sap-internal-table.jpg" class="jh-image-popup-colorbox cboxElement">
                <img alt="SAP ABAP Internal Table: Create, Read, Populate, Copy &amp; Delete" class="aligncenter size-full wp-image-974"
                height="273" src="http://guru99.com/images/sap/2011/01/sap-internal-table.jpg" title="sap-internal-table" width="413">
                </a>
            </p>
        </p>
        <h3>Types of Internal Tables</h3>
        <p>
            There are 2 types of internal tables. 

            <ol>
                <li> Internal tables <b> with HEADER line</b></li> 
                <li> Internal tables <b>without HEADER line.</b></li>
            </ol>
            
            <h3>Internal Tables with Header Line </h3> 
            <ul>
                <li> Here the system automatically creates the work area.</li> 
                <li> The work area has the same data type as internal table.</li>
                <li> This work area is called the HEADER line.</li>
                <li> It is here that all the changes or any of the action on the contents of the table are done.
                    As a result of this, records can be directly inserted into the table or accessed from the internal table directly.

                </li> 
            </ul>
            <h3> Internal Tables without Header Line: </h3>
            <ul> 
                <li> Here there is no work area associated with the table.
                </li>
                <li> Work area is to be explicitly specified when we need to access such tables.
                </li>
                <li> Hence these tables cannot be accessed directly.</li>
            </ul>
        </p> 
        <h3> Creating Internal Tables</h3>
        <p>
            There are <b> many</b> ways to create an Internal Table :
            
            <b>1.By Using the Type Statement</b>
            <p>
                Let us now create a Internal table <em>itab </em>using the TYPE statement.
            
                <b>syntax :</b>
                <pre>
                    Types : begin of line,
                    column1 type I,
                    column2 type I,
                    end of line.
                </pre>
                <br>
                <p> Example: </p>
                <pre>
                    TYPES : begin of line,
                    empno		type I,
                    empname(20)   	type c	,
                    end of line.
                </pre>
                <br>
                <p>
                    The TYPES statement creates a structure <em>line </em>as defined.
                    To actually create an Internal Table 
                    <em>itab</em> use the following command- &nbsp;
                </p>
                <pre>
                    Data itab type line occurs 10.
                </pre>
                <br>
                An internal table <em>itab </em>is created with the structure of line.
                    Besides declaring the structure of an internal table, the OCCURS clause also 
                    defines how many table entries are maintained in main storage(in this case 10).
                    Extra records are written out to paging area and can effect performance
            </p>   
            <b>2.By referring to another Table</b>
            <p>
                You can&nbsp; create an internal table by referring to an existing table.
                The existing table could be a standard SAP table, a Z table or another internal table.<br> 
                <b> Syntax :</b>
                    <pre>Data &lt;f&gt; &lt;type&gt; [with header line].

                    </pre>
                    
                <p> Example- </p>
                    <pre>DATA itab TYPE line OCCURS 10 with header line.</pre>

                Here an internal table <em>itab </em>is created of the type line with a header line. Please note
                        "with header line" is optional
            </p>          
            <b>3.By referring to existing Structure </b>
            <p>
                Syntax-
                </p>
                <pre>Data	&lt;f&gt; LIKE &lt;struct&gt; occurs n [with header line].
                    
                </pre>
                <br><p> Example- </p><pre>DATA itab LIKE sline OCCURS 10.
                </pre>
                <br><p> Here&nbsp; a table <em>itab </em>is created having a structure same as that of sline
            </p>
            <b>4.By creating a new Structure</b>
            <p>
                Let us now create an internal table with a structure of our own.
                Here the table is created with an Header line, <b>by default</b>.
                <br> Syntax -
                <pre>Data : Begin of &lt;f&gt; occurs &lt;n&gt;,
                    &lt;component declaration&gt;,          
                    .................................,
                    End of &lt;f&gt;.
                </pre>
                <br><p> Example - </p>
                <pre>Data : Begin of itab occurs 10,
                    
                    column1       type I,
                    
                    column2(4)  type C,
                    
                    column3      like  mara-ernam,
                    
                    End of itab.
                </pre>
                <br><p> Internal table <em>itab </em>is created </p>
            </p>   
        </p>     
        <h3>Populating Internal Tables</h3>
            <p>  
                    Now that we have successfully created some internal tables, let us see how do we populate them with some records.
                    There are various methods available to populate tables
                    <b>1.Append Data line by line</b>
                    <p>
                        The first method available is the use of the APPEND statement.
                        Using the APPEND statement we can either add one line from another work area to the internal table or 
                        we can add one initial line to the internal table..
                        
                        Syntax :
                        <pre>APPEND [&lt;wa&gt; TO / INITIAL LINE TO] &lt;itable&gt;.</pre> 
                        
                        Here work area <em>&lt;wa&gt; </em>or the Initial Line is appended to the internal table <em>&lt;itable&gt;.</em>
                        The system variable <em>SY-TABIX</em> contains the index of the appended line.
                        Example:
                        <pre>
                            Data: Begin of itab occurs 10,
                            col1 type C,
                            col2 type I,
                            end of itab.
                        
                            Append initial line to itab.
                        </pre> 
                        <br>
                            Results : ' ' '0'
                        <br> Initial lines adds a line initialized with the correct value for its type to the table. 
                        Here ,&nbsp; col1 is an integer and col2 is a character. 
                        Then APPEND initial line , adds a line initialized with respect to the data type of the columns, 
                        i.e. 0 for Col1 and space for Col2. 
                    </p>
                    <b>2.Using COLLECT statement</b>
                    <p>
                         COLLECT is another form of statement used for populating the internal tables.
                            Generally COLLECT is used while inserting lines into an internal table with unique standard key.
                            <br> <br> Syntax-<br>
                            <pre>
                                COLLECT [&lt;wa&gt; INTO] &lt;itable&gt;.

                            </pre> 
                            Incase of tables with Header line, INTO option is omitted. 
                            Suppose there is already an entry having a key same as the one you are trying to append,
                                then a new line is not added to the table,
                                but the numeric fields of both the entries are added and only one entry corresponding to the key is present.
                                Value of SY-TABIX is changed to the row of the original entry. 
                                Else COLLECT acts similar to APPEND and SY-TABIX contains the index of the processed line.
                    </p>
                    <b> 3.Using INSERT statement</b>
                    <p>
                        INSERT statement adds a line/work area to the internal table.
                        You can specify the position at which the new line is to be added 
                        by using the <em>INDEX </em>clause with the INSERT statement.
                        <b>Syntax</b>
                        <pre>INSERT [&lt;wa&gt; INTO / INITIAL LINE INTO] &lt;itable&gt; [index &lt;idx&gt;].

                        </pre>
                        Here,&nbsp; the work area <em>&lt;wa&gt;</em> or INITIAL LINE is inserted into internal table &lt;<em>itable&gt;</em> 
                        at index <em>&lt;idx&gt;</em>.
                    </p>
            </p>
        <h3> Copying Internal Tables</h3>
            <p>
                The contents of one internal table can be copied to another by using the APPEND LINES or INSERT LINES statement. 
                A more simpler way is to usetany of the following syntax's.<br> 
                <pre>MOVE  &lt;itab1&gt; To &lt;itab2&gt;.
                    
                    OR
                    
                    &lt;itab1&gt; = &lt;itab2&gt;.
                </pre> 
                These copy the contents of ITAB1 to ITAB2. Incase of internal tables with header line we have to use [] 
                inorder to distinguish from work area.
                    So, to copy contents of internal tables with header line the syntax becomes,
                    <pre>itab1[] = itab2[].
                    </pre>
            </p>
        <h3> Read Internal Tables</h3>  
            <p>
                
                <b> 1. Using Loop -Endloop </b>
                One of the ways of accessing or reading the internal table is by using LOOP-ENDLOOP.
                <br> Syntax
                <pre>LOOP AT &lt;itable&gt; [INTO &lt;wa&gt;]           
                        ...................................
                        ENDLOOP.
                </pre>
                
                Here when you say LOOP AT ITABLE, then the internal table ITABLE is read line by line.
                You can access the values of the columns for that line during any part of the LOOP-ENDLOOP structure. 
                The value of the <em>SY-SUBRC</em> is set to <b>0</b>,
                even if only one record is read.
                
                <b>2. Using READ</b>
                
                The other method of reading the internal table is by using the READ statement.
                <br> <br> Syntax-<br> 
                <pre>
                    READ TABLE &lt;itable&gt; [INTO &lt;wa&gt;] INDEX &lt;idx&gt;.
                </pre> 
                This statement reads the current line or line as&nbsp; specified by index <em>&lt;idx&gt;</em>. 
                The value of <em>SY-TABIX </em>is the index of the line read. If an entry with the specified index is found,
                then <em>SY-SUBRC</em> is set to 0. If the specified index is less than 0, then run-time error occurs. 
                If the specified index exceeds table size then SY-SUBRC is set to 4.
            </p>         
        <h3> Deleting Internal Tables</h3>
            <p>
                There are many ways for deleting lines from an internal table.
                <b>1.Deleting lines in a loop.</b>
                <br> This is the simplest way for deleting lines.<br> <br> 
                Sytax
                    <pre>DELETE &lt;ITABLE&gt;.</pre> 
                This statement works only within a loop. 
                It deletes the current line. You can delete the lines in a loop conditionally 
                by adding the WHERE clause.
                <b>2.Deleting lines using the index.</b>
                This is used to delete 
                a line from internal table at any know index.
                Syntax :
                <pre>DELETE &lt;ITABLE&gt; INDEX &lt;IDX&gt;.</pre>
                The line with the index &lt;IDX&gt; is deleted. The index of the following line is decremented by 1.
                <br>
            </p>
    </p>

    <h2> SAP ABAP Table Control  </h2>
    <p>
        . Table controls and step loops 
        are objects for screen table display that you add to a screen in the Screen Painter.
        . From a programming standpoint, table controls and step loops are almost exactly the same.
        . Table controls are simply improved step loops that display data with the look and feel associated with tables in desktop applications.
        
        . With table controls, the user can:

        <ul> 
            <li> Scroll through the table vertically and horizontally</li> 
            <li> Re-size the width of a column</li> 
            <li> Scroll wi  thin a field (when field contents are wider than the field)</li>
            <li> Select table rows or columns</li> 
            <li> Re-order the sequence of columns</li> 
            <li> Save the current display settings for future use</li>
        </ul>
        <br>
        Table controls also offer special formatting features .
        Table Control provides :

        <ul> 
            <li> automatic table resizing (vertical and horizontal) when the user resizes the window</li>
            <li> separator lines between rows and between columns (vertical and horizontal)</li> 
            <li> column header fields for all columns</li> 
        </ul>
        <br>
        <p> 
            Step loops  table rows can span more than one line on the screen.
            A row of a table control, on the other hand, must always be contained in a single line 
            (although scrolling is possible).
            
            <em><strong>
            In general, many of the features provided by the table control are handled locally by your system's SAPgui frontend,
                so you do not need to program them yourself. The only notable exception to this is vertical scrolling</strong>
            </em>.
        </p>    
        Example (Transaction TZ60)
            
        <b>Syntax  </b>
        To handle table controls in ABAP programs, you must declare a control in the declaration part of the program 
            for each table control using the following statement:<br>

        <pre>
            CONTROLS &lt;ctrl&gt; TYPE TABLEVIEW USING SCREEN &lt;scr&gt;
        </pre>
        <p> where <em>&lt;ctrl&gt;</em> is the name of the table control on a screen in the ABAP program.
            The control allows the ABAP program to read the attributes of the table control and
            to influence the control .Here,
            <em>&lt;scr&gt; </em>
            is the screen number where the initial values of the table are loaded.
                Cursor Position for a table control can be set in following ways:
                At PBO you can set the cursor on a specific field of a specific row of a table control.
        </p>
                
        <pre>SET CURSOR FIELD &lt;f&gt; LINE &lt;lin&gt; [OFFSET &lt;off&gt;]</pre>
        <p>
            Using the optional addition <em>OFFSET</em>, you can enter the offset of the cursor in
            the field as described under Setting the Cursor Position.<br> <br>
            At PAI you can read the current cursor position.
        </p>
        <pre>GET CURSOR FIELD &lt;f&gt; LINE &lt;lin&gt; ...</pre>
        <p> In addition to the information given under Finding Out the Cursor Position, field 
            <em>&lt;lin&gt;</em> contains information on which row of the table control the cursor is currently on.
            You can also use 
        </p>
        <pre>GET CURSOR LINE &lt;lin&gt;.</pre>
        <br>
        <p> to&nbsp; determine the row of the table control. <em>SY-SUBRC</em> allows you to check if the
            cursor is placed in a row of a table control.<br> <br> For getting the corresponding line of the internal table : 
        </p>
        <pre>GET CURSOR line &lt;lin&gt;.            
                    ind = &lt;table_control&gt;-top_line + &lt;lin&gt; - 1.
                    Read table &lt;itab&gt; index ind.
        </pre>
        <p> The system variable <em>stepl </em>
        - contains the current table line index in a loop ... endloop. 
        <em>Loopc</em> - contains number of lines visible in the table
        <strong><em>To create a table control</em></strong>
        1.Add a table control element to your screen
        2.Give a name to the table control. 
        In the ABAP program declare a structure with the same ( CONTROLS &lt;tcl&gt; type TABLEVIEW USING SCREEN &lt;scrn &gt;)
        3.To create fields go to the Dict./Program fields function.
        </p>
        <ul> 
                <li> Enter the name of the structure whose fields you want.
                    (If you want it to pick it from dictionary of your program click the relevant puhbutton).
                </li>
                <li> In the field list choose the fields you want and choose ok.</li> 
                <li> Click in the table control area</li> 
        </ul>
        <p> If you want a selection column , check the appropriate check box in the attributes and give it a name.
                Create the field in the ABAP program.
                In the PBO you should have the statement
        </p>
        <pre>
            LOOP at &lt;itab&gt; USING CONTROL &lt;cntrl_name&gt;.
        ENDLOOP.
        </pre>
        <p> In the PAI you should have. 

        </p>
        <pre>LOOP at &lt;itab&gt;.
            
            ENDLOOP.
        </pre>
        <p> It is within the loops that data transfer happens between the screen and the internal table.
            When you populate the internal table use DESCRIBE TABLE &lt;itab&gt; LINES &lt;cntrl_name&gt;-lines,
                to store the total number of lines in the control.
                The FIELD statement can be used to control when the data transfer happens
                <br> <br> To change the attributes of inpidual cells temporarily change the SCREEN table in the PBO.
                You can change the attributes of the structure created by the CONTROLS statement 
        </p>
        <pre>&lt;cntrl&gt;-fixed_cols etc are the attributes of the control
        
        &lt;cntrl&gt;-cols-index etc are the attributes of the columns.
        
        &lt;cntrl&gt;-cols-screen-invisible etc are the screen attributes of each column.
        </pre>
    </p>

    <h2 > ABAP Report Programming </h2> 
    <p> 
        SAP-ABAP supports two types of Programs :
        -&nbsp; Report Programs &amp; Dialog Programs.
    
        Report Programs are used when large amounts of data needs to be displayed
        

        <b>Purpose/Use of Report Programs</b> 
        <ul>
            <li> They are used&nbsp; when data from a number of tables have to be selected
            and processed before presenting</li>
            <li> Used when reports demand&nbsp; a special format</li> 
            <li> Used when the report has to be downloaded from SAP to an Excel sheet to be distributed across.</li> 
            <li> Used when the report has to be mailed to a particular person.</li>
        </ul>
        <br>
        <b>Important Points to Note About Report Program</b> 

        <ul>
            <li> Report Programs are always Executable Programs. Program Type is always 1.</li>
            <li> Every Report program corresponds to a particular Application Type i.e. 
            either with Sales &amp; Distribution, FI - CO etc. It can also be Cross Application i.e. type '*'.</li> 
            <li> Report Programming is an Event-driven programming.</li>
            <li> The first line of a report program is always Report <em><strong>&lt;report-name&gt;.</strong></em>
            </li>
                <li> To suppress the list heading or the name of the program the addition <em><strong>
                    No Standard Page Heading </strong></em>is used.</li>
            <li> The line size for a particular report can be set by using the addition <em><strong>
                line-size &lt;size&gt;.</strong></em></li> 
            <li> The line count for a particular page can be set by using the addition <em><strong>line-count n(n1)</strong>
            </em>. N is the number of lines for the page and N1 is the number of lines reserved for the page footer.</li>
                <li> To display any information or error message we add a message class to the program using the addition:
                    <em><strong>Message-id &lt;message class name&gt;. </strong></em>Message classes are maintained in SE91.</li> 
        </ul> 
        
        Therefore an ideal report program should start with:
        <pre>Report &lt;report name&gt; no standard page heading
        line-size &lt;size&gt;

        line-count &lt;n(n1)&gt;
        
        message-id &lt;message class&gt;.
        </pre>
    </p>
            
    <h2> Selection Screen</h2>
    <p> "Selection screen"&nbsp; is the screen where one specifies the input values for which the program should run.
        The selection screen is normally generated from the :
        
        <ol>
            <li> Parameters</li>
            <li> Select-Options</li>
        </ol>
        
        <b> Syntax </b>
        <pre>Selection-screen begin of screen &lt;screen #&gt;
            selection-screen begin of block &lt;#&gt;&nbsp; with frame title &lt;text&gt;
            .........
            .........
            selection-screen end of block &lt;#&gt;
            selection-screen end of screen &lt;screen #&gt;
        </pre>
        <b>Parameters</b>
            Parameters help one to do dynamic selection. They can accommodate only one value for one cycle of execution of the program.
            <b> Syntax</b>
            Defining parameters as a data type 
            
            <pre>Parameters p_id(30) type c.</pre>
            
            <b> Defining parameters like a table field:</b>
            <pre>Parameter p_id like &lt;table name&gt;-&lt;field name&gt;.</pre>
            <b> Parameters can be Checkboxes as well as Radiobuttons: </b>
            <pre>Parameters p_id as checkbox.Parameters p_id1 radiobutton group &lt;group name&gt;.
            Parameters p_id2&nbsp; radiobutton group &lt;group name&gt;.
            </pre>
            <b> Parameters can be listbox. </b>
            <pre>
                Parameter p_id like &lt;table name&gt;-&lt;field name&gt; as listbox
            </pre>
        
            <b>Select Options</b>
                A Select-Option is used to input a range of values or a set of values to a  program
            <b>Syntax </b>
            <pre>select-options s_vbeln for vbak-vbeln.</pre>
            <br> You can also define a select option like a variable 
            <pre>select-options s_vbeln for vbak-vbeln no intervals no-extension</pre>
            <br>
    </p>

    <h2><a id="2"></a> Events in an ABAP Report Program</h2>
    <p>
        ABAP report programs are <em><b>event driven programs</b></em>. 
            The different events in a report Program are:
        <br>
        
        <b>Load-of-program </b>
        
        <ul>
            <li> Triggers the associated event in an internal session after loading a program of type 1, M, F, or S.</li>
            <li> Also runs the associated processing block once and once only for each program and internal session.</li>
            <li> The processing block LOAD-OF-PROGRAM has roughly the same function for an ABAP program of type 1, M, F or S
                as a constructor has for classes in ABAP Objects</li>
        </ul>

        <b>Initialization.</b> 
        
        <ul> 
            <li> This event is executed before the selection screen is displayed .</li>
            <li> Initialization of all the values.</li> 
            <li> You can assign different values other than the values defaulted on the selection screen .</li>
                <li> You can fill your selection screen with some values at runtime.</li>
        </ul>
        <b>At Selection-Screen.</b>
        <ul> 
            <li> The event is processed when the selection screen has been processed (at the end of PAI ).</li>
            <li> Validation &amp; Checks of inputted values happen here</li>
            </ul>
        <b>Start-of-Selection.</b>
        </p>
        <ul> <li> Here the program starts selecting values from tables.</li>
        </ul>
        <b>End-of-selection.</b>
        </p>
        <ul> 
            <li> After all the data has been selected this event writes the data to the screen.</li> 
        </ul>
        <b>Interactive Events</b> 
        
        <ul>
            <li> Used for interactive reporting. It is used to create a detailed list from a basic list.</li> 
        </ul>
    </p>

    <h2>Formatting the report            </h2>
    <p>
        <p> ABAP allows the reports to be formatted as the user wants it to be.
            For example, "Alternate Lines" must appear in different colors and the "Totals" line should appear in Yellow.
        Syntax 
        </p>
        <pre>Format Color n
            Format Color n Intensified On
        </pre>
        <p>
            <strong>n</strong>
                may correspond to various numbers<br>
            Please note that there are other additions along with format as well 
        </p>
        <pre>FORMAT COLOR OFF INTENSIFIED OFF INVERSE OFF HOTSPOT OFF INPUT OFF</pre>
        <br>
    </p>

    <h2> Interactive Report Programming</h2>
    <p>
            <ul> <li> Using Interactive Programming users&nbsp; can actively control the data retrieval and display of data</li>
                <li> Used to&nbsp; create a detailed list from a very basic list</li>
                <li> The detailed data is written on a secondary list.</li> 
                <li> The secondary list may either completely overlay the first screen or one can display it in a new screen</li>
                <li> The secondary lists can be themselves interactive.</li> 
                <li> The first list may also call a transaction.</li> 
                <li> There are different events associated with interactive programming.</li>
            </ul>
            <p> Some commands used for interactive programming
                <em><strong>Hotspot</strong></em><br>
                If one drags the mouse over the data displayed in the report the cursor changes to a Hand with
                an Outstretched Index finger. An hotspot can be achieved using the FORMAT statement.
            </p>
            <pre>Syntax:      Format Hotspot On (Off).</pre>
            <p> <em><strong>Hide</strong></em>
                <br> This command helps you to store the field names based on which one will be doing further processing to
                get a detailed list. It is written directly after the WRITE statement for a field.
                When a row is selected the values get automatically filled in the variables for further use. </p>
                <pre>Syntax:     Hide &lt;field-name&gt;.

                </pre>
    </p>

    <h2>Logical Databases</h2>
    <p>
        <ul> <li> Instead of using "Select" queries you can use logical database to retrieve data for a program.</li> 
            <li> Logical databases are created by transaction <strong>SE36</strong></li> 
            <li> The name of a logical database can be up to 20 characters long. It may begin with a namespace prefix.

            </li> 
            <li> The data is selected by another program and one can access the data using GET &lt;table-name&gt; 
                command which places the data in the work area &lt;table-name&gt;.</li>
        </ul>
        <p> 
            <em><strong>Advantages of a logical database over normal Select queries.</strong></em> 
            </p>
        <ol> <li> It offers check conditions to see whether the input is correct, complete and plausible</li>
                <li> It contains central authorization checks for database access</li>
                <li> Enhancements such as improvement in performance immediately apply to all reports
                    which use logical database.</li>
        </ol>
        <blockquote> 
            Note: Due to the complexities involved, logical databases are not used in most
            of the cases
        </blockquote>
        <p id="slidetag">&nbsp;</p>
    </p>

    <h2 > Dialog Programming Tutorial: Module Pool in SAP ABAP </h2>
    <p>                   
        SAP-ABAP supports two types of programs - Report Program and Dialog Program.
        If your ABAP program demands user input , Dialog programming is used.

        A user dialog is any form of interaction between the user and the program and could be any of the following 
        <ul> 
            <li> Entering data</li>
            <li> Choosing a menu item</li> 
            <li> Clicking a button</li>
            <li> Clicking or double clicking an entry</li>
        </ul>
         <p> Dialog program is also used when we need to navigate back and forth between screens
            Dialog programs are created with type as 'M' - Module Pool. They cannot be executed independently 
            and must be attached to at least one transaction code in which you specify an initial screen.
        </p>
    </p> 

    <h2> Difference between Report and Dialog Programs</h2>
    <p> 
            <img alt="Dialog Programming Tutorial: Module Pool in SAP ABAP" class="aligncenter  wp-image-944" 
            height="337"
            src="http://guru99.com/images/sap/2011/01/sap-dialog-programming.png"
                title="sap-dialog-programming" width="600"> 
        
        <p> <em><strong>Report Program:</strong></em><br>
                <br> A report is a program that typically reads and analyzes data in database tables without 
                changing the database.<br> <br> 
                <em><strong>Dialog Program:</strong></em><br> <br> A dialog program allows you to work interactively with 
                the system and to change the contents of the database tables. Each dialog program has a certain sequence
                of screens that are processed by the system one after the other.
        </p>
    </p>

    <h2> A Sample transaction processing in Dialog Programming</h2>
    <img src="http://guru99.com/images/sap/2011/01/sap-dialog-programming1.jpg">
                    

    <h2> Components of Dialog Program</h2>
    <p>
        Unlike report which generally entails the creation of one autonomous program which can be executed independently of other objects, 
        dialog program development entails development of multiple objects none of which can be executed on it's own.
        <strong><em> Instead all objects are linked hierarchically to the main program and and are executed
                    in a sequence dictated by the Dialog Main Program</em></strong>.
        
        The components of a dialog program  are:
        
        <b>Transaction code</b>
        <ul> 
            <li> The transaction code starts a screen sequence.</li> 
        <li> You create transaction codes in the Repository Browser in the ABAP Workbench or using Transaction SE93.</li>
            <li> A transaction code is linked to an ABAP program and an initial screen.</li>
            <li> You can start a screen sequence from any ABAP program using the CALL SCREEN statement.</li>
        </ul>
    
        <b>Screens</b>
        <ul> <li> Each dialog in an SAP system is controlled by one or more screens.</li>
            <li> You create screens using the Screen Painter in the ABAP Workbench through transaction SE51</li> 
            <li> Each screen belongs to an ABAP program.</li>
            <li> These screens consist of a "screen mask" or "layout" and its flow logic. The screen has a 
                layout that determines the positions of input/output fields and other graphical elements 
                such as checkboxes and radio buttons. A flow logic determines the logical processing within screen.</li> 
        </ul>
                        
        <b>GUI status</b>
        <ul>
            <li> Each screen has a GUI status(es) which are independent components of a program.</li>
            <li> This controls the <em>menu bars, standard toolbar, application toolbar</em> , 
            with which the user can choose functions in the application.</li>
            <li> You create them in the ABAP Workbench using the Menu Painter.</li>
        </ul>
        
        <b>ABAP Program</b>
        <ul>
            <li> Each screen and GUI status in the R/3 System belongs to one ABAP program.</li>
            <li> The ABAP program contains the dialog modules that are called by the screen flow logic,
                and also process the user input from the GUI status.</li>
                <li> ABAP programs that use screens are also known as dialog programs.</li>
                <li> In a module pool (type M program); the first processing block to be called 
                    is always a dialog module. However, you can also use screens in other ABAP programs, 
                    such as executable programs or function modules. The first processing block is
                        then called differently; for example, by the runtime environment or a procedure 
                        call. The screen sequence is then started using the CALL SCREEN statement.</li> 
        </ul>
        <b>Screen Flow Logic</b>
            <br> Screen Flow logic is primarily pided into four components.
        </p>
        <ul> 
            <li> Process Before Output (<strong>PBO</strong>)
                event: which is processed before the screen is displayed</li> 
                <li> Process After Input (<strong>PAI</strong>) event: which is 
                processed after a user action on the screen</li> 
                <li> Process on help request (<strong>POH</strong>):
                        which is processed when F1 is pressed</li> 
                <li> Process on value request (<strong>POV</strong>):
                    which is processed when F4 is pressed</li>
        </ul>
        <b>Dynpro </b>
        <ul>
            <li> A screen together with its Flow logic&nbsp; is called a Dynpro ("Dynamic Program" since the screen flow logic 
                influences the program flow)
            </li>
            <li> Each dynpro controls exactly one step of your Dialog Program.</li> 
            <li> The screens belonging to a program are <strong>numbered</strong>. The&nbsp; screen flow sequence 
            can be either linear or cyclic. From within a screen chain, you can even call another screen chain and, 
            after processing it, return to the original chain. You can also override the statically-defined next
                screen from within the dialog modules of the ABAP program.
            </li> 
        </ul>
        <b>ABAP Module Pool</b>
            <ul> 
                <li> On a PBO or PAI event a Dynpro calls an ABAP dialog program.&nbsp; 
                Collection of such programs is called the ABAP module pool.</li>
                <li> For example modules called at the PAI event are used to check the user input and to trigger
                        appropriate dialog steps, such as the update task.</li>
                <li> All dynpros to be called from within <strong>one</strong> transaction refer to a common module pool.</li>
            </ul>
        
        <h3>Structure of a Dialog Program</h3>            
        <img src="https://www.guru99.com/images/sap/2011/01/sap-dialog-programming2.png" width="500px">
    </p>        

    <h1 > ABAP Subscreens Tutorial: Call Subscreen in SAP </h1>
    <h2> CALL SUBSCREEN</h2>
    <p>
        <ul> 
            <li> A subscreen is an independent screen that is displayed in an area of another ("main") screen.</li> 
        <li> Subscreens allow you to embed one screen within another at runtime. You can include multiple sub-screens on main screen.</li>
        <li> The term subscreen applies both to the screen that you embed, and the area on the main screen in which you place it.
            This tutorial is about subscreen areas. The actual screens created through SE51 transaction, 
            are called subscreen screens if defined in screen attributes.</li>
        <li> When you use a subscreen, the flow logic of the embedded screen is also embedded in the flow logic of the main screen.
            Hence, Using subscreens on screens is like using includes in ABAP programs.</li> 
        </ul>
        <p> To use a subscreen, you must follow three simple steps </p>
        <ol>
            <li> Define the subscreen area(s) on a screen</li> 
            <li> Define suitable subscreen screens</li> 
            <li> Include the subscreen screen in the subscreen area.</li>
        </ol>
        Also, you need to adjust the frame of sub-screen and main screen. You need to name it in the field name field.
        <br> Further, you also need to adjust the fields within the subscreen to make them appear in main screen. 
        In case the sub-screen is defined to be larger than the available area in the main screen,
        only the part of subscreen will be visible that fits in the the area available. 
        The area is always measured from the top left corner of screen.
        Hence you should take adequate care while defining sub-screen areas and creating sub-screens.
        
        <strong> EXAMPLE</strong>
         For instance here we have defined two sub-screen areas on main screen and have attached 
        two different Sub-screen to corresponding areas. Whenever main screen is called, the PBO of main screen is called.
        But before display, the PBO's of each screen attached with sub-screen areas on main screen are also called.
        
        <img alt="ABAP Subscreens Tutorial: Call  Subscreen in SAP"  
                src="http:/guru99.com/images/sap/2011/01/sap-subscreen.jpg" title="sap-subscreen">
        
        <p> You can include a subscreen screen using the CALL SUBSCREEN statement in the flow logic of the main screen.
                <br> <br> To include a subscreen screen in the subscreen area of the main screen and call its PBO flow logic, 
                use the following statement in the PBO event of the main screen:
        </p>

        <pre>
            PROCESS BEFORE OUTPUT.

            CALL SUBSCREEN &lt;area&gt; INCLUDING [&lt;prog&gt;] &lt;dynp&gt;.
        </pre>
        <p> 
            This statement assigns the subscreen screen with number &lt;dynp&gt; to the subscreen area called &lt;area&gt;.
             You can also specify the program in which the subscreen screen is defined (optional).
              If you do not specify the program explicitly, the system looks for the subscreen screen in the same ABAP program
               as the main program. If it does not find a corresponding subscreen screen, a runtime error occurs. 
               The PBO flow logic of the subscreen screen is also included at the same point.
                This can call PBO modules of the ABAP program in which the subscreen screen is defined.
                 At the end of the subscreen PBO, the global fields from the program are passed to any identically-named screen fields
                  in the subscreen screen. The PBO flow logic of the subscreen screen can itself include further subscreens.
                  <br> <br> The name &lt;area&gt; of the subscreen area must be entered directly without inverted commas. 
                  You can specify the names &lt;prog&gt; and &lt;dynp&gt; either as literals or variables.
                   If you use variables, you must declare and fill identically-named variables in the ABAP program. 
                   The screen number &lt;dynp&gt; must be 4 characters long. If you do not assign a subscreen screen to an area,
                    it remains empty.<br> <br> To call the PAI flow logic of the subscreen screen, 
                    use the following statement in the PAI flow logic of the main screen: 
        </p>
        <pre>PROCESS AFTER INPUT.    
            CALL SUBSCREEN &lt;area&gt;.
        </pre>
        <p> This statement includes the PAI flow logic of the subscreen screen
                included in the subscreen area &lt;area&gt; in the PBO event.
                This can call PAI modules of the ABAP program in which the
                subscreen screen is defined. Data is transported between
                identically-named fields in the subscreen screen and the ABAP
                    program either when the PAI event is triggered, or at the
                    corresponding FIELD statements in the PAI flow logic of the
                    subscreen screen.<br> <br> <em><strong>Points to Remember

            </strong></em>
        </p>
        <ul> 
            <li> Names of elements of sub-screens within a screen should be unique</li>
            <li> You should not have OK_CODE or FCODE attached with sub-screen. The OK_CODE of main screen itself is OK_CODE of sub-screen</li>
            <li> Sub-screens cannot have any dialog modules containing SET TITLEBAR, SET PF-STATUS, SET SCREEN, LEAVE SCREEN
                or LEAVE TO SCREEN. This will cause runtime error.</li>
                    <li> You need to call it in the flow logic (both PBO and PAI) of the main screen.</li> 
                    <li> CALL SUBSCREEN is not allowed in CHAIN..ENDCHAIN and LOOP ENDLOOP statements</li>
                    <li> Can not have an AT EXIT-COMMAND module</li>
                    <li> The fields that you use are the global fields. They must be declared in the top include</li>
                    <li> If using subscreens from another dialog program the data transfer will not happen unless
                            you add specific code.</li>
        </ul>
    </p>
        
    <h1 > SAP Process On Value &amp; Process On Help-Request </h1>

    <h2>Process on Help-Request (POH) : F1 Help</h2>
        <p>
            <ul>
                <li>Whenever F1 is pressed the POH event&nbsp; for the specified data element&nbsp; is executed.</li>
                <li>If the PROCESS ON HELP-REQUEST event does not exist in the process logic of a screen,
                    the documentation of the field in the ABAP Dictionary is taken as a basis and displayed.&nbsp;
                    Even if that does not exit no help is displayed.</li>
                <li>To display field help documentation, you must code the following screen flow logic in the POH event:</li> 
            </ul>
            <pre>PROCESS ON HELP-REQUEST
                        FIELD &amp;lt;f&amp;gt; [MODULE &amp;lt;mod&amp;gt;] WITH &amp;lt;num&amp;gt;
            </pre>
            <ul> 
                <li>If there is screen-specific data element documentation for the field <em>&lt;f&gt;</em>,
                    you can display it by specifying its number <em>&lt;num&gt;</em>.
                    </li>
                <li>The number &lt;num&gt; can be a literal or a variable. The variable must be declared and filled in the corresponding ABAP program.</li> 
                <li>Note, the FIELD statement does not transfer the contents of the screen field <em>&lt;f&gt; </em>
                    to the ABAP program in the PROCESS ON HELP-REQUEST event. It just shows help documentation. That's it.</li> 
            </ul> 
            The module <em>&lt;mod&gt;</em> is defined in the ABAP program like a normal PAI module.
            The processing logic of the module must ensure that adequate help is displayed for the field in question. 
            Instead of calling an extra screen with text fields, you should use one of the following function modules 
            to display a suitable SAPscript document
            <p> <em><strong>HELP_OBJECT_SHOW_FOR_FIELD</strong></em> 
            </p>
            <ul>
                <li>This function module displays the data element documentation for components of any 
                    structure or database table from the ABAP Dictionary.
                    </li>
                <li>You pass the name of the component and structure or table to the import parameters FIELD and TABLE.</li>
            </ul>
            <em><strong>HELP_OBJECT_SHOW</strong></em>
            <ul>
                <li>Use this function module to display any SAPscript document.</li>
                <li> You must pass the document class (for example, TX for general texts, DE for data element documentation)
                    and the name of the document to the import parameters DOKCLASS and DOKNAME.
                    </li> 
                <li> For technical reasons, you must also pass an empty internal table with the line type TLINE 
                    to the tables parameter of the function module.</li> 
            </ul>
        </p>

    <h2>Process on Value (POV): F4</h2>
    <p>
        <ul>
            <li>When the user chooses the function Possible entries (F4), the system displays the possible input values for a field 
                (values, check table, matchcode), provided they were stored by the developer.
                </li> 
                <li>The event PROCESS ON VALUE-REQUEST is always processed if the user has called "Possible entries".</li> 
                <li>To define Possible values for a field on screen, you need to defined following in POV event of screen flow logic:</li>
        </ul> 
        <pre>PROCESS ON VALUE-REQUEST
                    
                    FIELD <em>field name</em> MODULE <em>module name</em>
        </pre>
        <ul> 
            <li>For Possible values, within module defined above, you should use the general function module 
                <strong>HELP_VALUES_GET_WITH_TABLE</strong> to get possible values from ABAP Dictionary.
            </li>
        </ul>
        There are some other functions that can also be used for input help :
        
        <strong>F4IF_FIELD_VALUE_REQUEST</strong>
        <ul>
            <li>Calls the input help of the ABAP Dictionary dynamically.</li>
                <li>You can pass the component names of a structure or database table of the ABAP Dictionary
                    to the function module in the import parameters TABNAME and FIELDNAME.</li>
            <li>The function module starts the ABAP Dictionary input help for this component.
                All of the relevant screen fields are read.</li>
            <li>If you specify the import parameters DYNPPROG, DYNPNR, and DYNPROFIELD, the user's selection is 
                returned to the corresponding field on the screen.</li>
            <li>If you specify the table parameter RETURN_TAB, the selection is returned into the table instead.

            </li> 
            </ul>
            <pre>MODULE VALUE_CARRIER INPUT.
                    
                    CALL FUNCTION 'F4IF_FIELD_VALUE_REQUEST'
                    
                    EXPORTING
                    
                    TABNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 'DEMOF4HELP'
                    
                    FIELDNAME&nbsp;&nbsp;&nbsp;&nbsp; = 'CARRIER1'
                    
                    DYNPPROG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;PROGNAME
                    
                    DYNPNR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;DYNNUM
                    
                    DYNPROFIELD= 'CARRIER'.
                    
                    ENDMODULE.
                </pre> 
                <strong>F4IF_INT_TABLE_VALUE_REQUEST</strong>
                <ul>
                    <li>This function module displays a value list that you created in an ABAP program.</li>
                    <li>The value list is passed to the function module as the table parameter VALUE_TAB.</li> 
                    <li>If you specify the import parameters DYNPPROG, DYNPNR, and DYNPROFIELD,
                        the user's selection is returned to the corresponding field on the screen.</li>
                    <li>If you specify the table parameter RETURN_TAB, the selection is returned into the table instead.</li> 
                </ul> <pre>CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
                    EXPORTING<p>
                    RETFIELD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =  'CONNID'
                    DYNPPROG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =  PROGNAME
                    DYNPNR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =  DYNNUM
                    DYNPROFIELD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=  'CONNECTION'
                    VALUE_ORG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 'S'
                    TABLES
                    VALUE_TAB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= VALUES_TAB.</p></pre>
                        That's all to POH and POV. Leave your comments in case of any doubts.
                        <p id="slidetag">&nbsp;

                        </p>
    </p>
                  
    <h2>ALV Reports in SAP Tutorial - ABAP List Viewer   </h2>
    <p>

        The common desired  features of any  report are "column alignment", sorting, filtering, subtotals, totals etc.
        To implement these from scratch , a lot of coding effort  is to be put.
        To avoid that we can use a concept called ABAP List Viewer (ALV).

        Each of these reports provide function modules which help in producing desired output without much effort.

        <h3>simple report:</h3>

        Important function modules in these report are -

            Reuse_alv_fieldcatalog_merge
            Reuse_alv_list_display
            Reuse_alv_events_get
            Reuse_alv_grid_display
            Reuse_alv_commentary_write

        REUSE_ALV_FIELDCATALOG_MERGE

            This function module is used to populate a field catalog which is essential to display the data in ALV.

            If the output data is from a single dictionary table and all the columns are selected, 
            then we need not exclusively create the field catalog. 
            Its enough to mention the table name as a parameter (I_structure_name) in the REUSE_ALV_LIST_DISPLAY.
            But in other cases we need to create it.

            Note : Fieldcatalog can be filled manually also by filling up all the required details into the internal table

            Important parameters in are:

            1. Export:

                I_program_name : report id
                I_internal_tabname : the internal output table
                I_inclname : include or the report name where all the dynamic forms are handled.

            2. Changing

                ct_fieldcat : an internal table with the type SLIS_T_FIELDCAT_ALV which is declared in the type pool SLIS.

        REUSE_ALV_LIST_DISPLAY

            This is the function module which prints the data.

            The important parameters are:

            1. Export:

                I_callback_program : report id
                I_bypassing_buffer : 'X'
                I_buffer_active : ' '
                I_callback_pf_status_set : routine where a user can set his own pf status or change the functionality of the existing pf status.
                I_callback_user_command : routine where the function codes are handled.

                I_structure name : name of the dictionary table
                Is_Layout : structure to set the layout of the report
                It_fieldcat : internal table with the list of all fields and their attributes which are to be printed (this table can be populated automatically by the function)
                It_events : internal table with a list of all possible events of ALV and their corresponding form names.

            2. Tables:

                a. t_outtab : internal table with the data to be output

        REUSE_ALV_EVENTS_GET:

            Returns table of possible events for a a list type

            1. Import:

            Et_Events :The event table is returned with all possible CALLBACK events for the specified list type (column 'NAME'). For events to be processed by the Callback, their 'FORM' field must be filled. If the field is initialized, the event is ignored. The entry can be read from the event table, the field 'FORM' filled and the entry modified using constants from the type pool SLIS.

            2. Export:

            I_list_type: 0 = simple list REUSE_ALV_LIST_DISPLAY

            1 = hierarchical-sequential list  REUSE_ALV_HIERSEQ_LIST_DISPLAY

            2 = simple block list REUSE_ALV_BLOCK_LIST_APPEND

            3 = hierarchical-sequential block list   REUSE_ALV_BLOCK_LIST_HS_APPEND

        REUSE_ALV_GRID_DISPLAY

            A new function from ABAP4.6 version, to display the results in grid rather than a preview.

            Parameters : same as reuse_alv_list_display

                Note:Grid cannot handle high volumes. Functions like sort, scrolling down consumes a lot of resources / time if the volume of data to be displayed is high. There is no clear cut definition such that if the amount of data is X go for list or grid  but the developer has to take a call based on his experience. If not sure, then list is the better option

        REUSE_ALV_COMMENTARY_WRITE

            This is used in the Top-of-page event to print the headings and other comments for the list.

            Important Parameters

                It_list_commentary : Internal table with the headings of the type slis_t_listheader.

            This internal table has three fields:

                Typ : 'H' - header, 'S' - selection, 'A' - action
                Key : only when typ is 'S'.
                Info : the text to be printed

        <h3>Block Report</h3>

        This looks like a simple report but this report has the features of sorting and filtering only.This report is used if you have to display more than one report on the output. Technically speaking if you have multiple internal table with data to be displayed as separate blocks then we go for block report of ALV.

        The important functions used for creating this report are:

            REUSE_ALV_BLOCK_LIST_INIT
            REUSE_ALV_BLOCK_LIST_APPEND
            REUSE_ALV_BLOCK_LIST_DISPLAY

        REUSE_ALV_BLOCK_LIST_INIT

        This function module is used to set the default gui status etc. The parameters are similar to the one used in reuse_alv_list_display or reuse_alv_grid_display

        REUSE_ALV_BLOCK_LIST_APPEND

        This function module adds the data to the block.

        Important Parameters

        1.Export :

            is_layout : layout settings for block
            it_fieldcat : field catalog
            I_tabname : internal table name with all all possible events

        2.Tables :

            t_outtab : internal table with output data.

        REUSE_ALV_BLOCK_LIST_DISPLAY

        This function module display the list with data appended by the above function.

        Parameters : All the parameters are optional.
        <h3>Hierarchical Reports</h3>

        Hierarchical display is used for displaying data that are related. Like sales order and item details. Here sales order details can be the header data whereas them items in the sales order can be the item data

        The function module used for this is

        REUSE_ALV_HIERSEQ_LIST_DISPLAY

        Export:

            I_CALLBACK_PROGRAM
            I_CALLBACK_PF_STATUS_SET
            I_CALLBACK_USER_COMMAND
            IS_LAYOUT
            It_fieldcat
            It_events
            I_tabname_header : Name of the internal table in the program containing the output data of the highest hierarchy level.
            I_tabname_item : Name of the internal table in the program containing the output data of the lowest hierarchy level.
            Is_keyinfo : This structure contains the header and item table field names which link the two tables (shared key).

        Tables

            t_outtab_header : Header table with data to be output
            t_outtab_item : Name of the internal table in the program containing the output data of the lowest hierarchy level.

        All the definitions of internal tables, structures and constants are declared in a type-pool called SLIS. This internal table can be populated automatically by using REUSE_ALV_FIELDCATALOG_MERGE'.
        <h3>Display Variants</h3>

            Display variants are used to set the default properties of an alv output like sort criteria, filtering criteria, totaling and subtotaling etc
            Display varian`ts can be user specific and standard (standard variants can be used by any user )
            Kind of display variants that can be saved is controlled by the parameter i_save that is passed in function modules  reuse_alv_list_display / reuse_alv_grid_display
            You can provide an option on the selection screen to select what display variant to be used

        The common function modules related to selecting / validating display variants are

            Reuse_alv_variant_default_get
            Reuse_alv_variant_f4
            Reuse_alv_variant_existence

    </p>

    <h2>SAP Scripts Tutorial: SE71, SE78, SCC1, VF03, SO10</h2>
    <p>
        SAP script is the SAP System's own text-processing system.
        It is used to print preformatted text in pre-formatted forms.

        <h3>Components of SAPScript</h3>

        SAP Scripts comprises of 5 main components:
        <p>
            . An editor for entering and editing the lines of a text
            . Styles and layout sets for print layout. These are created independent of the inpidual texts
            using the corresponding maintenance transactions and are allocated to the texts later
            . The composer is a central output module. The SAP script composer is invisible to the outside
            . A programming interface that allows you to include SAP script components into your own application programs
            and to control the output of layout sets from within the programs
            . Several database tables for storing texts, styles and layout sets
        </p>

        <h3>Layout Set</h3>
        <p>
            To output documents using the programming interface, R/3 application programs need so-called layout sets (a kind of form).
            In SAP script a layout set describes the layout of the inpidual print pages and
            uses text elements to supply definable output blocks, which a print program can call.
            A layout set can be defined as a page design for a document

            Layout set on its own doesn't contain any data. The selection of data for the document is done through the print program.
            The print program selects the data from database table and feeds it to the layout set. 
            When the print program is executed the document is printed on the screen, printer.

            Usually a SAPScript Layout consists of following components
            <p>
                <b>Header Data</b>: 
                    Header data is used for information and control of SAP printing. The header data comprises of 2 parts - Device Independent - Stores information like Start page , Default paragraph ,Language Attributes etc. And Device Dependent stores information like Page format ,Orientation Lines per inch etc
                <b>Paragraph and Character Formats</b>:
                    Paragraphs are formatted using various attributes. For instance Standard paragraph attributes specify Left or Right margin, Alignment ,Line spacing etc. Font attributes specify Font family ,Font size etc. Character formats allow to format entire blocks of text within a paragraph
                <b>Windows and Text Elements</b>: 
                    Windows are inpidual text areas (header address, date, footer) in a page . 
                    It helps combine the information contained in a document into certain groups and make each group appear on the printed page in an inpidual area.
                    You can define text elements (window texts) for each window.
                    The print program accesses text elements by name, formats them and prints them in the respective window.
                    The paragraph and the character formats used must be defined in the form.
                <b>Pages:</b> 
                    They are inpidual pages of a document and must have a unique name. You will often find different layouts 
                    for inpidual pages: 
                    
                    The first page of an invoice differs from the subsequent pages,
                    on which you need not repeat general information, such as address or customer data.
                <b>Page Windows:</b>
                While defining windows and pages, you do not yet determine the position and spacing of the texts to be output.
                A page window defines the rectangular output area in the output medium by specifying the left upper edge of the output area 
                and its width and height
            </p>
        </p>
        <h3>Control Commands</h3>
        <p>
            The purpose of "control commands" is to allow control of the output formatting.
            These commands are not interpreted by the SAP script editor, but are passed through to the SAP script Composer for processing. 
            This includes, for example, line and page formatting, the formatting of text according to the paragraph and character formats specified.

            <b>Syntax</b>
            <pre>
                Enter /: in the paragraph format
            </pre>
            <br>

            <b>Examples</b>
            <pre>
                NEW-PAGE - Explicit page break
                PROTECT .........ENDPROTECT - To print complete paragraph in one page.
                INCLUDE - To include the content of another text into current text
                PERFORM - To call a subroutine of any ABAP program
            </pre>
        </p>
        <h3>Print Program</h3>
        <p>
            The execution of script is done through an ABAP program, which is referred as Print Program.
            Each print program should have an ENTRY form , which will be called from customization.

            For a standard configuration we can see the form name (script name), print program name and output type in the table TNAPR.
            The print program uses the Form control functions to call the script.

            The print program call either all or some of the form control functions to execute the script

                OPEN_FORM (Mandatory) Opens the layout set output
                CLOSE_FORM (Mandatory) Ends the layout set output
                START_FORM (Optional) Starts a new layout set
                WRITE_FORM (Mandatory) Calls a layout set element
                END_FORM (Optional) Ends the current layout set
        </p>
        <h3>Output Types</h3>
        <p>
            The output type can specify, a printed form that you need for internal use or a form that you want to send to a customer or vendor .
            The output type can also be an internal electronic mail message that you want to send to staff in another department.

            For example "Print out" can be classified as one output type of a billing document,
            i.e. when this output type is executed the billing document is printed.
            Similarly "Fax" can be an output type, i.e. when this output type is executed a fax of the billing document is sent

            All the output types for any document (e.g. billing document) will be stored in the table NAST.
            Output types are executed through the program RSNAST00 .

            Example : Output type in a billing document-

                Go to VF03
                Enter billing document number and press enter again
                Chose Output under the menu Goto -> Header
                Here Z101 is an output type of a print output
        </p>
        <h3>Standard Texts and Graphics</h3>
        <p>
            Standard Texts for your report can be created using transaction SO10

            Graphics and printer macros are uploaded with report RSTXLDMC into inpidual standard text documents
            or through transaction SE78. Graphics are uploaded  in "Baseline TIFF 6.0" format (.tif files on PC)

            SAP Script & Standard text elements can exported or imported between two systems using RSTXSCRP program

            <b>Copying Scripts Across clients:</b>

            SAP Script is a client dependent object.Unlike programs, changes done to SAP script in one client will not be reflected in other clients.
            For copying script from one client to another, go to SE71 and
            use "Copy from Client" option available under Utilities menu or import the transport request, 
            in which the script is saved, from the original client using the transaction SCC1 .

            <b>Important Points to Note</b>

                SAP script does not maintain any versions. So when modifying the SAP script , ensure that the changes are well documented in script.
                This applies to the standard texts too.
                The output of the form will differ when viewed on the screen and on the printer. So always test the output of the script on the printer.
        </p>

    </p>

    <h2> Smart Forms in SAP ABAP</h2>
    <p>
            SAP Smart Forms is used to create and maintain forms for mass printing in SAP Systems.
            As output medium SAP Smart Forms support a printer, a fax, e-mail, or the Internet (by using the generated XML output).
            
            SAP introduced SmartForms in 1998 to overcome the limitations in SAP Scripts.
            SmartForms are easier to develop, maintain and transport than SAP Script.
            
            
            <h3>Smart Forms and  SapScripts Comparison</h3>
            <p>
                Multiple page formats are possible in SmartForms which is not the case in SAPScripts
                It is possible to have a SmartForm without a main window.
                Routines can be written in SmartForms tool.
                SmartForms generates a function module when activated.
                Labels cannot be created in SmartForms.
            </p>
            <h3>Advanatges of Smart Forms</h3>
            <p>
                They  help adapting forms without any programming knowledge due to entirely graphical user interface
                When activating the smart form the system automatically generates the function module and at the runtime .
                To make any changes we have to use the Drag & Drop, Cut & Paste. 
                These actions do not include writing of coding lines or using a script language.
                We can insert static and dynamic tables.
                These include the line feeds in the inpidual table cells, triggering events for table headings and subtotals 
                and sorting data before output.
                The smart forms allow the user to include graphics, which can be displayed as a part of the form or as background graphics.
                During printout the user can suppress the background graphic as and when necessary.
                Web Publishing is possible using the generated XML output
            </p>
            <h3>Architecture of SAP Smart Form</h3>
            <img src="https://www.guru99.com/images/sap/2011/02/smartformpdf2.jpg">
            <h3>Smartforms Guide</h3>
            
                1. Enter transaction SMARTFORMS in the transaction code box.
                2. In the next screen , enter a Form name and click create
            
                <img src="https://www.guru99.com/images/sap/2011/01/sap-smart-form1.jpg">
            
                The next screen is pided into three sections-
            
                <img src="https://www.guru99.com/images/sap/2011/02/sap-smart-forms2.png">
            
            <b>Navigation window</b> consist of nodes and sub nodes.
            They contain all the elements (text, window etc) that belong to sap forms
            <p>
                . Maintenance window shows attributes of the elements
                . Form printer window shows the layout of the page
            </p>
            Whenever we create smart forms, SAP creates/generates a function module.Unlike SAPscripts , SAP FORMS allow you to change language.
            
            In the navigation window  you will find
            
            <b>Global Data Declarations: </b> The Data defined here can be used throughout the smartform for coding purposes.
            
            <b>Form Interface :</b> Here all the data which will be passed to the smartform from the Print program is defined.
            
            <img src="https://www.guru99.com/images/sap/2011/02/Copy-of-1.png">
            
            Right-Clicking on the Pages will allow creation of New Page, Window, Graphic or Address.
            
            <img src="https://www.guru99.com/images/sap/2011/02/sap-smart-forms4.png">
            
            Printing will take place on the basis of 'next page' field.
            
            But processing will happen as per the sequence in navigation window!
            
            <img src="https://www.guru99.com/images/sap/2011/02/sap-smart-forms7.png">
            
            For background picture and graphics you can pick up either black and white or color bitmap images and
            are stored in the form of standard texts.
            You may take a detour from the smartform screen and open Form Graphics screen. Transaction code: Se78
            
            <img src="https://www.guru99.com/images/sap/2011/02/sap-smart-forms8.png">
            
            Setting in the Graphics in  Smart Form Window-
            
            <img src="https://www.guru99.com/images/sap/2011/02/sap-smart-forms9.png">
            
            <h3>Windows in Smart Forms</h3>
            <img src="https://www.guru99.com/images/sap/2011/02/sap-smart-forms10.png">
            
            There are two types of Windows
            <p>
                    1.Main
                    2.Secondary    
            </p>
                
            <b>Important Points to Note</b>
            <p>
                . You cannot have more than 1 main window in a page. You can have multiple secondary windows
                .Whatever you print in secondary window...it has to be static.
                (If u have 20 lines in a PO and there is page constraint the lines get carried forward to next page in the main window. 
                i.e. In a predecessor and successor type of content, they will be printed in sequence in main window. 
                This is not allowed in Secondary windows.
            </p>
            <img src="https://www.guru99.com/images/sap/2011/02/sap-smart-forms11.png">
            
            Inside the main window we can add text as introduction to customize the form output.
            <img src="https://www.guru99.com/images/sap/2011/02/rsz_sap-smart-forms.png">
            
            The Output options on each window determine the Line size, Width, Colors and background to be put.
            
            <img src="https://www.guru99.com/images/sap/2011/02/1.png">
            
            Smartforms gives the option of giving the address number which is maintained in the central address management. 
            The address will be directly taken from ADRC table and will be populated in the form.
            
            <img src="https://www.guru99.com/images/sap/2011/02/2.png">
            The two different editors are available in Smartforms viz. Normal Editor
            <img src="https://www.guru99.com/images/sap/2011/02/3.png">
            
            and the Graphics Editor.
            
            
            <img src="https://www.guru99.com/images/sap/2011/02/51.png">
            This setting can be changed using the Configure editor in Utilities.
            
            In Table painter, you can draw the format as per client requirement (e.g. Heading, Sub Heading, Item, Sub Total, Grand Total etc.)
            
            You can use the table layout to determine:
            <p>
                . The number of lines and cells
                . The height of each line
                . The width of each cell
                . The alignment of the table in the window
            </p>
            <img src="https://www.guru99.com/images/sap/2011/02/11.png"> 
            
            The Table shows the different line types which will be used in the table.
            The Line types define the size of each cell and the number of cells in each line.
            
            <img src="https://www.guru99.com/images/sap/2011/02/21.png">
            <h3>Smart Forms Programming Flow</h3>
            
            When an SAP Smart Form template is created, a user creates the form layout, defines the required fields, conditions,
            and special programming instructions in the Smart Form template using the Smart Form Builder.
            
            After the form design is complete, the form needs to be activated before it can be tested or accessed by the print programs.
            Activating the form initiates the generation of a function module that handles all of the form's processing.
            
            This function module interacts with the application program/print program to create the output in the user-defined output 
            media for the specified device.
            
            In case of smart forms, we use 2 function modules for the processing of the smart form. To the first function module ,
            we pass the name of the smart form as the import parameter. 
            This then returns the name of the dynamically generated function module which will actually call the smartform.
            
            The smartform name can be passed on to the function Module - 'SSF_FUNCTION_MODULE_NAME'
            
            <img src="https://www.guru99.com/images/sap/2011/02/12.png">
            This will return the Function module name of the smartform which is referenced.
            
            <img src="https://www.guru99.com/images/sap/2011/02/22.png">
            The Print program will be calling the FM 'SSF_FUNCTION_MODULE_NAME' to get the Function module name at Runtime. 
            Therafter it will call the Function module thus obtained to execute the smartform.
            
            <img src="https://www.guru99.com/images/sap/2011/02/32.png">
            <h3>Templates</h3>
            
            Template can be  used when you know the exact size of the output or the output is in a fixed format.
            
            E.g. Tax form/ cheques /airline form/railway ticket: all these use templates.
            
            The big  between table and template is that in a Table the height changes dynamically.We call a row a 'line' in template.
            
            <img src="https://www.guru99.com/images/sap/2011/02/52.png">
            SMART Styles
            
            A Smart Style contains:
            <p>
                . Header data containing the default values of a Smart Style
                . Paragraph formats including indents and spacing, font attributes, tabs, and outline and numbering
                . Character formats including effects (superscript, subscript), barcode and font attributes
                . Colors and underlines for a paragraph or character format
            </p>
            You can use the transaction 'smartforms' / 'smartstyles' to create a smart style.
            <img src="https://www.guru99.com/images/sap/2011/02/Copy-of-7.png">
    </p>
        
    <h2>What is User Exits and Customer Exits in SAP ABAB</h2>
        <p>
            <h3>What is Customer Exits ?</h3>
            <p>
                    Customer exits are "hooks" provided by SAP within many standard programs, 
                    screens and menus on which customers may "hang" custom functionality
                    to meet business requirements.  
            </p>
            <h3> Types of Customer Exits</h3>
            <p>
                1. <b>   Function Module Exits</b>
                <p>
                        It  allows customer to add code via a function module at a specific location in an SAP application program 
                        <pre>
                                Syntax: CALL CUSTOMER-FUNCTION '004'
                        </pre>
                </p>
                2.<b>    Screen Exits</b>
                <p>
                        :  It allows customer to add fields to a screen in an SAP program via a subscreen.
                        The subscreen is called within the standard screen's flow logic.
                        <pre>
                                Format: CALL CUSTOMER-SUBSCREEN CUSTSCR2
                        </pre>
                </p>
                3.<b>    Menu exits</b>
                <p>
                        It  allows customer to add items to a pulldown menu in a standard SAP program. 
                        These items may be used to call add-on programs or custom screens.
                        <pre>
                                Format: +CUS ( additional item in GUI status )
                        </pre>
                </p>
            </p>
            <h3> Examples of Customer Exits</h3>
                <b>Example of a Screen Exit</b>
                <p>
                        In transaction CAT2 - Time Sheet Entry,
                        HR wishes to include an interactive acknowledgment that knowingly submitting incorrect data is grounds for dismissal. 
                        <img src="https://www.guru99.com/images/sap/2011/01/16.png">
                </p>
                <b>Example of a Menu Exit</b>
                <p>
                        In transaction SE38 - ABAP Editor, the development team wishes to include a menu link to transaction SE80 - 
                        Object Navigator for ease of use.
                        <b>Befor:</b>
                        <img src="https://www.guru99.com/images/sap/2011/01/25.png">
                        <b>After:</b>
                        <img src="https://www.guru99.com/images/sap/2011/01/34.png">
                </p>
                <b>Example of a Function Module Exit</b>
                <p>
                    The company wants the bank details of the Vendors in the Vendor creation to be mandatory event .
                    So it must flash a error message that 'Please Enter the bank details'
                    <b>Before:</b>
                    <img src="https://www.guru99.com/images/sap/2011/01/43.png">
                    <b>After:</b>
                    <img  src="https://www.guru99.com/images/sap/2011/01/52.png">
                </p>
            <h3> Locating Customer Exits</h3>
            <p>
                    In transaction SMOD and look into the details
                    <img src="https://www.guru99.com/images/sap/2011/02/6.png">
                    Or in transaction SE81 you can use the appropriate application area
                    <img src="https://www.guru99.com/images/sap/2011/01/72.png">
            </p>
            <h3> Create a Customer Exit</h3>
            <p>
                To create a customer exit you first need to create a project in transaction CMOD

                What is User Exits and Customer Exits in SAP ABAB
                <img src="https://www.guru99.com/images/sap/2011/01/82.png">
                Later you assign the Customer Exit to your project. 
            </p>
            <h3> What is a USER EXIT?</h3>
            <p>
                User Exit serve the same purpose as Customer Exits but they are available only for the SD module.
                The exit is implemented as a call to a Function Module.
                The code is written by the developer.

                Well know User Exit in SD is MV45AFZZ
                <pre>                
                    USEREXIT_FIELD_MODIFICATION - To modify screen attributes
                    USEREXIT_SAVE_DOCUMENT - To perform operations when user hits Save
                    USEREXIT_SAVE_DOCUMENT_PREPARE
                    USEREXIT_MOVE_FIELD_TO_VBAK - When user header changes are moved to header work area.
                    USEREXIT_MOVE_FIELD_TO_VBAP - When user item changes are moved to SAP item work area
                </pre>
            </p>

        <h2>What is BADI? </h2>
        <p>
                BADI stands for Business Add Ins Just like Customer Exits , BADI  help hook custom enhancements to SAP functionality.
                Example of a BADI: In transaction CAT2 - Time Sheet Entry, HR wishes to include an interactive acknowledgment
                that knowingly submitting incorrect data is grounds for dismissal.
                This can be achieved using BADI
                <h4>befor:</h4>
                <img src="https://www.guru99.com/images/sap/2011/01/17.png">
                <h4>After:</h4>
                <img src="https://www.guru99.com/images/sap/2011/01/17.png">
            <h3>Features:</h3>
            <p>            
                . BADI's are Object Oriented
                . They can be implemented multiple times
                . It does not require SAP Software Change Registration
                . No effect on release upgraded on the functioning of BADI's
            </p>
            <h3>Define and Implement a BADI</h3>
            <p>
                    This involved three steps

                    Step 1 Creating BADI Definition : Transaction SE18
                    <img src="https://www.guru99.com/images/sap/2011/01/18.png">

                    Step 2 Define BADI interface: Transaction SE19
                    <img src="https://www.guru99.com/images/sap/2011/01/26.png">

                    Step 3 Define a class implements the interface :
                    During implementation creation, a class for implementing the enhancement's interface is also created
            </p>    
        </p>
    </p>

    <h2>ABAP Query Tutorial in SAP: SQ01, SQ02, SQ03</h2>
    <p>
        The ABAP Query application is used to create reports not already present in SAP system.
            It has been designed for users with little or no knowledge of the ABAP programming. 
            ABAP Query offers users a broad range of ways to define reports and create different types of reports such as 
            basic lists, statistics, and ranked lists.
        
        The ABAP Query comprises four components:
        <p>
            
            1.Queries
            2.InfoSets
            3.User Groups
            4.Translation of Query

        </p>
        <h3>Queries</h3>
        <p>
            The Queries component is used by end users to maintain queries.
                One can create queries,change queries and execute queries. Transaction SQ01
                <img src="https://www.guru99.com/images/sap/2011/01/14.png">
        </p>
        <h3>InfoSets</h3>
        <p>
                InfoSets are special views of data sources.
                An InfoSet describes which fields of a data source can be reported on in queries. 
                An InfoSet can be assigned to several roles or user groups.

                Advantages-
                
                    By creating InfoSets and assigning them to roles or user groups,
                    the system administrator determines the range of reports that the inpidual application departments
                    or end-users are able to generate using the SAP Query.
                    End-users are able to work only with those InfoSets that are relevant to their particular area, 
                    as designated by the role or user group that they are assigned to.            
        </p>
        <h3>USER Groups</h3>
        <p>
                The User Groups component is used to maintain user groups (from a security standpoint).

                Users working in the same application are assigned to the same user group.
                It does not matter who actually defined a query in a user group.
                Every user assigned to the user group is able to execute the query.
                
                Users in a user group need to have the necessary authorizations before they are able to change or redefine a query. 
                Every user in a system can be assigned to several user groups.

        </p>

        <h3>Translation/QUERY Component</h3>
        <p>
                A lot of texts are generated when defining queries, InfoSets, and user groups.
                These texts are displayed in the language that we chose when we log on to the SAP system.
                We can compare the text/languages using this component. 
        </p>

        <h3> Data processing in Queries        </h3>
        <p>
            Data can be processed and presented in 3 ways:-
            <p>
                <b>BASIC LIST</b> - Presents data in the order defined by the functional area ( supports sorting and summation ).
                <b>STATISTIC</b> - Shows the statistical figures calculated from the basic data.
                <b>RANKED LIST </b>- A ranked list is a specialization of a statistic. E.x. Top ten customers of a travel agency.
            </p>
            A query can have one  basic list , upto nine statistics and upto nine ranked lists.
            
        </p>

        <h3>CREATING A QUERY</h3>
        <p>
            Step 1. Goto SQ01. Give a name to the query and click on the Create button
            <img src="https://www.guru99.com/images/sap/2011/01/24.png">
            
            Step 2. Give the description of the query in the next screen. 
            Specify the output length and select the processing option from the Further Processing Options box.
                The data can be displayed in various formats such as table, download to a file, and display in Word etc.
            <img src="https://www.guru99.com/images/sap/2011/01/33.png">

            Step 3.  Click on the next screen, select the field group to be used.
            <img src="https://www.guru99.com/images/sap/2011/01/42.png">
            Step 4. Click on the next screen, select the fields you want displayed
            <img src="https://www.guru99.com/images/sap/2011/01/51.png">
            Step 5. On the next screen, select the selection fields and then chose one of the output types ( basic, statistics, ranked ).
            In each of the lists, you can select various options.
            ( eg. Sort order of fields, change output length, column color,totals,page header, page footer etc.).
            <img src="https://www.guru99.com/images/sap/2011/01/64.png">
            Step 6. After providing all the above options you can save the query and execute it .
            <img src="https://www.guru99.com/images/sap/2011/01/81.png">
        </p>

    </p>
    <h2>SAP ABAP BDC (Batch Data Communication) </h2>
    <p>
        <h3>Introduction to Batch input</h3>
        <p>

        </p>
        Batch input is typically used to transfer data from non-R/3 systems to R/3 systems or to transfer data between R/3 systems.
        
        It is a data transfer technique that allows you to transfer datasets automatically to screens belonging to transactions,
            and thus to an SAP system. Batch input is controlled by a batch input session.

        <b>Batch input session</b>
        Groups a series of transaction calls together with input data and user actions .
        A batch input session can be used to execute a dialog transaction in batch input,
        where some or all the screens are processed by the session. 
        Batch input sessions are stored in the database as database tables and can be used within a program as internal tables
        when accessing transactions.

        <b>Points to note        </b>
        <p>    
            . BDI works by carrying out normal SAP transactions just as a user would but it execute the transaction automatically.
            All the screen validations and business logic validation will be done while using Batch Data Input.
            . It is suitable for entering large amount of data.
            . No manual interaction is required
        </p>
        
        <h3> Methods of Batch Input        </h3>
        <p>
            SAP provide two basic methods for transferring legacy data in to the R/3 System.
            <p>
                1.Classical Batch Input method.
                2.Call Transaction Method.        
            </p>
            
            <b>Classical Batch Input method</b>
            
            In this method an ABAP/4 program reads the external data to the SAP System and stores in a batch input session.
            
            After creating the session, you can run the session to execute the SAP transaction in it.
            
            This method uses the function modules BDC_ OPEN, BDC_INSERT and BDC_CLOSE
            
            Batch Input Session can be process in 3 ways
            
                1.In the foreground
                2.In the background
                3.During processing, with error display
            
            You should process batch input sessions in the foreground or using the error display if you want to test the data transfer.
            
            If you want to execute the data transfer or test its performance, you should process the sessions in the background.
            
            <b>Points to note about Classical Batch Input method</b>
            
                . Asynchronous processing
                . Transfer data for multiple transactions.
                . Synchronous database update.
                . A batch input process log is generated for each session.
                . Session cannot be generated in parallel.    
            
            <b>Call Transaction Method</b>
            <p>
                In this method ABAP/4 program uses CALL TRANSACTION USING statement to run an SAP transaction.
                Entire batch input process takes place online in the program     
                <img src="https://www.guru99.com/images/sap/2011/01/sap-bdc.png">
                Points to Note:
                <p>
                . Faster processing of data
                . Synchronous processing
                . Transfer data for a single transaction.
                . No batch input processing log is generated.
                </p>

            </p>

            
        </p>
        <h3> Batch Input Procedures</h3>
        <p>
            <img src="https://www.guru99.com/images/sap/2011/01/sap-bdc1.jpg">
            You will typically observe the following sequence of steps to develop Batch Input for your organization
            <p>           
                1. Analysis of the legacy data. Determine how the data to be transferred is to be mapped in to the SAP Structure.
                Also take note of necessary data type or data length conversions.
                2. Generate SAP data structures for using in export programs.
                3. Export the data in to a sequential file. Note that character format is required by predefined SAP batch input programs.
                4. If the SAP supplied BDC programs are not used, code your own batch input program. 
                Choose an appropriate batch input method according to the situation.
                5. Process the data and add it to the SAP System.
                6. Analyze the process log. For the CALL TRANSACTION method, where no proper log is created, 
                use the messages collected by your program.
                7. From the results of the process analysis, correct and reprocess the erroneous data.
            </p>
            
        </p>
        <h3> Writing BDC program </h3>
        <p>
            You may observe the following process to write your BDC program
            <p>
                1.Analyze the transaction(s) to process batch input data.
                2.Decide on the batch input method to use.
                3.Read data from a sequential file
                4.Perform data conversion or error checking.
                5.Storing the data in the batch input structure,BDCDATA.
                6.Generate a batch input session for classical batch input,or process the data directly with CALL TRANSACTION USING statement.
            </p>
            <b>Batch Input Data Structure</b>
            <p>
                Declaration of batch input data structure
                <pre>
                        DATA : BEGIN OF < bdc table>

                        OCCURS <occurs parameters>.
                        
                        INCLUDE STRUCTURE BDCDATA.
                        
                        DATA:END OF <bdc table>.
                </pre>
                <br>
                <table >
                    <thead>
                        <tr>
                            <th> Field name</th>
                            <th> Type</th>
                            <th> Length</th>
                            <th> Description</th>
                        </tr> 
                    </thead>
                    <tbody>
                        <tr>
                            <td> PROGRAM</td>
                            <td> CHAR</td>
                            <td> 8</td>
                            <td> Module pool</td>
                        </tr>
                        <tr>
                            <td> DYNPRO</td>
                            <td> NUMC</td>
                            <td> 4</td>
                            <td> Dynpro number</td>
                        </tr>
                        <tr> 
                            <td> DYNBEGIN</td> 
                            <td> CHAR</td> 
                            <td> 1</td> 
                            <td> Starting a dynpro</td> 
                        </tr> 
                        <tr> <td> FNAM</td> <td> CHAR</td> <td> 35</td> <td> Field name</td> </tr>
                        <tr> <td> FVAL</td> <td> CHAR</td> <td> 80</td> <td> Field value</td> </tr>
                    </tbody>
                </table>
                The order of fields within the data for a particular screen is not of any significance
                <b>Points to Note</b>
                <p>
                    
                    . While populating the BDC Data make sure that you take into consideration the user settings. This is specially relevant for filling fields which involves numbers ( Like quantity, amount ). It is the user setting which decides on what is the grouping character for numbers E.g.: A number fifty thousand can be written as 50,000.00 or 50.000,00 based on the user setting.
                    . Condense the FVAL field for amount and quantity fields so that they are left aligned.
                    . Note that all the fields that you are populating through BDC should be treated as character type fields while populating the BDC Data table.
                    . In some screens when you are populating values in a table control using BDC you have to note how many number of rows are present on a default size of the screen and code for as many rows. If you have to populate more rows then you have to code for "Page down" functionality as you would do when you are populating the table control manually.
                    . Number of lines that would appear in the above scenario will differ based on the screen size that the user uses. So always code for standard screen size and make your BDC work always in standard screen size irrespective of what the user keeps his screen size as.

                </p>

            </p>
        </p>
        <h3> Creating Batch Input Session  </h3>
        <p>
                
            1. Open the batch input session session using function module BDC_OPEN_GROUP.
            2. For each transaction in the session:
            . Fill the BDCDATA with values for all screens and fields processed in the transaction.
            . Transfer the transaction to the session with BDC_INSERT.
            3. Close the batch input session with BDC_CLOSE_GROUP
        </p>
        <h3> Batch Input Recorder</h3>
        <p>
                Batch input recorder (System > Services > Batch input > Recorder) 
                records transactions which are manually entered and creates a batch input session which can be executed later using SM35.
                <img src="https://www.guru99.com/images/sap/2011/01/sap-bdc2.jpg">
                <p>
                    
                    <b>.</b> Begin the batch input recorder by selecting the Recording pushbutton from the batch input initial screen.
                    <b>.</b> The recording name is a user defined name and can match the batch input session name which can be created from the recording.
                    <b>.</b> Enter a SAP transaction and begin posting the transaction.
                    <b>.</b> After you have completed posting a SAP transaction you either choose Get Transaction and Save to end the recording or
                    Next Transaction and post another transaction.
                    <b>.</b> Once you have saved the recording you can create a batch input session from the recording and/or generate 
                    a batch input program from the recording.
                    <b>.</b> The batch input session you created can now be analyzed just like any other batch input session.
                    <b>.</b> The program which is generated by the function of the batch input recorder is a powerful tool for
                    the data interface programmer. It provides a solid base which can then be altered according to customer requirements.

                </p>
        </p>
    </p>
    <h2>ALE, EDI & IDocs</h2>
    <p>
        EDI, stands for Electronic Data Interchange, is the electronic exchange of structured business data between different applications.
        <b>EDI Architecture consists of</b>
        <p>            
            1. EDI-enabled applications :They support the automatic processing of business transactions.
            2. The IDoc interface: This was designed as an open interface. The IDoc interface consists of IDoc types 
            and function modules that form the interface to the application.
            3. The EDI subsystem: This converts the IDoc types into EDI message types and vice versa. 
            This component of the EDI architecture is not supplied by SAP.
        </p>
        <b>Advantages of EDI process</b>
        <p>        
            <b>.</b> Reduced data Entry Errors
            <b>.</b> Reduced Processing cycle time
            <b>.</b> Availability of data electronic form
            <b>.</b> Reduced Paper Work
            <b>.</b> Reduced Cost
            <b>.</b> Reduced Inventories and Better Planning
            <b>.</b> Standard Means of Communicating
            <b>.</b> Better Business Processes
            <b>.</b> Competitive Advantage
        </p>
        <h3>What is ALE</h3>
        <p>
                ALE supports the distribution of the business functions and process across loosely coupled SAP R/3 systems (different versions of SAP R/3). Connections from R/2 and non SAP systems is also supported.

                ALE supports-
                
                    Distribution of applications between different releases of R/3 Systems
                    Continued data exchange after a release upgrade without requiring special maintenance
                    Customer-specific extensions.
                    Communication interfaces that allow connections to non-SAP systems.
                    Coupling of R/3 and R/2 Systems.            
        </p>
        <h3>Difference between ALE and EDI ?</h3>
        <p>
                ALE is used to support distributed yet integrated processes across several SAP systems whereas EDI is used for the exchange of business documents between the systems of business partners (could be non-SAP systems)

                ALE is SAP's technology for supporting a distributed environment whereas EDI is a process used for exchange of business documents which now have been given a standard format
                
                Both ALE and EDI require data exchange. An Idoc is a data container which is used for data exchange by both EDI and ALE processes.
        </p>
        <h2>What is IDOC?</h2>
        <p>
                IDOC is simply a data container used to exchange information between any two processes that can understand the syntax and 
                semantics of the data.

                In simple words , an idoc is like a data file with a specified format which is exchanged between 2 systems which
                know how to interpret that data.
                
                IDOC stands for " Intermediate Document"
                
                When we execute an outbound ALE or EDI Process, an IDOC is created.In an inbound ALE or EDI process, 
                an IDOC serves as input to create an application document.In the SAP System, IDOCs are stored in database.
                Every IDOC has an unique number(within a client).
                
                IDOCs are based on EDI standards, ANSI ASC X12 and EDIFACT. In case of any conflict in data size, it adopts one with greater length.
                IDOCs are independent of the direction of data exchange e.g. ORDERS01 : Purchasing module : Inbound and Outbound.
                IDOCs can be viewed in a text editor.
                Data is stored in character format instead of binary format.
                IDOCs are independent of the sending and receiving systems.(SAP-to-SAP as well as Non-SAP)   
                <h3>Key Features</h3>
                <p>                
                    <b>.</b> IDOCs are independent of the sending and receiving systems.(SAP-to-SAP as well as Non-SAP)
                    <b>.</b> IDOCs are based on EDI standards, ANSI ASC X12 and EDIFACT. In a case of any conflict in data size, it adopts one with greater length.
                    <b>.</b> IDOCs are independent of the direction of data exchange e.g. ORDERS01: Purchasing module: Inbound and Outbound
                    <b>.</b> IDOCs can be viewed in a text editor. Data is stored in character format instead of binary format.
                </p>       
                <a href="https://www.guru99.com/all-about-idocdefinition-architecture-implementation.html">More Info..</a>  
        </p>
        <h2>What is BAPI?</h2>
        <p>
                Business Application Programming Interface(BAPI) are standardized programming interfaces (methods) 
                enabling external applications to access business processes and data in the R/3 System.

                They provide stable and standardized methods to achieve seamless integration between the R/3 System and external applications,
                legacy systems and add-ons.
                
                BAPIs are defined in the  BOR(Business object repository) as methods of SAP business object types that carry out 
                specific business functions.They  are implemented as RFC-enabled function modules and are created in the Function
                Builder of the ABAP Workbench.
                
                
                Some BAPIs and methods provide basic functions and can be used for most SAP Business Objects.These are called STANDARDIZED BAPI's.
                
                List of Standardized BAPIs:
                
                    BAPIs for Reading Data - GetList() , GetDetail() , GetStatus() , ExistenceCheck()
                    BAPIs for Creating or Changing Data- Create() ,Change(),Delete() and Undelete() ,
                    BAPIs for Mass Processing -ChangeMultiple(), CreateMultiple(), DeleteMultiple().           
            <a href="https://www.guru99.com/all-about-bapi.html">More Info</a>
        </p>
        <h2>Remote Function Call (RFC)</h2>
        <p>
                What is RFC?

                RFC is a mechanism that allows business applications to communicate and exchange information (in pre-defined formats) with other systems. RFC stands for 'Remote Function Call'
                
                RFC consists of two interfaces:
                
                    A calling interface for ABAP Programs
                    A calling interface for Non-SAP programs.
                
                Any ABAP program can call a remote function using the CALL FUNCTION...DESTINATION statement.
                The DESTINATION parameter tells the SAP System that the called function runs in a system other than the callers.
            <a href="https://www.guru99.com/rfc-remote-function-call.html">More Info..</a>
        </p>

    </p>
</p>
</body>
</html>
