<p>
It is a javascript testing framework 
that can be used immidiately after installation no configuration
</p>
<b>To Install </b>
  npm install --save-dev jest
<pre>
<p>
Let's get started by writing a test for a hypothetical function that adds two numbers.
First, create a sum.js file:
 </p>
<code>
function sum(a, b) {
  return a + b;
}
module.exports = sum;
</code>

Then, create a file named sum.test.js. This will contain our actual test:
<code>
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
</code>

<b> toEquel </b>
<code>
test('object assignment', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
</code>

<b> not </b>
<code>
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
</code>

<b>Truthiness</b>
<p>
In tests, you sometimes need to distinguish between 
undefined,
null, 
and false, 
but you sometimes do not want to treat these differently.

Jest contains helpers that let you be explicit about what you want.

toBeNull      matches only null
toBeUndefined matches only undefined
toBeDefined   is the opposite of toBeUndefined
toBeTruthy    matches anything that an if statement treats as true
toBeFalsy     matches anything that an if statement treats as false

For example:
</p>
<code>
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
</code>
</pre>
