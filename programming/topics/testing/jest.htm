<style>
  *{font-size:16px;}
  
  code{
    background-color:black;
    color:#ffffaa;
   display:block;
  }
  b{
   display:block;
   font-size:20px;
   font-weight:900;
   border:1 solid black;}
</style>
<p>
It is a javascript testing framework 
that can be used immidiately after installation no configuration
</p>
<b>To Install </b>
  npm install --save-dev jest
<pre>
<p>
Let's get started by writing a test for a hypothetical function that adds two numbers.
First, create a sum.js file:
 </p>
<code>
function sum(a, b) {
  return a + b;
}
module.exports = sum;
</code>

Then, create a file named sum.test.js. This will contain our actual test:
<code>
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
</code>

<b> toEquel </b>
<code>
test('object assignment', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
</code>

<b> not </b>
<code>
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
</code>

<b>Truthiness</b>
<p>
In tests, you sometimes need to distinguish between 
undefined,
null, 
and false, 
but you sometimes do not want to treat these differently.

Jest contains helpers that let you be explicit about what you want.

toBeNull      matches only null
toBeUndefined matches only undefined
toBeDefined   is the opposite of toBeUndefined
toBeTruthy    matches anything that an if statement treats as true
toBeFalsy     matches anything that an if statement treats as false

For example:
</p>
<code>
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
</code>

<b>Numbers</b>
Most ways of comparing numbers have matcher equivalents.
<code>
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
</code>

<b>Strings</b>
You can check strings against regular expressions with toMatch:
<code>
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
</code>

<b>Arrays and iterables</b>
You can check if an array or iterable contains a particular item using toContain:
<code>
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'milk',
];

test('the shopping list has milk on it', () => {
  expect(shoppingList).toContain('milk');
  expect(new Set(shoppingList)).toContain('milk');
});
</code>

<b>Exceptions</b>
If you want to test whether a particular function throws an error when it's called, use toThrow.
<code>
function compileAndroidCode() {
  throw new Error('you are using the wrong JDK!');
}

test('compiling android goes as expected', () => {
  expect(() => compileAndroidCode()).toThrow();
  expect(() => compileAndroidCode()).toThrow(Error);

  // You can also use a string that must be contained in the error message or a regexp
  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');
  expect(() => compileAndroidCode()).toThrow(/JDK/);

  // Or you can match an exact error message using a regexp like below
  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails
  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass
});
</code>

<b>Promises</b>
Return a promise from your test, and Jest will wait for that promise to resolve. 
If the promise is rejected, the test will fail.

For example,
let's say that fetchData returns a promise 
that is supposed to resolve to the string 'peanut butter'.
We could test it with:
<code>
test('the data is peanut butter', () => {
  return fetchData().then(data => {
    expect(data).toBe('peanut butter');
  });
});
</code>

</pre>
