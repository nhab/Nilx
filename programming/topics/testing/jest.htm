<style>
  *{font-size:20px;}
  html {background-color: #aaaaaa}
  code{
    background-color:black;
    color:#ffffaa;
   display:block;
  }
  b{
   display:block;
   font-size:24px;
   font-weight:900;
   border:1 solid black;}
</style>
<p>
It is a javascript testing framework 
that can be used immidiately after installation no configuration
</p>
<b>To Install </b>
  npm install --save-dev jest
<pre>
<p>
Let's get started by writing a test for a hypothetical function that adds two numbers.
First, create a sum.js file:
 </p>
<code>
function sum(a, b) {
  return a + b;
}
module.exports = sum;
</code>

Then, create a file named sum.test.js. This will contain our actual test:
<code>
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
</code>

<b> toEquel </b>
<code>
test('object assignment', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
</code>

<b> not </b>
<code>
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
</code>

<b>Truthiness</b>
<p>
In tests, you sometimes need to distinguish between 
undefined,
null, 
and false, 
but you sometimes do not want to treat these differently.

Jest contains helpers that let you be explicit about what you want.

toBeNull      matches only null
toBeUndefined matches only undefined
toBeDefined   is the opposite of toBeUndefined
toBeTruthy    matches anything that an if statement treats as true
toBeFalsy     matches anything that an if statement treats as false

For example:
</p>
<code>
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
</code>

<b>Numbers</b>
Most ways of comparing numbers have matcher equivalents.
<code>
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
</code>

<b>Strings</b>
You can check strings against regular expressions with toMatch:
<code>
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
</code>

<b>Arrays and iterables</b>
You can check if an array or iterable contains a particular item using toContain:
<code>
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'milk',
];

test('the shopping list has milk on it', () => {
  expect(shoppingList).toContain('milk');
  expect(new Set(shoppingList)).toContain('milk');
});
</code>

<b>Exceptions</b>
If you want to test whether a particular function throws an error when it's called, use toThrow.
<code>
function compileAndroidCode() {
  throw new Error('you are using the wrong JDK!');
}

test('compiling android goes as expected', () => {
  expect(() => compileAndroidCode()).toThrow();
  expect(() => compileAndroidCode()).toThrow(Error);

  // You can also use a string that must be contained in the error message or a regexp
  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');
  expect(() => compileAndroidCode()).toThrow(/JDK/);

  // Or you can match an exact error message using a regexp like below
  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails
  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass
});
</code>

<b>Promises</b>
Return a promise from your test, and Jest will wait for that promise to resolve. 
If the promise is rejected, the test will fail.

For example,
let's say that fetchData returns a promise 
that is supposed to resolve to the string 'peanut butter'.
We could test it with:
<code>
test('the data is peanut butter', () => {
  return fetchData().then(data => {
    expect(data).toBe('peanut butter');
  });
});
</code>

<b>Async/Await</b>
Alternatively, you can use async and await in your tests. 

To write an async test,
use the async keyword in front of the function passed to test. 

For example, the same fetchData scenario can be tested with:
<code>
test('the data is peanut butter', async () => {
  const data = await fetchData();
  expect(data).toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  expect.assertions(1);
  try {
    await fetchData();
  } catch (e) {
    expect(e).toMatch('error');
  }
});
</code>

You can combine async and await with .resolves or .rejects.
<code>
test('the data is peanut butter', async () => {
  await expect(fetchData()).resolves.toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  await expect(fetchData()).rejects.toMatch('error');
});
</code>
In these cases, 
async and await are effectively syntactic sugar for the same logic as the promises example uses.

<b>Callbacks</b>
If you don't use promises, you can use callbacks. 
For example, 
let's say that fetchData,
instead of returning a promise,
expects a callback,
i.e. fetches some data and calls callback(null, data) when it is complete. 

You want to test that this returned data is the string 'peanut butter'.

By default, Jest tests complete once they reach the end of their execution. 

That means this test will not work as intended:
<code>
// Don't do this!
test('the data is peanut butter', () => {
  function callback(error, data) {
    if (error) {
      throw error;
    }
    expect(data).toBe('peanut butter');
  }

  fetchData(callback);
});
</code>

The problem is that the test will complete as soon as fetchData completes,
before ever calling the callback.

There is an alternate form of test that fixes this. 

Instead of putting the test in a function with an empty argument, 
use a single argument called done. 

Jest will wait until the done callback is called before finishing the test.

<code>
test('the data is peanut butter', done => {
  function callback(error, data) {
    if (error) {
      done(error);
      return;
    }
    try {
      expect(data).toBe('peanut butter');
      done();
    } catch (error) {
      done(error);
    }
  }

  fetchData(callback);
});
</code>
If done() is never called, the test will fail (with timeout error),
which is what you want to happen.

If the expect statement fails,
it throws an error and done() is not called. 

If we want to see in the test log why it failed, 
we have to wrap expect in a try block and pass the error in the catch block to done.
Otherwise, we end up with an opaque timeout error that doesn't show what value was received by expect(data).

<b>.resolves / .rejects</b>
You can also use the .resolves matcher in your expect statement,
and Jest will wait for that promise to resolve.

If the promise is rejected, the test will automatically fail.
<code>
test('the data is peanut butter', () => {
  return expect(fetchData()).resolves.toBe('peanut butter');
});
</code>
Be sure to return the assertion
â€”if you omit this return statement, 
your test will complete before the promise returned 
from fetchData is resolved 
and then() has a chance to execute the callback.

If you expect a promise to be rejected,
use the .rejects matcher.
It works analogically to the .resolves matcher. 

If the promise is fulfilled, the test will automatically fail.
<code>
test('the fetch fails with an error', () => {
  return expect(fetchData()).rejects.toMatch('error');
});
</code>
None of these forms is particularly superior to the others,
and you can mix and match them across a codebase or even in a single file. 
It just depends on which style you feel makes your tests simpler.

Setup and Teardown
Often while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.

Repeating Setup
If you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach hooks.

For example, let's say that several tests interact with a database of cities. You have a method initializeCityDatabase() that must be called before each of these tests, and a method clearCityDatabase() that must be called after each of these tests. You can do this with:

beforeEach(() => {
  initializeCityDatabase();
});

afterEach(() => {
  clearCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});

beforeEach and afterEach can handle asynchronous code in the same ways that tests can handle asynchronous code - they can either take a done parameter or return a promise. For example, if initializeCityDatabase() returned a promise that resolved when the database was initialized, we would want to return that promise:

beforeEach(() => {
  return initializeCityDatabase();
});

One-Time Setup
In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides beforeAll and afterAll hooks to handle this situation.

For example, if both initializeCityDatabase() and clearCityDatabase() returned promises, and the city database could be reused between tests, we could change our test code to:

beforeAll(() => {
  return initializeCityDatabase();
});

afterAll(() => {
  return clearCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});

Scoping
The top level before* and after* hooks apply to every test in a file. The hooks declared inside a describe block apply only to the tests within that describe block.

For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:

// Applies to all tests in this file
beforeEach(() => {
  return initializeCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});

describe('matching cities to foods', () => {
  // Applies only to tests in this describe block
  beforeEach(() => {
    return initializeFoodDatabase();
  });

  test('Vienna <3 veal', () => {
    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);
  });

  test('San Juan <3 plantains', () => {
    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);
  });
});

Note that the top-level beforeEach is executed before the beforeEach inside the describe block. It may help to illustrate the order of execution of all hooks.

beforeAll(() => console.log('1 - beforeAll'));
afterAll(() => console.log('1 - afterAll'));
beforeEach(() => console.log('1 - beforeEach'));
afterEach(() => console.log('1 - afterEach'));

test('', () => console.log('1 - test'));

describe('Scoped / Nested block', () => {
  beforeAll(() => console.log('2 - beforeAll'));
  afterAll(() => console.log('2 - afterAll'));
  beforeEach(() => console.log('2 - beforeEach'));
  afterEach(() => console.log('2 - afterEach'));

  test('', () => console.log('2 - test'));
});

// 1 - beforeAll
// 1 - beforeEach
// 1 - test
// 1 - afterEach
// 2 - beforeAll
// 1 - beforeEach
// 2 - beforeEach
// 2 - test
// 2 - afterEach
// 1 - afterEach
// 2 - afterAll
// 1 - afterAll

Order of Execution
Jest executes all describe handlers in a test file before it executes any of the actual tests. This is another reason to do setup and teardown inside before* and after* handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.

Consider the following illustrative test file and output:

describe('describe outer', () => {
  console.log('describe outer-a');

  describe('describe inner 1', () => {
    console.log('describe inner 1');

    test('test 1', () => console.log('test 1'));
  });

  console.log('describe outer-b');

  test('test 2', () => console.log('test 2'));

  describe('describe inner 2', () => {
    console.log('describe inner 2');

    test('test 3', () => console.log('test 3'));
  });

  console.log('describe outer-c');
});

// describe outer-a
// describe inner 1
// describe outer-b
// describe inner 2
// describe outer-c
// test 1
// test 2
// test 3

Just like the describe and test blocks Jest calls the before* and after* hooks in the order of declaration. Note that the after* hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:

beforeEach(() => console.log('connection setup'));
beforeEach(() => console.log('database setup'));

afterEach(() => console.log('database teardown'));
afterEach(() => console.log('connection teardown'));

test('test 1', () => console.log('test 1'));

describe('extra', () => {
  beforeEach(() => console.log('extra database setup'));
  afterEach(() => console.log('extra database teardown'));

  test('test 2', () => console.log('test 2'));
});

// connection setup
// database setup
// test 1
// database teardown
// connection teardown

// connection setup
// database setup
// extra database setup
// test 2
// extra database teardown
// database teardown
// connection teardown
</pre>
