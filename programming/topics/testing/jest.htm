<style>
  *{font-size:16px;}
  
  code{
    background-color:black;
    color:#ffffaa;
   display:block;
  }
  b{
   display:block;
   font-size:20px;
   font-weight:900;
   border:1 solid black;}
</style>
<p>
It is a javascript testing framework 
that can be used immidiately after installation no configuration
</p>
<b>To Install </b>
  npm install --save-dev jest
<pre>
<p>
Let's get started by writing a test for a hypothetical function that adds two numbers.
First, create a sum.js file:
 </p>
<code>
function sum(a, b) {
  return a + b;
}
module.exports = sum;
</code>

Then, create a file named sum.test.js. This will contain our actual test:
<code>
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
</code>

<b> toEquel </b>
<code>
test('object assignment', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
</code>

<b> not </b>
<code>
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
</code>

<b>Truthiness</b>
<p>
In tests, you sometimes need to distinguish between 
undefined,
null, 
and false, 
but you sometimes do not want to treat these differently.

Jest contains helpers that let you be explicit about what you want.

toBeNull      matches only null
toBeUndefined matches only undefined
toBeDefined   is the opposite of toBeUndefined
toBeTruthy    matches anything that an if statement treats as true
toBeFalsy     matches anything that an if statement treats as false

For example:
</p>
<code>
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
</code>

<b>Numbers</b>
Most ways of comparing numbers have matcher equivalents.
<code>
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
</code>

<b>Strings</b>
You can check strings against regular expressions with toMatch:
<code>
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
</code>

<b>Arrays and iterables</b>
You can check if an array or iterable contains a particular item using toContain:
<code>
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'milk',
];

test('the shopping list has milk on it', () => {
  expect(shoppingList).toContain('milk');
  expect(new Set(shoppingList)).toContain('milk');
});
</code>

<b>Exceptions</b>
If you want to test whether a particular function throws an error when it's called, use toThrow.
<code>
function compileAndroidCode() {
  throw new Error('you are using the wrong JDK!');
}

test('compiling android goes as expected', () => {
  expect(() => compileAndroidCode()).toThrow();
  expect(() => compileAndroidCode()).toThrow(Error);

  // You can also use a string that must be contained in the error message or a regexp
  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');
  expect(() => compileAndroidCode()).toThrow(/JDK/);

  // Or you can match an exact error message using a regexp like below
  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails
  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass
});
</code>

<b>Promises</b>
Return a promise from your test, and Jest will wait for that promise to resolve. 
If the promise is rejected, the test will fail.

For example,
let's say that fetchData returns a promise 
that is supposed to resolve to the string 'peanut butter'.
We could test it with:
<code>
test('the data is peanut butter', () => {
  return fetchData().then(data => {
    expect(data).toBe('peanut butter');
  });
});
</code>

<b>Async/Await</b>
Alternatively, you can use async and await in your tests. 

To write an async test,
use the async keyword in front of the function passed to test. 

For example, the same fetchData scenario can be tested with:
<code>
test('the data is peanut butter', async () => {
  const data = await fetchData();
  expect(data).toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  expect.assertions(1);
  try {
    await fetchData();
  } catch (e) {
    expect(e).toMatch('error');
  }
});
</code>

You can combine async and await with .resolves or .rejects.
<code>
test('the data is peanut butter', async () => {
  await expect(fetchData()).resolves.toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  await expect(fetchData()).rejects.toMatch('error');
});
</code>
In these cases, 
async and await are effectively syntactic sugar for the same logic as the promises example uses.

<b>Callbacks</b>
If you don't use promises, you can use callbacks. 
For example, 
let's say that fetchData,
instead of returning a promise,
expects a callback,
i.e. fetches some data and calls callback(null, data) when it is complete. 

You want to test that this returned data is the string 'peanut butter'.

By default, Jest tests complete once they reach the end of their execution. 

That means this test will not work as intended:
<code>
// Don't do this!
test('the data is peanut butter', () => {
  function callback(error, data) {
    if (error) {
      throw error;
    }
    expect(data).toBe('peanut butter');
  }

  fetchData(callback);
});
</code>

The problem is that the test will complete as soon as fetchData completes,
before ever calling the callback.

There is an alternate form of test that fixes this. 

Instead of putting the test in a function with an empty argument, 
use a single argument called done. 

Jest will wait until the done callback is called before finishing the test.

<code>
test('the data is peanut butter', done => {
  function callback(error, data) {
    if (error) {
      done(error);
      return;
    }
    try {
      expect(data).toBe('peanut butter');
      done();
    } catch (error) {
      done(error);
    }
  }

  fetchData(callback);
});
</code>
If done() is never called, the test will fail (with timeout error),
which is what you want to happen.

If the expect statement fails,
it throws an error and done() is not called. 

If we want to see in the test log why it failed, 
we have to wrap expect in a try block and pass the error in the catch block to done.
Otherwise, we end up with an opaque timeout error that doesn't show what value was received by expect(data).

</pre>
