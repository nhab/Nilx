<head>
<meta charset='UTF-8' />
<meta name='viewport' content='width=device-width, initial-scale=1' />
<link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/nhab/nhab@latest/assets/css/blocks.css'>
<script src='https://cdn.jsdelivr.net/gh/nhab/nhab@latest/assets/js/blocks.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js'></script>
<script src='https://code.jquery.com/jquery-3.6.3.min.js'></script>
</head>
<body onload='AddToggleButtons();ReplaceLtGt();hljs.highlightAll();'>
 <button onclick="toggleAll(this);" >-</button>
	
<h2>Resources</h2>
<div><p>
<a href="https://www.google.com/search?q=c%23+ddd+context+maps+domain+event&&oq=c%23+ddd+context+maps+domain+event"
   target="_blank"
   >Research DDD</a>
<a href="https://github.com/heynickc/awesome-ddd" target="_blank"
   >awesome DDD</a>
<a href="awesome-architecture.com" target="_blank"
   >Awesome Architechturre</a>
<a href="https://martinfowler.com/tags/domain%20driven%20design.html" target="_blank"
	 >DDD of martin fowler</a>
<a href="https://stackoverflow.com/questions/tagged/domain-driven-design" target="_blank"        
   >DDD in stackoverflow</a>
</p></div>
        
<h2>What is domain driven design( DDD ) ?</h2>
<div><p>
 DDD is designing the domain model classes first ,
 based on  input from that domain's experts then creating database based on the domain model. 

  . Domain driven methodology(code first aproach) 
	allows developers to focus and think through in terms of business domain objects
        rather than creating domain model classes to match the database design in Database First approach.

  . In terms of object-oriented programming
	it means that the structure and language of software code should match the business domain.
        (Including class names, class methods, class variables)
	
   . For example, if a software processes loan applications, 
     it might have classes like LoanApplication and Customer, and methods such as AcceptOffer and Withdraw.

 . Domain-driven design is predicated on the following goals:
    - placing the project's primary focus on the core domain and domain logic;
    - basing complex designs on a model of the domain;
    - initiating a creative collaboration between technical and domain experts 
      to iteratively refine a conceptual model that addresses particular domain problems.  
  </p>
    </div>
    <h2 style="display:flex"><input type="button" value="-"
        style="font-size:20px;margin-right:5px;vertical-align: middle;"  
        onclick="toggle(this)" />Ubiquitous language</h2>
    <p>
    -  Most of  ambiguities, can be solved with proper naming of classes and methods,
    making them express what an object is and what a method does in the context of the domain.

    -  The main idea of using a Ubiquitous Language is to align the application with the business. 
        This is accomplished by adopting a common language, between the business and technology, in the code. 

    -The source for the language is the business side of the company, 
    they have the concepts that need to be implemented, 
    but the terminology is then negotiated with the technology side of the company 
    (meaning that the business side doesn’t always choose the best naming either) 
    with the objective of creating a common terminology that can be used by business, 
    technology and in the code itself without any ambiguity, a ubiquitous language. 

    -The code, classes, methods, properties and modules naming must align with the ubiquitous language.
    -It is the practice of using the terms used throughout the business within the codebase, 
    and working new terms from the modeling back into the business.

    - Language often evolves and the codebase should evolve with the language.
    - The essence really of DDD is that your code models the processes within the business
	    and if you are not starting with the same language then how descriptive can it really be. 
    - If a product owner is looking at the application code 
      he should recognise the classes, methods, and variables as models, workflows, and actions that actually occur.
    </p>   
	
    <h2 style="display:flex">Layers</h2>
    <p>
    layers in DDD are: 
        <b>
        . User interface
        . Application
        . Domain
        . Infrrastructure
        </b>
    </p>
	
    <h2 style="display:flex">DDD architecture Layers</h2>
    <div> <p>
        . Business Logic places into two layers, the Domain layer and the Application Layer,
	    while they contain different kinds of business logic;

        . DDD architecture Layers are:
       
            ● <b>Domain Layer</b> implements the core, use-case 
            independent business logic of the domain/system.
            
            ● <b>Application Layer</b>  implements the use cases of the 
            application based on the domain. A use case can be 
            thought as a user interaction on the User Interface (UI)
    
            ● <b>Presentation Layer </b> contains the UI elements (pages, components) of the application.
    
            ● <b>Infrastructure Layer</b>  supports other layer by implementing the abstractions and integrations to 3rd-party library and systems.
        </p> 
        . In the Clean Architecture, each layer only depends on the layer directly inside it.
    </div>
    
    <h2 style="display:flex">Domain layer building blocks</h2>
<div>
    <p>
        ●  <b>Entity:</b> An Entity is an object with its own properties 
                (state, data) and methods that implements the business 
                logic that is executed on these properties. An entity is 
                represented by its unique identiﬁer (Id).

                Entities are the classes that model the domain concepts and have identity. 
                This usually means there is a unique primary key associated with the entity. 
                Remember that modelling in DDD takes us back to the OOP we learned in the text books... behavior and data together.
                This is in antithesis to the usual anemic models found in most software.              
                               
        ●   <b>Value Object: </b>A Value Object is another kind of domain 
                object that is identiﬁed by its properties rather than a unique Id. 
                That means two Value Objects with same properties are considered as the same object. 
                Value objects are generally implemented as immutable and 
                mostly are much simpler than the Entities.  

                Value objects are much like entities except they do not have identity.
                Money is the quintessential example of a model that shows intent, contains rules, 
	        but does not have identity. 
	    
                The important part here is using types to convey meaning as well as place logic
	        along with the data in a very obvious way.   
    
        ●   <b>Agregate</b>A DDD aggregate is a cluster of domain objects that can be treated as a single unit. 
            An example may be an order and its line-items, these will be separate objects, 
	    but it's useful to treat the order (together with its line items) as a single aggregate.

            An Aggregate is a hierarchy of objects (Entities and Value objects) that make up a consistency boundary.
            
            Why would we want to set a boundary rather than just reference any object needed?
        
            Minimising associations helps to prevent a reference web.
            This can be problematic when fetching and reconstituting a hierarchy of objects into memory. 
            
	    Lazy loading can quickly get out of hand, 
	    alternatively null references about and conntinually need to be checked.
        
            Let us turn the question around.
            What if the relationships of our object model clearly showed us the effects of change? 
            For example, the aggregate was the scope of the transaction...
        
        
        ●   <b>Agregate root</b>Each AGGREGATE has a root and a boundary. 
                The boundary defines what is inside the AGGREGATE.
	        The root is a single, specific ENTITY contained in the AGGREGATE.
                The root is the only member of the AGGREGATE that outside objects are allowed to hold references to.
                Example: An example is a model containing a Customer entity and an Address entity. 
                
	        We would never access an Address entity directly from the model 
	        as it does not make sense without the context of an associated Customer. 
	    
                So we could say that Customer and Address together form an aggregate
	        and that Customer is an aggregate root.
        
                
                The Aggregate Root is an Entity that all other Entities and Value Objects in the hierarchy hang off. 
                For example if you have an Order with Order Lines and a Supplier,
	         the OrderRepository will return an Order with all OrderLines and OrderSupplier populated. 
	    
                If would not be possible to fetch an OrderLine separately, nor a OrderSupplier. 
	    
                 If needed though you would provide methods on your OrderRepository to fetch an order
	          by Order Line Id or by Supplier Reference for example.
                    
                 
                 Technical difficulties implementing an aggregate (like transaction issues persisting it) 
	         are usually indicative of a poorly chosen model.
	    
                 Put more effort refining the model 
	         rather than trying to fix a modelling problem with a technical implementation.
                        
                  Access to objects from outside the aggregate must occur through the Aggregate Root.
                        
                  Aggregates are always constructed in a consistent state.
                        
                  The logic is usually within the aggregate to disallow consistent state 
	          or at least check its consistency.
                        
                   It is better to encapsulate changes to state through method calls 
	          rather than directly mutating properties. 
	    
                   This shows intent as well as adds an extra layer of indirection
	          allowing implemntation changes without changing the API.
                           
        ●   <b>Repository (interface):</b>
	        A Repository is a collection-like interface that is used by the Domain 
	        and Application Layers to access to the data persistence system (the database). 
	    
                ● It hides the complexity of the DBMS from the business code. 
                ● Domain Layer contains the interfaces of the repositories.  
        
                ● "Mediates between the domain and data mapping layers 
	         using a collection-like interface for accessing domain objects" (Martin Fowler).
	    
                Repositories, in practice, are used to perform database operations for domain objects.
	        Generally, a separated repository is used for each aggregate root or entity.
    
                ● Common Repository principles are;
                    ●  Deﬁne a repository interface in the Domain Layer 
                    (because it is used in the Domain and Application Layers),
                    implement in the Infrastructure Layer
                    (EntityFrameworkCore project in the startup template). 
                    ●  Do not include business logic inside the repositories. 
                    ●  Repository interface should be database provider / ORM
                    independent. For example, do not return a DbSet from a 
                    repository method. DbSet is an object provided by the EF 
                    Core.
                    ●  Create repositories for aggregate roots, not for all 
                    entities. Because, sub-collection entities (of an aggregate) 
                    should be accessed over the aggregate root.
                ● Repositories will be implemented in intrface layer  
                
                Repositories protect us from taking a data-centric view of our code.
                They allow us to persist and retrieve aggregates 
	        without dealing directly with the underlying persistence.
	    
                It is however important for developers to at least be aware of the underlying implementations
	        so as not to abuse the repository from a performance or scoping way.
            
                The abstraction of the repository is contained within the domain.
	        This abstraction knows about the domain models within that context.
	    
                More specifically it knows about the aggregate that it is returning.
	    
                A repository returns an Entity (or collection of Entities) and the aggregate
	         for wich that Entity is the Aggregate Root.
            
                The implementation of the repository abstraction does not reside in the domain. 
	        It is a Infrastructural concern and can change.
                What is important though is that the repository handles mapping
	        however the data is persisted into a fully hydrated and consistent aggregate.
            
                The developer is free to add multiple query methods to the repository 
	    but the return results are always in terms of the Aggregate Root.
              
                    The repository abstraction is part of the domain
                    The repository implementation is NOT part of the domain
                    The repository exposes data in terms of that repository's Aggregate Root
                    Query methods should use the domain language
                    If complex queries look to encapsulate in query objects using the Specification pattern
                    Transaction should be controlled by the client code
            
        ●   <b>Domain Service: </b>
            ● A Domain Service is a stateless service that <b>implements core business rules</b> of the domain. 
            ●  It is useful to implement domain logic that
	     depends on multiple aggregate (entity) type or some external services.
    
            ●  Services come in 3 flavours: 
	           Domain Services, Application Services, and Infrastructure Services.
	    
            <b>Domain Services :</b>
	    Encapsulates business logic that doesn't naturally fit within a domain object,
	    and are NOT typical CRUD operations – those would belong to a Repository.
	    
            <b>Application Services : </b>
	    Used by external consumers to talk to your system (think Web Services). 
	    If consumers need access to CRUD operations, they would be exposed here.
                    <b>Infrastructure Services :</b> Used to abstract technical concerns 
	    (e.g. MSMQ, email provider, etc).
	    
            ●  Keeping Domain Services along with your Domain Objects is sensible
	        ( they are all focused on domain logic).
                And you can inject Repositories into your Services.
                Depends on services and repositories.
            ●  Needs to work with multiple aggregates, so the logic doesn't properly ﬁt in any of the aggregates.
            ●  Domain Services work with Domain Objects. 
            ●  Their methods can get and return entities, value objects, primitive types... etc. 
            ●  However, they don't get/return DTOs. DTOs is a part of the Application Layer.
                
            ● 
                    Don't give up too quickly trying to fit an operation into the model (concider a new concept that encapsulates entities and values objects...
                    maybe this is actual aggregate root?)
                    The Service is named after an activity (verb not noun)
                    Services are stateless
                    Services still use the Ubiquitous Language
                
        ●   <b> Speciﬁcation:</b>
          
                ● A Speciﬁcation is used to deﬁne named, reusable, 
	          combinable and testable ﬁlters for Domain Objects based on the business rules.
                ● you can think of specifications as of domain classes that categorize other domain classes. 
                ● A specification answers the question of whether a domain object meets some criteria.
                ● he main benefit of the Specification pattern is that you can reuse that knowledge (of whether a domain object meets some criteria) in different scenarios 
                 and therefore adhere to the Don’t Repeat Yourself principle.
                ● Here are the typical use cases for this pattern:
              
                    <b>Data retrieval</b> — Querying objects from the database that meet the criteria
                    <b>In-memory validation</b> — Checking that an object in the memory meets the criteria
                    <b>Creation of a new object</b> — Creating a new (arbitrary) object that meets the criteria
                    <b>Bulk updates</b> — Modifying a bunch of objects that meet the criteria
                </div>
                ● Speciﬁcation<T> base class simpliﬁes to create a speciﬁcation class by deﬁning an expression. 
            </div>
        ●   <b>Domain Event: </b>A Domain Event is a way of informing other services in a loosely coupled manner, when a domain speciﬁc event occurs.

        ● <b>Factories</b>
            Since an aggregate should always be in a consistent state it is important that they are constructed in a consistent state to the user.
            Factories provide a way to ensure that new instances of an aggregate always start in a consistent state.
    </p>
</div>
   <h2 style="display:flex">Application layer building blocks</h2>
   <div> <p>
        ●  <b>Application Service:</b>
	   An Application Service is a stateless service that implements use cases of the application. 
                An application service typically gets and returns DTOs. It is used by the Presentation Layer.
                It uses and coordinates the domain objects to implement the use cases. A use case is typically considered as a Unit Of Work.
                
                The application service is what presents an input for a use-case. 
                It calls off to the domain for execution, calls any other services (like notifications) and returns.
                This could be something like a WebApi controller in .NET or you could choose to explicitly create an an application service.
                
               
                    A thin layer that receives a request and passes it to the domain to processes
                    Think use-case
                    A good place to handle transactions
                    Can call out to Infrastructure Services

        ●   <b>Data Transfer Object (DTO):</b>
	   A DTO is a simple object without any business logic that is used to transfer state 
            (data) between the Application and Presentation Layers.
    
        ●   <b>Unit of Work (UOW):</b>
	   A Unit of Work is an atomic work that should be done as a transaction unit. 
                All the operations inside a UOW should be committed on success or rolled back on a failure.
    
    </p>
</div>
    <h2 style="display:flex">User Interface layer</h2>
   <div> <p>
    Responsible for drawing the screens the users use to interact with the application 
	   and translating the user’s inputs into application commands.
    the “users” can be human but can also be other applications connecting to our API,
	   which corresponds entirely to the Boundary objects in the EBI architecture;
</p></div>
    <h2 style="display:flex">Application Layer</h2>
    <div><p>
    Orchestrates Domain objects to perform tasks required by the users: the Use Cases. 
	    It does not contain business logic.
	    This relates to the Interactors in the EBI architecture,
	    except that the Interactors were any object that was not related to the UI or an Entity and,
	    in this case, the Application Layer only contains the objects relevant to a Use Case.
	    
     This layer is where the Application Services belong,
	    as they are the containers where the use case orchestration happens, 
	    using repositories, Domain Services, Entities, Value Objects or any other Domain object;
	    </p></div>

    <h2 style="display:flex">Infrastructure</h2>
    <div><p>The technical capabilities that support the layers above, ie. persistence or messaging.
	    </p>    
</div>
    
<h2 style="display:flex">Bounded context</h2>    
<div>
<p>
 In an enterprise application,
the model can grow quite a lot and the size of the team working on the code base as well.
	
The usual solution to a big problem is to break it up into smaller pieces,
and this is exactly where the “bounded contexts” come into play.

Two subsystems commonly serve very different user communities

Bounded contexts define a context where an isolated part of the model applies. 
The isolation can be achieved by decoupling technical logic, 
by code base segregation, by database schema segregation and also in terms of team organisation. 
	
The degree to which we isolate the bounded context is, as usual, 
dependent on the actual situation: the needs and possibilities we have.

Already back then he had quite a few very concrete ideas about this subject:

The system thus consists of a number of subsystems which can contain subsystems of themselves. 
At the bottom of such a hierarchy are the analysis objects. 
	
Subsystems are thus a way of structuring the system for further development and maintenance
The task of the subsystems is to package the objects so that the complexity is reduced.
	
All the objects having to do with a particular part of the functionality will be placed in the same subsystem
The aim is to have a strong functional coupling within a subsystem and a weak coupling between subsystems
(nowadays known as low coupling and high cohesion)
[One subsystem] should therefore preferably be coupled to only one actor,
since changes are usually caused by an actor
[…] begin by placing the control object in a subsystem, 
and then place strongly coupled entity objects and interface objects in the same subsystem
All objects which have a strong mutual functional coupling will be placed in the same subsystem […]
Will changes in one object lead to changes in the other object? 
(This is now known as The Common Closure Principle – Classes that change together are packaged together)
Do they communicate with the same actor?
Are both of them dependent on a third object, such as an interface object or an entity object?
Does one object perform several operations on the other? 
(This is now known as The Common Reuse Principle – Classes that are used together are packaged together)
Another criterion for the division is that there should be as little communication between different subsystems as possible (low coupling)
For large projects, there may thus be other criteria for subsystem division, for example:
Different development groups have different competence or resources, 
and it may be desirable to distribute the development work accordingly 
(the groups may also be geographically separated)
	
In a distributed environment, a subsystem may be wanted at each logical node (SOA, web services and micro services)
If an existing product can be used in this system,
this may be regarded as a subsystem (libraries our system depends on, i.e. an ORM)

The Bounded context is the context in which the Ubiquitous language and the corresponding models are valid.
As developer it is a common trap to fall into to try reuse code and concepts across contexts. 
This is a recipe for disaster since the terms 
and verbs used to describe a model in one context will likely be similar but not the same.
	
 This results in blurring of the model to cater for both. 
This adds confusion as well as inviting changes with unintended consequences.
  This is especially true when a model is shared across more than one team
(strongly concider whether it really is one context).
    Example

    Imagine a Product class in the Logistics domain. 
    For tracking around the warehouse you need a barcode, for shipping you need the packaged dimensions and weight.
    Now think of a product for display on an e-commerce website.
    You need photos, description, and other specs like its actual dimensions unpacked.
</p>    
</div>

<h2 style="display:flex">Anti-corruption layer (ACL)</h2>
<div>
 <p>  
    An ACL is at the very least a thin translation layer between two bounded contexts. 
    Even if both bounded contexts are well defined, and share similar models.
    The models in one context should not influence the models in another
	and without a layer in between to translate between the two corruption will creep in. 
	 
    If the external system a bounded context is talking to is a legacy system with a very poor model 
	it is even more likely it will corrupt unless the ACL acts as a strong buffer.
    
    
    Why would a developer need all of this at one time?
    Why confuse matters? Why would the clients of the code like a scanner in the warehouse
	 or a customer on the website need both?
    If all that is shared is maybe a name and a SKU,
is the code sharing of 2 properties worth coupling different parts of the system? Different teams together?
   
There are many reasons to want to keep Anti-Corruption Layer

An anti-corruption layer is basically a middleware between two subsystems.
 It is used to isolate the two subsystems, making them depend on the anti-corruption layer
	 instead of depending directly on each other.
  This way, if we refactor or completely replace one of the subsystems, 
	 we will only have to update the anti-corruption layer leaving the other subsystem untouched.

This is especially useful when we have a new system that we need to integrate with a legacy system.
 In order to not let the legacy structure dictate how we design the new system, 
we create an anti-corruption layer that will adapt the API of the legacy subsystem to the needs of the new subsystem.

It has 3 main concerns:

Adapting subsystems APIs to what the client subsystems need;
Translating data and commands between subsystems;
Establish communication in one or several directions, as needed

This is a technique that is more logical to be used when we don’t control one or all of the subsystems,
	but it might also make sense to use it when we control all of the subsystems involved, 
even if they are well designed but simply have very different models and we want to prevent leakage from one model to another 
	 (change one subsystem to match the needs of another subsystem).
</p>
</div>

<h2 style="display:flex">Shared Kernel</h2>
<div>
<p>
In some situations, despite our desire to have completely isolated and decoupled components, 
	it makes sense for some domain code to be shared by multiple components.

This will allow components to stay decoupled from each other, 
	although coupled to that same shared code, the shared kernel.

That is the case, for example, with events that are triggered by one component
and listened to by another one or several components.
But it can also be the case with service interfaces and even entities.

Nevertheless, we should keep the shared kernel small, 
and be very careful when changing it so we don’t inadvertedly break other code using it. 
	
It is important that the code in the shared kernel is not changed 
without consultation with the other development teams using it.
</p>
</div>

<h2 style="display:flex">Generic Subdomain</h2>
<div>
<p>
A subdomain is a very well isolated part of the domain.
A generic subdomain is a subdomain that is not specific to our application,
it could be used in any similar application.

So, if we have an application which has part of it that is about finance, 
maybe we can use an existing finance library in our application. 
	
But either way, even if we can’t use an existing library and need to build our own,
if it is a generic subdomain it is not our core business and it should be thought of as essential but not crucial.
 It is not the most important part of our application, 
so it is not where our best experts should be focused and it should even be clearly outside of the main source code,
  possibly installed with a dependency management tool.
	
these models seperated based on their context and few reasons to combine them.
    Yet it is a very common occurance in development. Why? Code re-use.
    Only re-use models if they are indeed the same model.
 </p>   
</div>

<h2 style="display:flex">Infrastructure Service</h2> 
<div>
<p>
    This is a technical implementation for something that performs some task such as notifications (IM, email, etc.),
     put messages on a bus, or retrieve some data from another system.
</p>    
</div>

<h2 style="display:flex">Modules</h2>
<div>
    <p>
        Modules are simply packages or assemblies. Whatever your technology's means is of bundling built code is.   
    </p>
</div>

<h2>Shared Kernel</h2>
<div>
<p>
    Sometimes a model needs to be shared across multiple Bounded Contexts.
    If so a Shared Kernel can be created but in a lot of cases the coupling created 
	between the contexts and the teams is not worth it.  
</p>
</div>

<h2><input type="button" value="-" class="toggleButton"  
    onclick="toggle(this)" />Clients</h2>
<div><p>
   Clients are the callers of the application layer.
    These could be another application automated service or an application been driven by a user. 
    Regardless the clients execute the use-cases defined in the application layer.    
</p>
</div>

<h2>Domain Events and Integration Events </h2>
<div>
<h3>Domain Events</h3>
<p>
 are used to allow aggregates to react to a change in another aggregate without coupling them.
- For handling processes that do require asynchronous behaviour and aggregates in different sub-domains or microservices,
 Integration Events can be published using a Message Broker/Event Bus.
- It is important that Integration Events are published after a transaction completes successfully and 
that mechanisms are in place to ensure that Integration Events are always published successfully.

-Event Bus — An in-memory Event Bus has been created to handle Integration Events asynchronously.
 In a real application, a third-party tool would be used such as Rabbit MQ
Mediator — MediatR has been used to publish and handle Domain Events
</p>
<h3>scenario</h3>
<p>
The sample simulates the following scenario:

A Basket is created
Products are added to the Basket
When the Basket is checked-out, an Order is created
A Shipping Address is added to the Order
A Payment Method is selected for the Order
When the Order is submitted an Invoice is generated
When the Invoice is paid the Order is dispatched
</p>
<h3>Domain Events Implementation</h3>
<p>	
Domain Events should be raised from an Aggregate. 
Static methods can be used to handle Domain Events as soon as they are raised
however there are better ways of doing this.
It is much better if handling can be delayed 
until after the command/operation on the Aggregate has completed 
in case there is an error or any other behaviour that follows.
Domain Events model something that has happened in the past so ideally, our code should reflect this as well.
</p>
<h3>Raising a Domain Event</h3>
Since Domain Events should be raised from an Aggregate it makes sense to hold them inside the base AggregateRoot class.
<pre><code>
namespace DDDMart.SharedKernel
{
    public abstract class AggregateRoot : Entity
    {
        private List<DomainEvent> _domainEvents;
        public IReadOnlyCollection<DomainEvent> DomainEvents => _domainEvents?.AsReadOnly();

        protected void AddDomainEvent(DomainEvent eventItem)
        {
            _domainEvents = _domainEvents ?? new List<DomainEvent>();
            _domainEvents.Add(eventItem);
        }

        public void ClearDomainEvents()
        {
            _domainEvents?.Clear();
        }
    }
}
</code></pre>
The following snippet from one of the Aggregates in the Orders bounded-context 
shows how Domain Events can be raised on particular actions.

<pre><code>
namespace DDDMart.Ordering.Core.Orders.Entities
{
    public class Order : AggregateRoot
    {
        public Guid CustomerId { get; private set; }
        public Guid BasketId { get; private set; }
        public OrderStatus Status { get; private set; }
        public ShippingAddress ShippingAddress { get; private set; }
        public Guid PaymentMethodId { get; private set; }
        public PaymentAddress PaymentAddress { get; private set; }       

        private readonly List<OrderItem> _items = new List<OrderItem>();
        public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
        
        // ...

        public void Submit()
        {
            CheckIfCancelled();
            if (Submitted)
            {
                throw new DomainException("Order has already been submitted");
            }
            if(Status != OrderStatus.PaymentMethodConfirmed)
            {
                throw new DomainException("Payment Method and Delivery Address must be selected before submitting the order");
            }
            Status = OrderStatus.Submitted;
            AddDomainEvent(new OrderSubmittedDomainEvent(Id, CustomerId, PaymentMethodId, PaymentAddress, TotalPrice));
        }

        public void Dispatch()
        {
            CheckIfCancelled();
            if (Status != OrderStatus.Paid)
            {
                throw new DomainException("Order must be paid before dispatching");
            }
            DispatchedDate = DateTime.UtcNow;
            Status = OrderStatus.Dispatched;
            AddDomainEvent(new OrderDispatchedDomainEvent(Id, CustomerId, DispatchedDate.Value));
        }

        public void Cancel()
        {
            Status = OrderStatus.Cancelled;
            AddDomainEvent(new OrderCancelledDomainEvent(Id, CustomerId));
        }

        private void CheckIfCancelled()
        {
            if (Cancelled)
            {
                throw new DomainException("Order has been cancelled.");
            }
        }
    }
}
</code></pre>

<h3>Dispatching Domain Events</h3>
If you are using Entity Framework then you can take advantage of the Change Tracker to extract any Domain Events that have been created directly before the database changes are saved.
<pre><code>
public abstract class DbContextBase<T> : DbContext, IUnitOfWork where T : DbContextBase<T>
{
    private readonly IMediator _mediator;

    protected DbContextBase(DbContextOptions<T> options,
        IMediator mediator) : base(options)
    {
        _mediator = mediator;
    }

    public async Task<bool> CommitAsync(CancellationToken cancellationToken = default)
    {
        // Dispatch Domain Events collection. 
        // Right BEFORE committing data (EF SaveChanges) into the DB will make a single transaction including  
        // side effects from the domain event handlers which are using the same DbContext with "InstancePerLifetimeScope" or "scoped" lifetime
        await _mediator.DispatchEventsAsync(this);

        // After executing this line all the changes (from the Command Handler and Domain Event Handlers) 
        // performed through the DbContext will be committed
        await base.SaveChangesAsync(cancellationToken);

        return true;
    }

    // ...
}
</code></pre>
In the sample project, MediatR is used to publish the Domain Events so that they can be consumed by any registered Domain Event Handlers.
MediatR allows multiple handlers to be registered for each event if required as well. 
I find that the mediator pattern is a perfect way to separate the Domain Event Handlers from the Domain Events being raised and published.

<pre><code>
internal static class MediatorExtensions
{
    public static async Task DispatchEventsAsync<T>(this IMediator mediator, DbContextBase<T> context) where T : DbContextBase<T>
    {
        var aggregateRoots = context.ChangeTracker
            .Entries<AggregateRoot>()
            .Where(x => x.Entity.DomainEvents != null && x.Entity.DomainEvents.Any())
            .Select(e => e.Entity)
            .ToList();

        var domainEvents = aggregateRoots
            .SelectMany(x => x.DomainEvents)
            .ToList();

        await mediator.DispatchDomainEventsAsync(domainEvents);

        ClearDomainEvents(aggregateRoots);
    }

    private static async Task DispatchDomainEventsAsync(this IMediator mediator, List<DomainEvent> domainEvents)
    {
        foreach (var domainEvent in domainEvents)
        {
            await mediator.Publish(domainEvent);
        }
    }

    private static void ClearDomainEvents(List<AggregateRoot> aggregateRoots)
    {
        aggregateRoots.ForEach(aggregate => aggregate.ClearDomainEvents());
    }
}
</code></pre>
<h3>Consuming Domain Events</h3>
The following Domain Event Handler shows how an Order is generated when a Basket is checked-out. 
The handler is executed when mediator.Publish(domainEvent) is called for BasketCheckedOutDomainEvent.

<pre><code>
public class BasketCheckedOutDomainEventHandler : DomainEventHandler<BasketCheckedOutDomainEvent>
{
    private readonly IBasketsRepository _basketsRepository;
    private readonly IOrdersRepository _ordersRepository;
    private readonly ILogger<BasketCheckedOutDomainEventHandler> _logger;

    public BasketCheckedOutDomainEventHandler(IBasketsRepository basketsRepository,
        IOrdersRepository ordersRepository,
        ILogger<BasketCheckedOutDomainEventHandler> logger)
    {
        _basketsRepository = basketsRepository;
        _ordersRepository = ordersRepository;
        _logger = logger;
    }

    public override async Task HandleAsync(BasketCheckedOutDomainEvent @event)
    {
        _logger.LogInformation("Creating order from basket {id}", @event.BasketId);
        var basket = await _basketsRepository.GetByIdAsync(@event.BasketId);
        var order = Order.FromBasket(basket);
        await _ordersRepository.InsertAsync(order);
        // UnitOfWork should not be commited here as it will be
        // commited when the EF changes are saved after all of the Domain Event Handlers
        // have been processed
        _logger.LogInformation("Created order {id}", order.Id);
    }
}
</code></pre>
The previous examples are able to work via the MediatR library because the base DomainEventclass inherits from INotification
 and the base DomainEventHandler class inherits from INotificationHandler<T> where T : DomainEvent.

<h3>Domain Event Considerations</h3>
There are a couple of important considerations to keep in mind when designing your Domain Events and their associated Handlers:

1. The Handlers are processed in the same Unit of Work that they were dispatched from.

The handlers are processed in a Unit of Work directly before EF saves changes to the database.
Therefore, another Unit of Work or transaction should not be started from a handler as there is already an existing one ongoing.
 If a new Unit of Work was started in a handler then there could be a situation where that transaction is successful but the parent transaction fails. 
You also shouldn’t Commit a Unit of Work from a handler as it is already being processed within a Commit operation.

2. The parent Unit of Work could fail when Committed.

Even though your preceding code that published the event ran successfully, the transaction could still fail when committed to the database.
 e.g. foreign key clash, database unavailable. Obviously, in DDD, your preceding code should check for most of these scenarios, but we are all human at the end of the day!

This means that you shouldn’t do anything in your handlers that can’t be committed or reversed separately. 
Generally, this means calling external services which are out of our control. Here’s some examples to watch out for:

Sending emails to users
Writing data to another API
Publishing a Message or Integration Event
Luckily this type of scenario can instead be handled Asynchronously using Integration Events!

<h3>Integration Events Implementation</h3>
Integration Events should be published to a Message Broker and handled asynchronously.
This allows for retry logic if there are any problems in downstream systems and will result in Eventual Consistency.

<h3>Storing integration events to the outbox</h3>
In the sample application, Integration Events are serialized to JSON and stored in the database along with the Event Name.
<pre></code>
namespace DDDMart.SharedKernel.Outbox.Entities
{
    public class OutboxIntegrationEvent : AggregateRoot
    {
        public OutboxIntegrationEvent(string eventName, string data)
        {
            EventName = eventName;
            Data = data;
        }

        public string EventName { get; private set; }
        public string Data { get; private set; }
    }
}
</code></pre>
An OutboxIntegrationEvents table is created in the EF DbContext for each sub-domain for storing the Integration Events. 
An Integration Event Mapper is injected to map Domain Events to Integration Events.
<pre><code>
public abstract class DbContextBase<T> : DbContext, IUnitOfWork where T : DbContextBase<T>
{
    private readonly IMediator _mediator;
    public readonly IIntegrationEventMapper EventMapper;

    protected DbContextBase(DbContextOptions<T> options,
        IMediator mediator,
        IIntegrationEventMapper eventMapper) : base(options)
    {
        _mediator = mediator;
        EventMapper = eventMapper;
    }

    public DbSet<OutboxIntegrationEvent> OutboxIntegrationEvents { get; set; }

    // ...
}
</code></pre>
Each subdomain must implement its own IntegrationEventMapperclass which knows how to map its events. 
Not all Domain Events will result in an Integration Event, the default mapping will return null. 
The following shows how the mapping has been configured for the Ordering subdomain.

<pre><code>
namespace DDDMart.Ordering.Application.Services
{
    public class OrderingIntegrationEventMapper : IntegrationEventMapper, IOrderingIntegrationEventMapper
    {
        protected override IntegrationEvent MapDomainEvent<T>(T domainEvent)
        {
            return domainEvent switch
            {
                OrderSubmittedDomainEvent @event => new OrderSubmittedIntegrationEvent(@event.Id, @event.CustomerId, @event.PaymentMethodId, @event.PaymentAddress.Street, @event.PaymentAddress.City, @event.PaymentAddress.State, @event.PaymentAddress.Country, @event.PaymentAddress.ZipCode, @event.TotalPrice),
                OrderCancelledDomainEvent @event => new OrderCancelledIntegrationEvent(@event.Id, @event.CustomerId),
                { } => null
            };
        }
    }
}
</code></pre>
The Integration Events are mapped and persisted after the Domain Events have been handled.

<pre><code>
internal static class MediatorExtensions
{
    public static async Task DispatchEventsAsync<T>(this IMediator mediator, DbContextBase<T> context) where T : DbContextBase<T>
    {
        // ...

        await mediator.DispatchDomainEventsAsync(domainEvents);
        await DispatchIntegrationEventsAsync(domainEvents, context);

        ClearDomainEvents(aggregateRoots);
    }

    // ...

    private static async Task DispatchIntegrationEventsAsync<T>(IEnumerable<DomainEvent> domainEvents, DbContextBase<T> context) where T : DbContextBase<T>
    {
        var integrationEvents = context.EventMapper.Map(domainEvents);
        if (integrationEvents != null)
        {
            await context.OutboxIntegrationEvents.AddRangeAsync(integrationEvents);
        }
    }
}
</pre></code>
<h3>Publishing Integration Events from the Outbox</h3>
A separate Integration Event Publisher service is required for each sub-domain. 
The service periodically reads the events from the Outbox table, serializes them,and publishes them to the Event Bus. 
Generally, in a real application, each publisher would be hosted in a separate process.

<pre><code>
public class IntegrationEventPublisher<T> : BackgroundService where T : DbContextBase<T>
{
    private readonly IEventBus _eventBus;
    private readonly ILogger<IntegrationEventPublisher<T>> _logger;
    private const int TIMEOUT_SECONDS = 1;
    private readonly IServiceProvider _serviceProvider;

    public IntegrationEventPublisher(IEventBus eventBus,
        ILogger<IntegrationEventPublisher<T>> logger,
        IServiceProvider serviceProvider)
    {
        _eventBus = eventBus;
        _logger = logger;
        _serviceProvider = serviceProvider;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Checking for integration events every {timeout}s", TIMEOUT_SECONDS);
        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(TIMEOUT_SECONDS * 1000, stoppingToken);
            await PublishOutboxEventsAsync();               
        }
    }

    private async Task PublishOutboxEventsAsync()
    {
        using (var scope = _serviceProvider.CreateScope())
        {
            var context = scope.ServiceProvider.GetRequiredService<T>();
            try
            {
                var integrationEvents = context.OutboxIntegrationEvents.AsQueryable().ToList();

                if (integrationEvents.Any())
                {
                    _logger.LogInformation("Publishing {count} events from outbox", integrationEvents.Count);

                    foreach (var integrationEvent in integrationEvents)
                    {
                        await PublishIntegrationEventAsync(integrationEvent, context);
                    }
                    context.OutboxIntegrationEvents.RemoveRange(integrationEvents);
                    await context.CommitAsync();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error publishing outbox events - {ex}", ex.ToString());
            }
        }
    }

    private async Task PublishIntegrationEventAsync(OutboxIntegrationEvent integrationEvent, T context)
    {
        var @event = context.EventMapper.Factory.Create(integrationEvent);
        await _eventBus.PublishAsync(@event);
    }
}
</code></pre>
</div>
