<html>
    <head> 
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/nilx/assets/css/blocks.css">	
        <script src='/nilx/assets/js/blocks.js'></script>
    </head>
<body>
<button onclick="toggleAll(this);" >-</button>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Resources</h2>
<div>
    <a href='https://www.csharp-console-examples.com/basic/c-algorithms-examples/'>csharp-console-examples</a>
</div>
<h2>    
<input type="button" value="-"
class="toggleButton"  onclick="toggle(this)" />Time complexity</h2>
<div>
    - Time complexity represents the number of times a statement is executed.  
    - the “Big O notation”. The Big O notation is a language we use to describe the time complexity of an algorithm.
    - Big O notation: expresses the run time of an algorithm in terms of how quickly it grows relative to the input (this input is called “n”).
    - O(n) (Linear Time Complexity) :
        When time complexity grows in direct proportion to the size of the input, you are facing Linear Time Complexity, or O(n).
        Algorithms with this time complexity will process the input (n) in “n” number of operations. 
    - O(n²)   : If we say that the run time of an algorithm grows “on the order of the square of the size of the input”, 
                we would express it as “O(n²)”.for example sort algorithms.
    - O(1)    : When time complexity is constant (notated as “O(1)”), the size of the input (n) doesn’t matter.
    - O(log n):  time complexity of binary search is O(log n)
    - O(2^n)  :  Exponential Time Complexity:  brute force algo
    - O(1)constant: when only one operation is executed(for example printing "hello world!")
    - O(n log n),O(2^{n}), etc
</div>

<h2><input type="button" value="-" class="toggleButton"  onclick="toggle(this)" />HashTable = HashMap = Dictionary</h2>
<div>
<b>What is Hashing</b> 
It is the process of converting an object into an integer value. 
The integer value helps in indexing and faster searches.

<b>What is HashMap</b>
It store key-value items. 
So instead of storing just one value like the stack, array list and queue, the hash table stores 2 values. 
These 2 values form an element of the hash table:
<pre><code>
{ "001" , ".Net" }
{ "002" , ".C#" }
{ "003" , "ASP.Net" }   

//for example,In c#:
static void Main(string[] args)
{
 Hashtable ht = new Hashtable();
 ht.Add("001",".Net");
 ht.Add("002","C#");
 ht.Add("003","ASP.Net");

 ICollection keys = ht.Keys;

 foreach (String k in keys)
 {
  Console.WriteLine(ht[k]);
 }
  Console.ReadKey();
 }
}
</code></pre>

</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Stack</h2>
<div>
the principle of stack structure operation is LIFO (last in first out), the last element entered first out.
<pre><code>
    Stack myStack = new Stack();
    myStack.Push("Hello");
    myStack.Push("World");
    myStack.Push("!");
    foreach ( Object obj in myStack )
        Console.Write( "    {0}", obj );
    // !    World    Hello
</code></pre>
Stack applications:

    undo / redo functionality
    word reversal
    stack back/forward on browsers
    backtracking algorithms
    bracket verification
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Queue</h2>
<div>
the working principle of queue structures is FIFO (first in first out), the first element entered first out.
<pre><code>
Queue myQ = new Queue();
myQ.Enqueue("Hello");
myQ.Enqueue("World");
myQ.Enqueue("!");
foreach ( Object obj in myQ )
    Console.Write( "    {0}", obj );
//Hello    World    !
</code></pre>

</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />linked list</h2>
<div>
    each node in the list has a reference to the next node, except the tail of the list, which has no reference to the next node.
<pre><code>
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Binary Search</h2>
<div>
    we access the middle element and compare with the searched one
    if it is smaller repeats the recursive process for the first half, 
    otherwise it is searching in the second half, the binary.

    Binary search tree traversal:
Preorder

Root through
Go through the left subtree
Go through the right subtree
Inorder

Go through the left subtree
Root through
Go through the right subtree
Postorder

Go through the left subtree
Go through the right subtree
Root through
In the .NET Framework , the SortedList data structure uses internally a binary tree to keep the sorted elements.
<pre><code>
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Binary Search Tree</h2>
<div>
The idea is to have a node root, each node has at most two child nodes, 
the one on the left is smaller than the root, as well as the left subtree, 
the right node is larger than the root, so is the right subtree.
<pre><code>
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Graphs</h2>
<div>
The graphs are data structures characterized by nodes and edges joining the nodes, 
usually using the notation G = (V, E) where, V represents the set of nodes (vertices, vertices),
and E represents the set of edges (edges), in the programming language is represented by adjacency matrices for example
a [i, j] = k, this means that between node i and j we have an edge with weight k, and adjacent lists 
are also used for their representation.
<pre><code>
</code></pre>
</div>

<h2>ً<input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Quick sort</h2>
<div>
    It implements this strategy by choosing an element as a pivot and using it to partition the array.

    The left subarray contains all elements that are less than the pivot. The right subarray contains all the elements that are greater than the pivot. We recursively repeat this process until we sort the array. We can select the pivot the algorithm uses during this process in different ways:
    
    The first element of the array
    The last element of the array
    A random element of the array
    Median element of the array
    So, what is the best pivot to select when implementing the quicksort algorithm? The answer to this question is not that simple.
    
    Selecting the middle element of the unsorted array seems to make sense as it divides the array into equal halves. However, the process of finding that middle element is difficult and time-consuming. Using this strategy involves calculating the array’s length in every iteration and halving it to determine the index of the element in the middle of the array. 
    
    On the other hand, when using the median element of the array as the pivot, we use the median-of-three technique where we select the pivot based on the median of three values such as the first, middle, and last elements of the array. 
    
    Therefore, selecting the first, last, random, or median element of the array as the pivot is the best approach. 
<pre><code>
    public int[] SortArray(int[] array, int leftIndex, int rightIndex)
    {
        var i = leftIndex;
        var j = rightIndex;
        var pivot = array[leftIndex];
    
        while (i <= j)
        {
            while (array[i] < pivot)
            {
                i++;
            }
            
            while (array[j] > pivot)
            {
                j--;
            }
    
            if (i <= j)
            {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                i++;
                j--;
            }
        }
        
        if (leftIndex < j)
            SortArray(array, leftIndex, j);
    
        if (i < rightIndex)
            SortArray(array, i, rightIndex);
    
        return array;
    }
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Bubble Sort</h2>
<div>
<pre><code>
    public static void BubbleSort(int[] input)
    {
        var itemMoved = false;
        do
        {
            itemMoved = false;
            for (int i = 0; i < input.Count() - 1; i++)
            {
                if (input[i] > input[i + 1])
                {
                    var lowerValue = input[i + 1];
                    input[i + 1] = input[i];
                    input[i] = lowerValue;
                    itemMoved = true;
                }
            }
        } while (itemMoved);
    }
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Brute-Force Algorithm</h2>
<div>
<pre><code>
    using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace BruteForceAlgorithm
{
    class BruteForceAlgo
    {
 
        public delegate bool BruteForceTest(ref char[] testChars);
 
        public static bool BruteForce(string testChars, int startLength, int endLength, BruteForceTest testCallback)
        {
            for (int len = startLength; len <= endLength; ++len)
            {
                char[] chars = new char[len];
 
                for (int i = 0; i < len; ++i)
                    chars[i] = testChars[0];
 
                if (testCallback(ref chars))
                    return true;
 
                for (int i1 = len - 1; i1 > -1; --i1)
                {
                    int i2 = 0;
 
                    for (i2 = testChars.IndexOf(chars[i1]) + 1; i2 < testChars.Length; ++i2)
                    {
                        chars[i1] = testChars[i2];
 
                        if (testCallback(ref chars))
                            return true;
 
                        for (int i3 = i1 + 1; i3 < len; ++i3)
                        {
                            if (chars[i3] != testChars[testChars.Length - 1])
                            {
                                i1 = len;
                                goto outerBreak;
                            }
                        }
                    }
 
                outerBreak:
                    if (i2 == testChars.Length)
                        chars[i1] = testChars[0];
                }
            }
 
            return false;
        }
 
 
        static void Main(string[] args)
        {
            BruteForceTest testCallback = delegate(ref char[] testChars)
            {
                var str = new string(testChars);
                return (str == "bbc");
            };
 
 
            bool result = BruteForce("abcde", 1, 5, testCallback);
            Console.WriteLine(result);
        }
    }
}
 
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Bellman–Ford Algorithm for determining the shortest paths</h2>
<div>
<pre><code>
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Diagnostics;
     
    namespace BellmanFordAlgorithm
    {
        class BellmanFordAlgo
        {
            public struct Edge
            {
                public int Source;
                public int Destination;
                public int Weight;
            }
     
            public struct Graph
            {
                public int VerticesCount;
                public int EdgesCount;
                public Edge[] edge;
            }
     
            public static Graph CreateGraph(int verticesCount, int edgesCount)
            {
                Graph graph = new Graph();
                graph.VerticesCount = verticesCount;
                graph.EdgesCount = edgesCount;
                graph.edge = new Edge[graph.EdgesCount];
     
                return graph;
            }
     
            private static void Print(int[] distance, int count)
            {
                Console.WriteLine("Vertex   Distance from source");
     
                for (int i = 0; i < count; ++i)
                    Console.WriteLine("{0}\t {1}", i, distance[i]);
            }
     
            public static void BellmanFord(Graph graph, int source)
            {
                int verticesCount = graph.VerticesCount;
                int edgesCount = graph.EdgesCount;
                int[] distance = new int[verticesCount];
     
                for (int i = 0; i < verticesCount; i++)
                    distance[i] = int.MaxValue;
     
                distance[source] = 0;
     
                for (int i = 1; i <= verticesCount - 1; ++i)
                {
                    for (int j = 0; j < edgesCount; ++j)
                    {
                        int u = graph.edge[j].Source;
                        int v = graph.edge[j].Destination;
                        int weight = graph.edge[j].Weight;
     
                        if (distance[u] != int.MaxValue && distance[u] + weight < distance[v])
                            distance[v] = distance[u] + weight;
                    }
                }
     
                for (int i = 0; i < edgesCount; ++i)
                {
                    int u = graph.edge[i].Source;
                    int v = graph.edge[i].Destination;
                    int weight = graph.edge[i].Weight;
     
                    if (distance[u] != int.MaxValue && distance[u] + weight < distance[v])
                        Console.WriteLine("Graph contains negative weight cycle.");
                }
     
                Print(distance, verticesCount);
            }
     
            static void Main(string[] args)
            {
                int verticesCount = 5;
                int edgesCount = 8;
                Graph graph = CreateGraph(verticesCount, edgesCount);
     
                // Edge 0-1
                graph.edge[0].Source = 0;
                graph.edge[0].Destination = 1;
                graph.edge[0].Weight = -1;
     
                // Edge 0-2
                graph.edge[1].Source = 0;
                graph.edge[1].Destination = 2;
                graph.edge[1].Weight = 4;
     
                // Edge 1-2
                graph.edge[2].Source = 1;
                graph.edge[2].Destination = 2;
                graph.edge[2].Weight = 3;
     
                // Edge 1-3
                graph.edge[3].Source = 1;
                graph.edge[3].Destination = 3;
                graph.edge[3].Weight = 2;
     
                // Edge 1-4
                graph.edge[4].Source = 1;
                graph.edge[4].Destination = 4;
                graph.edge[4].Weight = 2;
     
                // Edge 3-2
                graph.edge[5].Source = 3;
                graph.edge[5].Destination = 2;
                graph.edge[5].Weight = 5;
     
                // Edge 3-1
                graph.edge[6].Source = 3;
                graph.edge[6].Destination = 1;
                graph.edge[6].Weight = 1;
     
                // Edge 4-3
                graph.edge[7].Source = 4;
                graph.edge[7].Destination = 3;
                graph.edge[7].Weight = -3;
     
                BellmanFord(graph, 0);
            }
        }
    }
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Breadth First Search (BFS) using Queue</h2>
<div>
    Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. 
    It starts at the tree root (or some arbitrary node of a graph) and explores the neighbor nodes first, 
    before moving to the next level neighbors.


<pre><code>
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
     
    namespace BreadthFirst
    {
        class Program
        {
            public class Employee
            {
                public Employee(string name)
                {
                    this.name = name;
                }
     
                public string name { get; set; }
                public List<Employee> Employees
                {
                    get
                    {
                        return EmployeesList;
                    }
                }
     
                public void isEmployeeOf(Employee p)
                {
                    EmployeesList.Add(p);
                }
     
                List<Employee> EmployeesList = new List<Employee>();
     
                public override string ToString()
                {
                    return name;
                }
            }
     
            public class BreadthFirstAlgorithm
            {
                public Employee BuildEmployeeGraph()
                {
                    Employee Eva = new Employee("Eva");
                    Employee Sophia = new Employee("Sophia");
                    Employee Brian = new Employee("Brian");
                    Eva.isEmployeeOf(Sophia);
                    Eva.isEmployeeOf(Brian);
     
                    Employee Lisa = new Employee("Lisa");
                    Employee Tina = new Employee("Tina");
                    Employee John = new Employee("John");
                    Employee Mike = new Employee("Mike");
                    Sophia.isEmployeeOf(Lisa);
                    Sophia.isEmployeeOf(John);
                    Brian.isEmployeeOf(Tina);
                    Brian.isEmployeeOf(Mike);
     
                    return Eva;
                }
     
                public Employee Search(Employee root, string nameToSearchFor)
                {
                    Queue<Employee> Q = new Queue<Employee>();
                    HashSet<Employee> S = new HashSet<Employee>();
                    Q.Enqueue(root);
                    S.Add(root);
     
                    while (Q.Count > 0)
                    {
                        Employee e = Q.Dequeue();
                        if (e.name == nameToSearchFor)
                            return e;
                        foreach (Employee friend in e.Employees)
                        {
                            if (!S.Contains(friend))
                            {
                                Q.Enqueue(friend);
                                S.Add(friend);
                            }
                        }
                    }
                    return null;
                }
     
                public void Traverse(Employee root)
                {
                    Queue<Employee> traverseOrder = new Queue<Employee>();
     
                    Queue<Employee> Q = new Queue<Employee>();
                    HashSet<Employee> S = new HashSet<Employee>();
                    Q.Enqueue(root);
                    S.Add(root);
     
                    while (Q.Count > 0)
                    {
                        Employee e = Q.Dequeue();
                        traverseOrder.Enqueue(e);
     
                        foreach (Employee emp in e.Employees)
                        {
                            if (!S.Contains(emp))
                            {
                                Q.Enqueue(emp);
                                S.Add(emp);
                            }
                        }
                    }
     
                    while (traverseOrder.Count > 0)
                    {
                        Employee e = traverseOrder.Dequeue();
                        Console.WriteLine(e);
                    }
                }
            }
     
            static void Main(string[] args)
            {
                BreadthFirstAlgorithm b = new BreadthFirstAlgorithm();
                Employee root = b.BuildEmployeeGraph();
                Console.WriteLine("Traverse Graph\n------");
                b.Traverse(root);
     
                Console.WriteLine("\nSearch in Graph\n------");
                Employee e = b.Search(root, "Eva");
                Console.WriteLine(e == null ? "Employee not found" : e.name);
                e = b.Search(root, "Brian");
                Console.WriteLine(e == null ? "Employee not found" : e.name);
                e = b.Search(root, "Soni");
                Console.WriteLine(e == null ? "Employee not found" : e.name);
            }
        }
    }
     
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Depth First Seach (DFS) using List</h2>
<div>
    Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root
    (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.
<pre><code>
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
     
    namespace DefthFirst
    {
        class Program
        {
            public class Employee
            {
                public Employee(string name)
                {
                    this.name = name;
                }
     
                public string name { get; set; }
                public List<Employee> Employees
                {
                    get
                    {
                        return EmployeesList;
                    }
                }
     
                public void isEmployeeOf(Employee e)
                {
                    EmployeesList.Add(e);
                }
     
                List<Employee> EmployeesList = new List<Employee>();
     
                public override string ToString()
                {
                    return name;
                }
            }
     
            public class DepthFirstAlgorithm
            {
                public Employee BuildEmployeeGraph()
                {
                    Employee Eva = new Employee("Eva");
                    Employee Sophia = new Employee("Sophia");
                    Employee Brian = new Employee("Brian");
                    Eva.isEmployeeOf(Sophia);
                    Eva.isEmployeeOf(Brian);
     
                    Employee Lisa = new Employee("Lisa");
                    Employee Tina = new Employee("Tina");
                    Employee John = new Employee("John");
                    Employee Mike = new Employee("Mike");
                    Sophia.isEmployeeOf(Lisa);
                    Sophia.isEmployeeOf(John);
                    Brian.isEmployeeOf(Tina);
                    Brian.isEmployeeOf(Mike);
     
                    return Eva;
                }
     
                public Employee Search(Employee root, string nameToSearchFor)
                {
                    if (nameToSearchFor == root.name)
                        return root;
     
                    Employee personFound = null;
                    for (int i = 0; i < root.Employees.Count; i++)
                    {
                        personFound = Search(root.Employees[i], nameToSearchFor);
                        if (personFound != null)
                            break;
                    }
                    return personFound;
                }
     
                public void Traverse(Employee root)
                {
                    Console.WriteLine(root.name);
                    for (int i = 0; i < root.Employees.Count; i++)
                    {
                        Traverse(root.Employees[i]);
                    }
                }
            }
     
            static void Main(string[] args)
            {
                DepthFirstAlgorithm b = new DepthFirstAlgorithm();
                Employee root = b.BuildEmployeeGraph();
                Console.WriteLine("Traverse Graph\n------");
                b.Traverse(root);
     
                Console.WriteLine("\nSearch in Graph\n------");
                Employee e = b.Search(root, "Eva");
                Console.WriteLine(e == null ? "Employee not found" : e.name);
                e = b.Search(root, "Brian");
                Console.WriteLine(e == null ? "Employee not found" : e.name);
                e = b.Search(root, "Soni");
                Console.WriteLine(e == null ? "Employee not found" : e.name);
            }
        }
    }
     
</code></pre>
</div>

<h2><input type="button" value="-"
    class="toggleButton"  onclick="toggle(this)" />Huffman coding using Dictionary</h2>
<div>
    Huffman coding is a lossless data compression algorithm. The idea is to assign variable-legth codes to input characters, lengths of the assigned codes are based on the frequencies of corresponding characters.
     The most frequent character gets the smallest code and the least frequent character gets the largest code.
Node.cs :
<pre><code>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace HuffmanTest
{
    public class Node
    {
        public char Symbol { get; set; }
        public int Frequency { get; set; }
        public Node Right { get; set; }
        public Node Left { get; set; }
 
        public List<bool> Traverse(char symbol, List<bool> data)
        {
            // Leaf
            if (Right == null && Left == null)
            {
                if (symbol.Equals(this.Symbol))
                {
                    return data;
                }
                else
                {
                    return null;
                }
            }
            else
            {
                List<bool> left = null;
                List<bool> right = null;
 
                if (Left != null)
                {
                    List<bool> leftPath = new List<bool>();
                    leftPath.AddRange(data);
                    leftPath.Add(false);
 
                    left = Left.Traverse(symbol, leftPath);
                }
 
                if (Right != null)
                {
                    List<bool> rightPath = new List<bool>();
                    rightPath.AddRange(data);
                    rightPath.Add(true);
                    right = Right.Traverse(symbol, rightPath);
                }
 
                if (left != null)
                {
                    return left;
                }
                else
                {
                    return right;
                }
            }
        }
    }
}
 
</code></pre>
HuffmanTree.cs :
<pre><code> 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;
 
namespace HuffmanTest
{
    public class HuffmanTree
    {
        private List<Node> nodes = new List<Node>();
        public Node Root { get; set; }
        public Dictionary<char, int> Frequencies = new Dictionary<char, int>();
 
        public void Build(string source)
        {
            for (int i = 0; i < source.Length; i++)
            {
                if (!Frequencies.ContainsKey(source[i]))
                {
                    Frequencies.Add(source[i], 0);
                }
 
                Frequencies[source[i]]++;
            }
 
            foreach (KeyValuePair<char, int> symbol in Frequencies)
            {
                nodes.Add(new Node() { Symbol = symbol.Key, Frequency = symbol.Value });
            }
 
            while (nodes.Count > 1)
            {
                List<Node> orderedNodes = nodes.OrderBy(node => node.Frequency).ToList<Node>();
 
                if (orderedNodes.Count >= 2)
                {
                    // Take first two items
                    List<Node> taken = orderedNodes.Take(2).ToList<Node>();
 
                    // Create a parent node by combining the frequencies
                    Node parent = new Node()
                    {
                        Symbol = '*',
                        Frequency = taken[0].Frequency + taken[1].Frequency,
                        Left = taken[0],
                        Right = taken[1]
                    };
 
                    nodes.Remove(taken[0]);
                    nodes.Remove(taken[1]);
                    nodes.Add(parent);
                }
 
                this.Root = nodes.FirstOrDefault();
 
            }
 
        }
 
        public BitArray Encode(string source)
        {
            List<bool> encodedSource = new List<bool>();
 
            for (int i = 0; i < source.Length; i++)
            {
                List<bool> encodedSymbol = this.Root.Traverse(source[i], new List<bool>());
                encodedSource.AddRange(encodedSymbol);
            }
 
            BitArray bits = new BitArray(encodedSource.ToArray());
 
            return bits;
        }
 
        public string Decode(BitArray bits)
        {
            Node current = this.Root;
            string decoded = "";
 
            foreach (bool bit in bits)
            {
                if (bit)
                {
                    if (current.Right != null)
                    {
                        current = current.Right;
                    }
                }
                else
                {
                    if (current.Left != null)
                    {
                        current = current.Left;
                    }
                }
 
                if (IsLeaf(current))
                {
                    decoded += current.Symbol;
                    current = this.Root;
                }
            }
 
            return decoded;
        }
 
        public bool IsLeaf(Node node)
        {
            return (node.Left == null && node.Right == null);
        }
 
    }
}
 
</code></pre>
Program to test Huffman Coding:
<pre><code>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;
 
namespace HuffmanTest
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Please enter the string:");
            string input = Console.ReadLine();
            HuffmanTree huffmanTree = new HuffmanTree();
 
            // Build the Huffman tree
            huffmanTree.Build(input);
 
            // Encode
            BitArray encoded = huffmanTree.Encode(input);
 
            Console.Write("Encoded: ");
            foreach (bool bit in encoded)
            {
                Console.Write((bit ? 1 : 0) + "");
            }
            Console.WriteLine();
 
            // Decode
            string decoded = huffmanTree.Decode(encoded);
 
            Console.WriteLine("Decoded: " + decoded);
 
            Console.ReadLine();
        }
    }
}
</code></pre>

 

</div>
