<html  lang="fa-IR">
<head >	
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link rel="stylesheet" href="..\..\editing.css">		
</head>
<body>
<div>
<h2>Multidimensional Arrays</h2>
    <code>
	int[, , , ,] arr5d; // five-dimensional array

    int[,] arr2d = new int[3,2]{    {1, 2},  {3, 4}, {5, 6}   };
    // or 
    int[,] arr2d = {     {1, 2},   {3, 4},  {5, 6}    };
    </code>
<h2>Jagged Arrays: An Array of Array</h2>
    <code>
    int[][] jArray = new int[2][]; 

    jArray[0] = new int[3]{1, 2, 3};

    jArray[1] = new int[4]{4, 5, 6, 7 };
    </code>
<h2>Indexers</h2>
    An indexer is a special type of property that allows a class or a structure to be accessed like an array for its internal collection
    Example:
    <code>
        class StringDataStore
        {
            private string[] strArr = new string[10]; // internal data storage

            public string this[int index]
            {
                get
                {
                    if (index < 0 || index >= strArr.Length)
                        throw new IndexOutOfRangeException("Index out of range");

                        return strArr[index];
                }

                set
                {
                    if (index < 0 ||  index >= strArr.Length)
                        throw new IndexOutOfRangeException("Index out of range");

                    strArr[index] = value;
                }
            }
        }
    </code>
<h2>Generics</h2>
    Generic means the general form, not specific. In C#, generic means not specific to a particular data type.
    Example of definition:
    <code>
        class DataStore<T>
        {
            public T Data { get; set; } //generic field of the generic class
            public T GetData(int index){...} //generic method (which returns generic class).
            //(generic methods can also be defined in a none-generic class)
        }
    </code>
    The DataStore is a generic class. 
    
    T is called type parameter, which can be used as a type of fields, properties, method parameters, return types, and delegates in the DataStore class. 
    You can also define multiple type parameters separated by a comma.
    <b>Instanciation:</b>You can create an instance of generic classes by specifying an actual type in angle brackets:
        DataStore<string> store = new DataStore<string>();

<h2>C# Generic Constraints</h2>

    C# allows you to use constraints to restrict client code to specify certain types while instantiating generic types. 
    It will give a compile-time error if you try to instantiate a generic type using a type that is not allowed by the specified constraints.

    There are six types of constraints.

        where T : struct  - Type argument must be a value type
        where T : class - Type argument must be a reference type
        where T : new() - Type argument must have a public parameterless constructor.
        where T : <base class> - Type argument must inherit from <base class> class.
        where T : <interface> -  Type argument must implement from <interface> interface.
        where T : U - There are two type arguments T and U. T must be inherit from U.

    <a href='https://www.tutorialsteacher.com/csharp/constraints-in-generic-csharp'>more..</a>
<h2>multicast delegates</h2>

     multicasting is the ability to create an invocation list, or chain, of methods that will be automatically called when a delegate is invoked.
    A delegate instance can reference not just a single target method, but also a list of target methods.
    As a result, one delegate instance can call many methods. It is called multicast.
    All delegate instances have multicast capability.

    Example:
    <code>
        // All delegate instances have multicast capability:

        SomeDelegate d = SomeMethod1;
        d += SomeMethod2;

        d();
        " -- SomeMethod1 and SomeMethod2 both fired\r\n".Dump();

        d -= SomeMethod1;
        d();
        " -- Only SomeMethod2 fired".Dump();

        void SomeMethod1 () => "SomeMethod1".Dump();
        void SomeMethod2 () => "SomeMethod2".Dump();

        delegate void SomeDelegate();
    </code>
    <h2>yield return</h2>
        if you want a collection that you can use "foreach" on, but gathering the items into the collection is expensive for some reason 
        (like querying them out of a database), AND you will often not need the entire collection, 
        then you create a function that builds the collection one item at a time and yields it back to the consumer
        (who can then terminate the collection effort early).

        t first sight, yield return is a .NET sugar to return an IEnumerable.

        Without yield, all the items of the collection are created at once:
        <code>
        class SomeData
        {
            public SomeData() { }

            static public IEnumerable<SomeData> CreateSomeDatas()
            {
                return new List<SomeData> {
                    new SomeData(), 
                    new SomeData(), 
                    new SomeData()
                };
            }
        }
    </code>
        Same code using yield, it returns item by item:
        <code>
        class SomeData
        {
            public SomeData() { }

            static public IEnumerable<SomeData> CreateSomeDatas()
            {
                yield return new SomeData();
                yield return new SomeData();
                yield return new SomeData();
            }
        }
    </code>
        The advantage of using yield is that if the function consuming your data simply needs the first item of the collection, the rest of the items won't be created.

        The yield operator allows the creation of items as it is demanded. That's a good reason to use it.
<h2>yield break</h2>
    <code>
    // The yield break statement indicates that the iterator block should exit early,
    // without returning more elements:

    foreach (string s in Foo (true))
    Console.WriteLine (s);

    static IEnumerable<string> Foo (bool breakEarly)
    {
        yield return "One";
        yield return "Two";

        if (breakEarly)
            yield break;

        yield return "Three";
    }
</code>
<h2>Access modifiers</h2>
<code>
class Class1 {}         // Class1 is <b>internal</b> (default) - visible to other types in same assembly
public class Class2 {}  // Class2 is visible to everything, including types in other assemblies

class ClassA
{
  int x;               // x is private <b>(default)</b> - cannot be accessed from other types
}

class ClassB
{
  internal int x;    // x can be accessed from other types in same assembly
}

class BaseClass
{
  void Foo()           {}    // Foo is private (default)
  protected void Bar() {}    // <b>protected</b> is accessible to subclasses
}

class Subclass : BaseClass
{
   void Test1() { Foo(); }     // Error - cannot access Foo
   void Test2() { Bar(); }     // OK
}
Friend Assemblies

// Unsigned friend:
//    [assembly: InternalsVisibleTo ("Friend")]

// Signed friend:
//    [assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]

// To obtain an assembly's public key, hit F5 to run the following code:

using (var dialog = new OpenFileDialog())
{
  dialog.Title = "Locate assembly";
  dialog.Filter = "Assembly files|*.dll;*.exe";
  dialog.DefaultExt = ".dll";
  
  if (dialog.ShowDialog() != DialogResult.OK) return;
  if (!File.Exists (dialog.FileName)) return;
  
  var aName = Assembly.LoadFile (dialog.FileName).GetName();

  string key = string.Join ("", 
    aName.GetPublicKey().Select (b => b.ToString ("x2")).ToArray());
    
  string assemAttrib = "[assembly: InternalsVisibleTo (\"" 
    + aName.Name
    + ", PublicKey=" + key.Dump ("Full Key")
    + "\")]";
    
  assemAttrib.Dump ("Assembly Attribute");
  
  Clipboard.SetText (assemAttrib);
}


</code>
<h2>Inheritence</h2>
<b>What is difference between virtual and override in C#?</b>

The virtual keyword is used to modify a method, property, indexer, or event declared in the base class 
and allow it to be overridden in the derived class.
The override keyword is used to extend or modify a virtual/abstract method, property, indexer, or event of base class into a derived class.

<b>Polymorphism</b>:
<code>
    // A variable of type x can refer to an object that subclasses x.

    // The Display method below accepts an Asset. This means means we can pass it any subtype:
    Display (new Stock { Name="MSFT", SharesOwned=1000 });
    Display (new House { Name="Mansion", Mortgage=100000 });

    void Display (Asset asset)
    {
    Console.WriteLine (asset.Name);
    }

    public class Asset
    {
    public string Name;
    }

    public class Stock : Asset   // inherits from Asset
    {
    public long SharesOwned;
    }

    public class House : Asset   // inherits from Asset
    {
    public decimal Mortgage;
    }
</code>
<b>Reference Conversions - Upcasting</b>
<code>
// An upcast creates a base class reference from a subclass reference:

Stock msft = new Stock();
Asset a = msft;               // Upcast

// After the upcast, the two variables still references the same Stock object:

Console.WriteLine (a == msft);  // True

public class Asset
{
  public string Name;
}

public class Stock : Asset   // inherits from Asset
{
  public long SharesOwned;
}

public class House : Asset   // inherits from Asset
{
  public decimal Mortgage;
}
</code>
<b>Virtual Function Members</b>
<code>
// A function marked as virtual can be overridden by subclasses wanting to provide a
// specialized implementation:

House mansion = new House { Name="McMansion", Mortgage=250000 };
Console.WriteLine (mansion.Liability);      // 250000

public class Asset
{
  public string Name;
  public virtual decimal Liability => 0;    // Virtual
}

public class House : Asset
{
  public decimal Mortgage;
  public override decimal Liability => Mortgage;   // Overridden
}

public class Stock : Asset
{
  public long SharesOwned;
  // We won't override Liability here, because the default implementation will do.
}
</code>
</div>
<b><Covariant returns/b>

 From C# 9, we can override a method such that it returns a more derived (subclased) type:
<code>
House mansion1 = new House { Name = "McMansion", Mortgage = 250000 };
House mansion2 = mansion1.Clone();

public class Asset
{
  public string Name;
  public virtual Asset Clone() => new Asset { Name = Name };
}

public class House : Asset
{
  public decimal Mortgage;
  
  // We can return House when overriding:
  public override House Clone() => new House { Name = Name, Mortgage = Mortgage };
}
</code>
<b>Abstract Classes & Members</b>

 A class declared as abstract can never be instantiated. Instead, only its concrete subclasses
 can be instantiated. Abstract classes are able to define abstract members.
<code>
new Stock { SharesOwned = 200, CurrentPrice = 123.45M }.NetValue.Dump();

public abstract class Asset    // Note abstract keyword
{
  public abstract decimal NetValue { get; }  // Note empty implementation
}

public class Stock : Asset
{
  public long SharesOwned;
  public decimal CurrentPrice;

  // Override like a virtual method.
  public override decimal NetValue => CurrentPrice * SharesOwned; 
}
</code>
<b>Sealing Functions & Classes</b>
 An overridden function member may seal its implementation with the sealed keyword to prevent it
 from being overridden by further subclasses:
<code>
    
House mansion = new House { Name="McMansion", Mortgage=250000 };
Console.WriteLine (mansion.Liability);      // 250000

public class Asset
{
  public string Name;
  public virtual decimal Liability => 0;    // Virtual
}

public class House : Asset
{
  public decimal Mortgage;
  public sealed override decimal Liability => Mortgage;   // Overridden + sealed
}

// You can also seal the class itself, implicitly sealing all the virtual functions:

public sealed class Stock : Asset { /* ... */ }
</code>
<b>Overloading and Resolution</b>
 When calling an overload method, the method with the most specific 
 parameter type match has precedence, based on the *compile-time* variable type:
<code>
void Main()
{
  Foo (new House());      // Calls Foo (House)
  
  Asset a = new House();
  Foo (a);                // Calls Foo (Asset)
}

static void Foo (Asset a) { "Foo Asset".Dump(); }
static void Foo (House h) { "Foo House".Dump(); }

public class Asset
{
  public string Name;
}

public class Stock : Asset   // inherits from Asset
{
  public long SharesOwned;
}

public class House : Asset   // inherits from Asset
{
  public decimal Mortgage;
}
</code>
<h2>Boxing & Unboxing</h2>
 Boxing is the act of casting a value-type instance to a reference-type instance; unboxing is the reverse.
 <code>
    int x = 9;
    object obj = x;           // Box the int
    int y = (int)obj;         // Unbox the int    
 </code>
</body>
</html>