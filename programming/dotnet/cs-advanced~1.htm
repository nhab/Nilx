<head<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/nilx/assets/css/blocks.css">
<script src='/nilx/assets/js/blocks.js'></script>
<link rel="stylesheet" href="/nilx/libs/highlight/androidstudio2.css">
<!--https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/androidstudio.min.css"-->
<!--github-dark.min.css-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"
  integrity="sha512-9ia7twbVj1OAzFDTFTzf/x2LrAc/Hf1KlzHTbyxfJZXA+YQP2eXOFWr7E3ZZ6SgtAZZza2PDXvcQjXQ5nZ9GAw=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>

<body onload="AddToggleButtons()">
  <button onclick="toggleAll(this);">-</button>
  <h2>Resources</h2>
  <div>
    <a href='https://learn.microsoft.com/en-us/dotnet/csharp/'>Microsoft C# Reference and other resources</a>
    <a href='https://www.tutorialsteacher.com/csharp/csharp-generics'>generics</a>
    <a href='https://www.albahari.com/nutshell/code.aspx'>in a nutshell</a>
  </div>
  <h2>Extension Method Chaining</h2>
  <div>
      Extension methods, like instance methods, provide a tidy way to chain functions:
  <pre><code>
string x = "sausage".Pluralize().Capitalize();
x.Dump();

// Equivalent to:
string y = StringHelper.Capitalize (StringHelper.Pluralize ("sausage"));
y.Dump();

// LINQPad's Dump method is an extension method:
"sausage".Pluralize().Capitalize().Dump();

public static class StringHelper
{
  public static string Pluralize (this string s) => s + "s";   // Very naiive implementation!

  public static string Capitalize (this string s) => s.ToUpper();
}
</code></pre>    
  </div>  
  <h2>Anonymous Types</h2>
  <div>
An anonymous type is a simple class created by the compiler on the fly to store a set of values
<code>
var dude = new { Name = "Bob", Age = 23 };

//Anonymous Types - with keyword

    var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
    var a2 = a1 with { E = 10 };
    a2.Dump();
</code>    
  </div>
 <h2>Record</h2>
 <div>
 new in C# 9.0
- defines a reference type that provides built-in functionality for encapsulating data.
Defining a record
<pre><code>
new Point (2, 3).Dump();

// Run the line below to look at Point in ILSpy.
// Util.OpenILSpy (typeof (Point));

record Point
{
  public Point (double x, double y) => (X, Y) = (x, y);

  public double X { get; init; }
  public double Y { get; init; }    
}
</code></pre>
- Record types have a compiler-generated ToString method 
that displays the names and values of public properties and fields.
- A record can inherit from another record.
  However, a record can't inherit from a class, and a class can't inherit from a record.
- For two record variables to be equal, the run-time type must be equal. 
The types of the containing variables might be different.
<b>Dynamic Type</b>
is to avoid compile-time type checking.
The dynamic type changes its type at the run time based on the value present on the right-hand side
<pre><code>
    dynamic value = 123;
</code></pre>
 </div>
<h2>Unsafe code (using pointers)</h2>
<div>
<pre><code>
//    Unsafe Code

// C# supports direct memory manipulation via pointers within blocks of code marked unsafe
// and compiled with the /unsafe compiler option. LINQPad implicitly compiles with this option.

// Here's how to use pointers to quickly process a bitmap:

int [,] bitmap = { { 0x101010, 0x808080, 0xFFFFFF }, { 0x101010, 0x808080, 0xFFFFFF } };
BlueFilter (bitmap);
bitmap.Dump();

unsafe static void BlueFilter (int [,] bitmap)
{
  int length = bitmap.Length;
  fixed (int* b = bitmap)
  {
    int* p = b;
    for (int i = 0; i < length; i++)
      *p++ &= 0xFF;
  }
}
</code></pre>
</div>
<h2>Regx Parsing</h2>
<div>
Pattern The string pattern that has to be used for the lookup. 
The common options in here are Singleline and Multiline. They are changing the
behaviour of pattern-elements like the dot (.) which won't cover a NewLine (\n) in
Multiline-Mode but in SingleLine-Mode. Default behaviour: msdn
Timeout [Optional] Where patterns are getting more complex the lookup can consume more time.
 This is the
passed timeout for the lookup just as known from network-programming.
<b>Single match</b>
<pre><code>
 using System.Text.RegularExpressions;
string pattern = ":(.*?):";
string lookup = "--:text in here:--";
// Instanciate your regex object and pass a pattern to it
Regex rgxLookup = new Regex(pattern, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
// Get the match from your regex-object
Match mLookup = rgxLookup.Match(lookup);
// The group-index 0 always covers the full pattern.
// Matches inside parentheses will be accessed through the index 1 and above.
string found = mLookup.Groups[1].Value;
Result:
found = "text in here" 
</code></pre>
    <b>Multiple matches</b>
    <pre><code>
  using System.Text.RegularExpressions;
  List<string> found = new List<string>();
  string pattern = ":(.*?):";
  string lookup = "--:text in here:--:another one:-:third one:---!123:fourth:";
  // Instanciate your regex object and pass a pattern to it
  Regex rgxLookup = new Regex(pattern, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
  MatchCollection mLookup = rgxLookup.Matches(lookup);
  foreach(Match match in mLookup)
  {
  found.Add(match.Groups[1].Value);
  }
  Result:
  found = new List<string>() { "text in here", "another one", "third one", "fourth" }  
</code></pre>

  </div>

<h2>ToString()</h2>
  <div>
    The ToString() method is present on all reference object types.
    This is due to all reference types being derived from Object which has the ToString() method on it.
    The ToString() method on the object base class returns the type name.
    The fragment below will print out "User" to the console.
    <pre><code>
public class User
{
public string Name { get; set; }
public int Id { get; set; }
}
...
var user = new User {Name = "User1", Id = 5};
Console.WriteLine(user.ToString());

//However, the class User can also override ToString() in order to alter the string it returns. 
//The code fragment below prints out "Id: 5, Name: User1" to the console.
public class User
  {
  public string Name { get; set; }
  public int Id { get; set; }
  public override ToString()
  {
    return string.Format("Id: {0}, Name: {1}", Id, Name);
  }
}
...
var user = new User {Name = "User1", Id = 5};
Console.WriteLine(user.ToString());

string outsidetext = "I am outside of bracket";
string.Format("{{I am in brackets!}} {0}", outsidetext);
//Outputs "{I am in brackets!} I am outside of bracket"
</code></pre>
</div>
<h2>Formatting</h2>
  <div>
    <b>Numeric formats</b>
    <pre><code>
  // Integral types as hex
  string.Format("Hexadecimal: byte2: {0:x2}; byte4: {0:X4}; char: {1:x2}", 123, (int)'A');
  // Integers with thousand separators
  string.Format("Integer, thousand sep.: {0:#,#}; fixed length: >{0,10:#,#}<", 1234567);
  // Integer with leading zeroes
  string.Format("Integer, leading zeroes: {0:00}; ", 1);
  // Decimals
  string.Format("Decimal, fixed precision: {0:0.000}; as percents: {0:0.00%}", 0.12);
  Output:
  Hexadecimal: byte2: 7b; byte4: 007B; char: 41
  Integer, thousand sep.: 1,234,567; fixed length: > 1,234,567<
  Integer, leading zeroes: 01;
  Decimal, fixed precision: 0.120; as percents: 12.00%
</code></pre>
    <b>custom number format</b>
    <pre><code>
  // invariantResult is "1,234,567.89"
  var invarianResult = string.Format(CultureInfo.InvariantCulture, "{0:#,###,##}", 1234567.89);
  // NumberFormatInfo is one of classes that implement IFormatProvider
  var customProvider = new NumberFormatInfo
  {
  NumberDecimalSeparator = "_NS_", // will be used instead of ','
  NumberGroupSeparator = "_GS_", // will be used instead of '.'
  };
  // customResult is "1_GS_234_GS_567_NS_89"
  var customResult = string.Format(customProvider, "{0:#,###.##}", 1234567.89);  
</code></pre>
    <b>String formatting</b>
    <pre><code class="csharp">
// float with two decimal places
String.Format("{0:0.00}", 123.4567);      // "123.46"
String.Format("{0:0.00}", 123.4);         // "123.40"
String.Format("{0:0.00}", 123.0);         // "123.00"

//Since C# 6.0 it is possible to use string interpolation in place of String.Format.
string name = "John";
string lastname = "Doe";
Console.WriteLine($"Hello {name} {lastname}!");//Hello John Doe!

</code></pre>
    <b>Formatting using ToString</b>
    <pre><code>
 // Integer to formatted string:
  int intValue = 10;
  string zeroPaddedInteger = intValue.ToString("000"); // Output will be "010"
  string customFormat = intValue.ToString("Input value is 0"); // output will be "Input value is 10"
 // double to formatted string:
  double doubleValue = 10.456;
  string roundedDouble = doubleValue.ToString("0.00"); // output 10.46
  string integerPart = doubleValue.ToString("00"); // output 10
  string customFormat = doubleValue.ToString("Input value is 0.0"); // Input value is 10.5
 // Formatting DateTime using ToString
  DateTime currentDate = DateTime.Now; // {7/21/2016 7:23:15 PM}
  string dateTimeString = currentDate.ToString("dd-MM-yyyy HH:mm:ss"); // "21-07-2016 19:23:15"
  string dateOnlyString = currentDate.ToString("dd-MM-yyyy"); // "21-07-2016"
  string dateWithMonthInWords = currentDate.ToString("dd-MMMM-yyyy HH:mm:ss"); // "21-July-2016 19:23:15"
</code></pre>
    <b>Create a custom format provider</b>
    <pre><code>
  public class CustomFormat : IFormatProvider, ICustomFormatter
  {
    public string Format(string format, object arg, IFormatProvider formatProvider)
    {
      if (!this.Equals(formatProvider))
      {
        return null;
      }
      if (format == "Reverse")
      {
        return String.Join("", arg.ToString().Reverse());
      }
      return arg.ToString();
    }
    public object GetFormat(Type formatType)
    {
        return formatType==typeof(ICustomFormatter) ? this:null;
    }
  }
  //Usage:
    String.Format(new CustomFormat(), "-> {0:Reverse} <-", "Hello World");//Output:    -> dlroW olleH <-
</code></pre>
    <b>Format dates in strings</b>
    <pre><code>
  var date = new DateTime(2015, 11, 11);
  var str = $"It's {date:MMMM d, yyyy}, make a wish!";
  System.Console.WriteLine(str);
  
 // You can also use the DateTime.ToString method to format the DateTime object. This will produce the same output
 // as the code above.

  var date = new DateTime(2015, 11, 11);
  var str = date.ToString("MMMM d, yyyy");
  str = "It's " + str + ", make a wish!";
  Console.WriteLine(str);// Output:  It's November 11, 2015, make a wish!
</code></pre>
    <b>Align left/ right, pad with spaces</b>
    <pre><code>
  string.Format("LEFT: string: ->{0,-5}<- int: ->{1,-5}<-", "abc", 123);
  string.Format("RIGHT: string: ->{0,5}<- int: ->{1,5}<-", "abc", 123);
  Output:
  LEFT: string: ->abc <- int: ->123 <-
  RIGHT: string: -> abc<- int: -> 123<-  
</code></pre>
    <b>Padding with Format Specifiers</b>
    You can also use existing formatting specifiers in conjunction with padding.
    <pre><code>
var number = 42;
var str = $"The answer to life, the universe and everything is ${number, 5:f1}";
//str is "The answer to life, the universe and everything is 42.1 ";
//                                                           ^^^^^  
</code></pre>
</div>

<h2>Strings</h2>
  <div>
    <b>Expressions</b>
    <pre><code>
  var StrWithMathExpression = $"1 + 2 = {1 + 2}"; // -> "1 + 2 = 3"
  string world = "world";
  var StrWithFunctionCall = $"Hello, {world.ToUpper()}!"; // -> "Hello, WORLD!"
</code></pre>
    <b>Splitting a String by another string</b>
    <pre><code>
  string str = "this--is--a--complete--sentence";
  string[] tokens = str.Split(new[] { "--" }, StringSplitOptions.None);
 // Result:
//  [ "this", "is", "a", "complete", "sentence" ] 
</code></pre>
    <b>Splitting a String by specific character</b>
    <pre><code>
  string helloWorld = "hello world, how is it going?";
  string[] parts1 = helloWorld.Split(',');
  //parts1: ["hello world", " how is it going?"]
  string[] parts2 = helloWorld.Split(' ');
  //parts2: ["hello", "world,", "how", "is", "it", "going?"]
</code></pre>
    other things:
    <pre><code>
  string helloWorld = "Hello World!";

  string world = helloWorld.Substring(6); //world = "World!"
  string hello = helloWorld.Substring(0,5); // hello = "Hello"

  HelloWorld.StartsWith("Hello"); // true
  HelloWorld.StartsWith("Foo"); // false

  bool stringExists = s.Contains("ello"); //stringExists =true as the string contains the substring

  char c = s[1]; //Returns 'e'
</code></pre>
    <b>Joining an array of strings into a new one</b>
    <pre><code>
  var parts = new[] { "Foo", "Bar", "Fizz", "Buzz"};
  var joined = string.Join(", ", parts);
  //joined = "Foo, Bar, Fizz, Buzz" 
</code></pre>
<b>Replacing a string within a string</b>
<pre><code>
string s = "Hello World";

s = s.Replace("World", "Universe"); // s = "Hello Universe"  

//This method can also be used to remove part of a string, using the String.Empty field:
s = s.Replace("ell", String.Empty); // s = "Ho World"
</code></pre>
<b>Changing the case of characters within a String</b>
System.String.ToLowerInvariant is used to return a String object converted to lowercase.
System.String.ToUpperInvariant is used to return a String object converted to uppercase
<pre><code>
string s = "My String";
s = s.ToLowerInvariant(); // "my string"
s = s.ToUpperInvariant(); // "MY STRING"
</code></pre>
    <b>Concatenating </b>
    <pre><code>
  //an array of strings into a single
  string[] words = {"One", "Two", "Three", "Four"};
  string singleString = String.Join(",", words); // singleString = "One,Two,Three,Four"

//String Concatenation
string first = "Hello ";
string second = "World";
string concat = first + second; // concat = "Hello World"
concat = String.Concat(first, second); // concat = "Hello World"
In C# 6 this can be done as follows:
string concat = $"{first},{second}";
//Concat string array elements using String.Join
string[] value = {"apple", "orange", "grape", "pear"};
string separator = ", ";
string result = String.Join(separator, value, 1, 2);
Console.WriteLine(result);//Produces the following output: "orange, grape"
//=========================
//using $
var str1 = "text1";
var str2 = " ";
var str3 = "text3";
string result2 = $"{str1}{str2}{str3}"; //"text1 text3"
//=====================
StringBuilder sb = new StringBuilder();
for (int i = 1; i <= 5; i++)
{
sb.Append(i);
sb.Append(" ");
}
Console.WriteLine(sb.ToString()); // "1 2 3 4 5 "
Calls to Append() can be daisy chained, because it returns a reference to the StringBuilder:
StringBuilder sb = new StringBuilder();
sb.Append("some string ")
.Append("another string");

StringBuilder sb = new StringBuilder(10000); // initializes the capacity to 10000

//If we know in advance how long our StringBuilder needs to be, we can specify its size ahead of time, which will
//prevent it from needing to resize the character array it has internally.
sb.Append('k', 2000);
//Though using StringBuilder for appending is much faster than a string, it can run even faster if you only need to
//add a single character many times.

</code></pre>
    <b>Interpolated Verbatim Strings</b>
    Verbatim strings can be combined with the new String interpolation features found in C#6.
    <pre><code>
Console.WriteLine($@"Testing \n 1 2 {5 - 2}
New line");
//Output:
//Testing \n 1 2 3
//New line
</code></pre>
  As expected from a verbatim string, the backslashes are ignored as escape characters.
  And as expected from an interpolated string, any expression inside curly braces is evaluated
  before being inserted into the string at that position
  <b>Escaping </b>
  <pre><code>
//Double Quotes:
//Double Quotes inside verbatim strings can be escaped by using 2 sequential double quotes "" to represent one
//double quote " in the resulting string.  
var str = @"""I don't think so,"" he said.";
Console.WriteLine(str);
//Output:
//"I don't think so," he said. 

Backslash
// The filename will be c:\myfile.txt in both cases
string filename = "c:\\myfile.txt";
string filename = @"c:\myfile.txt";

Quotes
string text = "\"Hello World!\", said the quick brown fox.";         //"Hello World!", said the quick brown fox.
string verbatimText = @"""Hello World!"", said the quick brown fox.";//"Hello World!", said the quick brown fox.

Newlines
Verbatim string literals can contain newlines:
string text = "Hello\r\nWorld!";
string verbatimText = @"Hello
World!";

//Unicode character escape sequences
string sqrt = "\\u221A"; // √
string emoji = "\\U0001F601"; // ?
string text = "\\u0022Hello World\\u0022"; // "Hello World"
string variableWidth = "\\x22Hello World\\x22"; // "Hello World"

//Escaping special symbols in character literals
//Apostrophes
char apostrophe = '\'';

//Backslash
char oneBackslash = '\\';

</code></pre>
    <b>Padding a string to a fixed length</b>
    <pre><code>
 string s = "Foo";
string paddedLeft = s.PadLeft(5); // paddedLeft = " Foo" (pads with spaces by default)
string paddedRight = s.PadRight(6, '+'); // paddedRight = "Foo+++" 
string noPadded = s.PadLeft(2); // noPadded = "Foo" (original string is never shortened)
</code></pre>
    <b>Getting x characters from the right side of a string</b>
    <pre><code>
  public static class StringExtensions
  {
    public static string Left( this string stringparam, int numchars )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (numchars > stringparam.Length)
        numchars = stringparam.Length;
      return stringparam.Substring( 0, numchars );
    }
    public static string Right( this string stringparam, int numchars )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (numchars > stringparam.Length)
        numchars = stringparam.Length;
      return stringparam.Substring( stringparam.Length - numchars );
    }
  
    public static string Mid( this string stringparam, int startindex )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative startindex being passed
      startindex = Math.Abs( startindex );
      // Validate numchars parameter
      if (startindex > stringparam.Length)
        startindex = stringparam.Length;
      // C# strings are zero-based, convert passed startindex
      return stringparam.Substring( startindex - 1 );
    }
    
    public static string Mid( this string stringparam, int startindex, int numchars)
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative startindex being passed
      startindex = Math.Abs( startindex );
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (startindex > stringparam.Length)
        startindex = stringparam.Length;
      // C# strings are zero-based, convert passed startindex
      return stringparam.Substring( startindex - 1, numchars );
      }
  }
  //This extension method can be used as follows:
  //string myLongString = "Hello World!";
  //string myShortString = myLongString.Right(6); // "World!"
  //string myLeftString = myLongString.Left(5); // "Hello"
  //string myMidString1 = myLongString.Left(4); // "lo World"
  //string myMidString2 = myLongString.Left(2,3); // "ell"
</code></pre>
    <b>Checking for empty String using String.IsNullOrEmpty() and String.IsNullOrWhiteSpace()</b>
    <pre><code>
  string nullString = null;
  string emptyString = "";
  string whitespaceString = " ";
  string tabString = "\t";
  string newlineString = "\n";
  string nonEmptyString = "abc123";
  bool result;
result = String.IsNullOrEmpty(nullString); // true
result = String.IsNullOrEmpty(emptyString); // true
result = String.IsNullOrEmpty(whitespaceString); // false
result = String.IsNullOrEmpty(tabString); // false
result = String.IsNullOrEmpty(newlineString); // false
result = String.IsNullOrEmpty(nonEmptyString); // false
result = String.IsNullOrWhiteSpace(nullString); // true
result = String.IsNullOrWhiteSpace(emptyString); // true
result = String.IsNullOrWhiteSpace(tabString); // true
result = String.IsNullOrWhiteSpace(newlineString); // true
result = String.IsNullOrWhiteSpace(whitespaceString); // true
result = String.IsNullOrWhiteSpace(nonEmptyString); // false
</code></pre>
    <b>Trimming Unwanted Characters</b>
    <pre><code>
  String.Trim()
  string x = " Hello World! ";
  string y = x.Trim(); // "Hello World!"
  string q = "{(Hi!*";
  string r = q.Trim( '(', '*', '{' ); // "Hi!"
  String.TrimStart() and String.TrimEnd()
  string q = "{(Hi*";
  string r = q.TrimStart( '{' ); // "(Hi*"
  string s = q.TrimEnd( '*' ); // "{(Hi"
</code></pre>
    <b>Convert Decimal Number to Binary,Octal and Hexadecimal Format</b>
    <pre><code>
 // 1. To convert decimal number to binary format use base 2
  Int32 Number = 15;
  Console.WriteLine(Convert.ToString(Number, 2)); //OUTPUT : 1111
 // 2. To convert decimal number to octal format use base 8
  int Number = 15;
  Console.WriteLine(Convert.ToString(Number, 8)); //OUTPUT : 17
//  3. To convert decimal number to hexadecimal format use base 16
  var Number = 15;
  Console.WriteLine(Convert.ToString(Number, 16)); //OUTPUT : f 
</code></pre>
    <b>Construct a string from Array</b>
    <pre><code>
  string delimiter=",";
  char[] charArray = new[] { 'a', 'b', 'c' };
  string inputString = String.Join(delimiter, charArray);
 // Output : a,b,c if we change the delimiter as "" then the output will become abc.

String from List of char:
string delimiter = "|";
List<char> charList = new List<char>() { 'a', 'b', 'c' };
string inputString = String.Join(delimiter, charList);
//Output : a|b|c

String from List of Strings:
string delimiter = " ";
List<string> stringList = new List<string>() { "Ram", "is", "a","boy" };
string inputString = String.Join(delimiter, stringList);
//Output : Ram is a boy

String from array of strings:
string delimiter = "_";
string[] stringArray = new [] { "Ram", "is", "a","boy" };
string inputString = String.Join(delimiter, stringArray);
//Output : Ram_is_a_boy
</code></pre>
    <b>Finding a string within a string</b>
    <pre><code>
  string s = "Hello World";
  bool stringExists = s.Contains("ello"); //stringExists =true as the string contains the substring 
  int location = s.IndexOf("ello"); // location = 1
  int location = s.LastIndexOf("l"); // location = 9
</code></pre>
</div>

<h2>Operators</h2>
<div>

  <b>Implicit Cast and Explicit Cast Operators</b>
  C# allows user-defined types to control assignment and casting through the use of <strong>the explicit and
    implicit</strong> keywords.
  The signature of the method takes the form:
  <cl>public static < implicit/explicit> operator < ResultingType>(< SourceType> myType)</cl>
  The method cannot take any more arguments, nor can it be an instance method. It can, however, access any private
  members of type it is defined within.
  An example of both an implicit and explicit cast:
  <pre><code>
public class BinaryImage
{
private bool[] _pixels;
public static implicit operator ColorImage(BinaryImage im)
{
  return new ColorImage(im);
}
public static explicit operator bool[](BinaryImage im)
{
  return im._pixels;
}
}
</code></pre>
  Allowing the following cast syntax:
  <pre><code>
var binaryImage = new BinaryImage();
ColorImage colorImage = binaryImage; // implicit cast, note the lack of type
bool[] pixels = (bool[])binaryImage; // explicit cast, defining the type
</code></pre>
  The cast operators can work both ways, going from your type and going to your type:
  <pre><code>
public class BinaryImage
{
public static explicit operator ColorImage(BinaryImage im)
{
 return new ColorImage(im);
}
GoalKicker.com – C# Notes for Professionals 25
public static explicit operator BinaryImage(ColorImage cm)
{
  return new BinaryImage(cm);
}
}
</code></pre>
  Finally, the as keyword, which can be involved in casting within a type hierarchy, is not valid in this situation.
  Even
  after defining either an explicit or implicit cast, you cannot do:
  <cl>ColorImage cm = myBinaryImage as ColorImage;</cl>
  It will generate a compilation error.

  <b>Ternary Operator</b>
  Returns one of two values depending on the value of a Boolean expression.
  Syntax:
  <cl>condition ? expression_if_true : expression_if_false;</cl>
  Example:
  <pre><code>
string name = "Frank";
Console.WriteLine(name == "Frank" ? "The name is Frank" : "The name is not Frank");  
//=====================================
//Example 2:
light.intensity = Clamp(light.intensity, minLight, maxLight);
public static float Clamp(float val, float min, float max)
{
return (val < min) ? min : (val > max) ? max : val;
}
</code></pre>
  Ternary operators can also be nested, such as:
  <pre><code>a ? b ? "a is true, b is true" : "a is true, b is false" : "a is false"
// This is evaluated from left to right and can be more easily seen with parenthesis:
a ? (b ? x : y) : z
// Where the result is x if a && b, y if a && !b, and z if !a
</code></pre>

  <b>var vs dynamic</b>
  <pre><code>
// var says, “let the compiler figure out the type”.
// dynamic says, “let the runtime figure out the type”.

dynamic x = "hello";  // Static type is dynamic, runtime type is string
var y = "hello";      // Static type is string, runtime type is string
int i = x;            // Run-time error
int j = y;            // Compile-time error
</code></pre>

  <b>Overloadable Operators</b>
  <b>Operator Overloading </b>
  An operator is overloaded by declaring an operator function:
  <code><pre>
//Example1 :
Note B = new Note (2);
Note CSharp = B + 2;
CSharp.SemitonesFromA.Dump();

CSharp += 2;
CSharp.SemitonesFromA.Dump();

public struct Note
{
int value;
public int SemitonesFromA => value;

public Note (int semitonesFromA) { value = semitonesFromA; }

public static Note operator + (Note x, int semitones)
{
  return new Note (x.value + semitones);
}
}

//Example 2:
public struct Complex
{
  public double Real { get; set; }
  public double Imaginary { get; set; }
}
public static Complex operator +(Complex c1, Complex c2)
{
  return new Complex
  {
    Real = c1.Real + c2.Real,
    Imaginary = c1.Imaginary + c2.Imaginary
  };
}
///=============================
//Example 3:
public static class Polar
{
  public static bool operator is(Cartesian c, out double R, out double Theta)
  {
    R = Math.Sqrt(c.X*c.X + c.Y*c.Y);
    Theta = Math.Atan2(c.Y, c.X);
    return c.X != 0 || c.Y != 0;
  }
}
//================================
//Example 4:
class Student : IEquatable< Student>
{
  public string Name { get; set; } = "";
  public bool Equals(Student other)
  {
    if (ReferenceEquals(other, null)) return false;
    if (ReferenceEquals(other, this)) return true;
    return string.Equals(Name, other.Name);
  }
  public override bool Equals(object obj)
  {
    if (ReferenceEquals(null, obj)) return false;
    if (ReferenceEquals(this, obj)) return true;
    return Equals(obj as Student);
  }
  public override int GetHashCode()
  {
    return Name?.GetHashCode() ?? 0;
  }
  public static bool operator ==(Student left, Student right)
  {
    return Equals(left, right);
  }
  public static bool operator !=(Student left, Student right)
  {
    return !Equals(left, right);
  }
}
</code></pre>
  <b>explicit operator</b>
  <pre><code>
internal class Explicit
{
  public static explicit operator int (Explicit a)
  {
      return 5;
  }
}

internal class Implicit
{
  public static implicit operator int(Implicit a)
  {
      return 5;
  }
}
//and two objects:

var obj1 = new Explicit();
var obj2 = new Implicit();

//you can now write:

int integer = obj2; // implicit conversion - you don't have to use (int)
//or:
int integer = (int)obj1; // explicit conversion
//but:
int integer = obj1; // WON'T WORK - explicit cast required
</code></pre>
  <b>Short-circuiting Operators</b>
  The short-circuiting boolean operators will only evaluate the second operand if
  the first operand can not determine the overall result of the expression.

  It means that, if you are using && operator as firstCondition && secondCondition
  it will evaluate secondCondition only when firstCondition is true
  and ofcource the overall result will be true only if both of firstOperand
  and secondOperand are evaluated to true.
  This is useful in many scenarios, for example imagine that you want to check whereas your
  list has more than three elements but you also have to check if list has been initialized to not run into
  NullReferenceException. You can achieve this as below:
  <pre><code>
bool hasMoreThanThreeElements = myList != null && mList.Count > 3;
mList.Count > 3 will not be checked untill myList != null is met.
</code></pre>
  <strong>Logical AND</strong>
  && is the short-circuiting counterpart of the standard boolean AND (&) operator.
  <pre><code>
var x = true;
var y = false;
x && x // Returns true.
x && y // Returns false (y is evaluated).
y && x // Returns false (x is not evaluated).
y && y // Returns false (right y is not evaluated).
</code></pre>
  <strong>Logical OR</strong>
  || is the short-circuiting counterpart of the standard boolean OR (|) operator.
  <pre><code>
var x = true;
var y = false;
x || x // Returns true (right x is not evaluated).
x || y // Returns true (y is not evaluated).
y || x // Returns true (x and y are evaluated).
y || y // Returns false (y and y are evaluated).
</code></pre>
  Example usage
  <pre><code>
if(object != null && object.Property)
// object.Property is never accessed if object is null, because of the short circuit.
GoalKicker.com – C# Notes for Professionals 26
Action1();
else
Action2();
</code></pre>
  <b>Indexers</b>
  is a special type of property that to be accessed like an array for its internal collection
  Example:
  <pre><code>
class StringDataStore
{
  private string[] strArr = new string[10]; // internal data storage

  public string this[int index]
  {
      get
      {
          if (index < 0 || index >= strArr.Length)
              throw new IndexOutOfRangeException("Index out of range");

              return strArr[index];
      }

      set
      {
          if (index < 0 ||  index >= strArr.Length)
              throw new IndexOutOfRangeException("Index out of range");

          strArr[index] = value;
      }
  }
}
</code></pre>
  <b>default Operator</b>
  <cl>Value Type (where T : struct)</cl>
  The built-in primitive data types, such as char, int, and float, as well as user-defined types declared with struct,
  or enum. Their default value is new T() :
  <pre><code>
default(int) // 0
default(DateTime) // 0001-01-01 12:00:00 AM
default(char) // '\0' This is the "null character", not a zero or a line break.
default(Guid) // 00000000-0000-0000-0000-000000000000
default(MyStruct) // new MyStruct()
// Note: default of an enum is 0, and not the first *key* in that enum
// so it could potentially fail the Enum.IsDefined test
default(MyEnum) // (MyEnum)0
Reference Type (where T : class)
Any class, interface, array or delegate type. Their default value is null :
default(object) // null
default(string) // null
default(MyClass) // null
default(IDisposable) // null
default(dynamic) // null 
</code></pre>
  <b>sizeof</b>
  Returns an int holding the size of a type* in bytes.
  <pre><code>
sizeof(bool) // Returns 1.
sizeof(byte) // Returns 1.
sizeof(sbyte) // Returns 1.
sizeof(char) // Returns 2.
sizeof(short) // Returns 2.
sizeof(ushort) // Returns 2.
sizeof(int) // Returns 4.
sizeof(uint) // Returns 4.
sizeof(float) // Returns 4.
sizeof(long) // Returns 8.
sizeof(ulong) // Returns 8.
sizeof(double) // Returns 8.
sizeof(decimal) // Returns 16.  
</code></pre>
  <b>Null-Conditional Operator</b>
  Introduced in C# 6.0, the Null Conditional Operator <b>?.</b> will immediately return null
  if the expression on its lefthand side evaluates to null, instead of throwing a NullReferenceException.
  If its left-hand side evaluates to a nonnull value, it is treated just like a normal . operator.
  Note that because it might return null, its return type is always a nullable type.
  That means that for a struct or primitive type, it is wrapped into a <b>Nullable<T>.</b>
  <pre><code>
var bar = Foo.GetBar()?.Value; // will return null if GetBar() returns null
var baz = Foo.GetBar()?.IntegerValue; // baz will be of type Nullable<int>, i.e. int?  
</code></pre>
  This comes handy when firing events.
  Normally you would have to wrap the event call in an if statement checking for null and raise the event afterwards,
  which introduces the possibility of a race condition.
  Using the Null conditional operator this can be fixed in the following way:
  <pre><code> 
event EventHandler<string> RaiseMe;
RaiseMe?.Invoke("Event raised"); 
</code></pre>

  Nullable types also work well with the null-conditional operator
  <pre><code>    
System.Text.StringBuilder sb = null;
int? length = sb?.ToString().Length;
length.Dump();

// We can combine this with the null coalescing operator to evaluate to zero instead of null:

int length2 = sb?.ToString().Length ?? 0;  // Evaluates to 0 if sb is null
length2.Dump();
</code></pre>
  <b>Null-Coalescing Operator</b>
  The Null-Coalescing operator ?? will return the left-hand side when not null.
  If it is null, it will return the right-hand side.

  Parameter Details
  possibleNullObject The value to test for null value. If non null, this value is returned. Must be a nullable type.
  defaultValue The value returned if possibleNullObject is null. Must be the same type as possibleNullObject.
  <pre><code>
object foo = null;
object bar = new object();
var c = foo ?? bar;
//c will be bar since foo was null
The ?? operator can be chained which allows the removal of if checks.
//config will be the first non-null returned.
var config = RetrieveConfigOnMachine() ??
RetrieveConfigFromService() ??
new DefaultConfiguration();
</code></pre>
  <b>Basic usage</b>
  Using the null-coalescing operator (??) allows you to specify a default value for a nullable type if the left-hand
  operand is null.
  <pre><code>
string testString = null;
Console.WriteLine("The specified string is - " + (testString ?? "not provided"));  
</code></pre>
  This is logically equivalent to:
  <pre><code>
string testString = null;
if (testString == null)
{
Console.WriteLine("The specified string is - not provided");
}
else
{
Console.WriteLine("The specified string is - " + testString);
} 
</code></pre>
  or using the ternary operator (?:) operator:
  <pre><code>
string testString = null;
Console.WriteLine("The specified string is - " + (testString == null ? "not provided" :testString));  
</code></pre>
  <b>Null fall-through and chaining</b>
  left-hand operand must be nullable, while the right-hand operand may or may not be.
  The result will be typed accordingly.
  Non-nullable:
  <pre><code>
int? a = null;
int b = 3;
var output = a ?? b;
var type = output.GetType();
Console.WriteLine($"Output Type :{type}");
Console.WriteLine($"Output value :{output}");
//Output:
//Type :System.Int32
//value :3
</code></pre>
  Nullable:
  <pre><code>
int? a = null;
int? b = null;
var output = a ?? b;
//output will be of type int? and equal to b, or null.
</code></pre>
  Multiple Coalescing:
  Coalescing can also be done in chains:
  <pre><code>
int? a = null;
int? b = null;
int c = 3;
var output = a ?? b ?? c;
var type = output.GetType();
Console.WriteLine($"Type :{type}");
Console.WriteLine($"value :{output}");
//Output:
//Type :System.Int32
//value :3
</code></pre>
  <b>Lambda operator</b>
  The => operator has the same precedence as the assignment operator = and is right-associative.
  It is used to declare lambda expressions and also it is widely used with LINQ Queries:
  <pre><code>
string[] words = { "cherry", "apple", "blueberry" };
int shortestWordLength = words.Min((string w) => w.Length); //5
</code></pre>

  When used in LINQ extensions or queries the type of the objects can usually be skipped as it is inferred by the
  compiler:
  <pre><code>
int shortestWordLength = words.Min(w => w.Length); //also compiles with the same result  
</code></pre>
  The general form of lambda operator is the following:
  <cl>(input parameters) => expression</cl>
  The parameters of the lambda expression are specified before => operator,
  and the actual expression/statement/block to be executed is to the right of the operator:
  <pre><code>
// expression
(int x, string s) => s.Length > x
// expression
(int x, int y) => x + y
// statement
(string x) => Console.WriteLine(x)
// block
(string x) => {
x += " says Hello!";
Console.WriteLine(x);
}</code></pre>
  This operator can be used to easily define delegates, without writing an explicit method:
  <pre><code>
delegate void TestDelegate(string s);
TestDelegate myDelegate = s => Console.WriteLine(s + " World");
myDelegate("Hello");
instead of
void MyMethod(string s)
{
Console.WriteLine(s + " World");
}
delegate void TestDelegate(string s);
TestDelegate myDelegate = MyMethod;
myDelegate("Hello");
</code></pre>
  <b>Null coalescing operator with method calls</b>
  The null coalescing operator makes it easy to ensure that a method that may return null will fall back to a default
  value.
  Without the null coalescing operator:
  <pre><code>
string name = GetName();
if (name == null)
name = "Unknown!";
</code></pre>
  With the null coalescing operator:
  <cl>string name = GetName() ?? "Unknown!";</cl>

  <b>Class Member Operators: Null Conditional Member Access</b>
  <pre><code>
var zipcode = myEmployee?.Address?.ZipCode;
//returns null if the left operand is null.
//the above is the equivalent of:
var zipcode = (string)null;
if (myEmployee != null && myEmployee.Address != null)
zipcode = myEmployee.Address.ZipCode;
</code></pre>
  <b> Use existing or create new</b>
  A common usage scenario that this feature really helps with is when you are looking for an object in a collection
  and need to create a new one if it does not already exist.
  <pre><code>
IEnumerable<MyClass> myList = GetMyList();
var item = myList.SingleOrDefault(x => x.Id == 2) ?? new MyClass { Id = 2 }; 
</code></pre>
  <b>Lazy properties initialization with null coalescing operator</b>
  <pre><code>
private List<FooBar> _fooBars;
  public List<FooBar> FooBars
  {
  get { return _fooBars ?? (_fooBars = new List<FooBar>()); }
  }
</code></pre>
  The first time the property .FooBars is accessed the _fooBars variable will evaluate as null,
  thus falling through to the assignment statement assigns and evaluates to the resulting value.
  <strong>Thread safety</strong>
  This is not thread-safe way of implementing lazy properties.
  For thread-safe laziness, use the Lazy<T> class built into the .NET Framework.
    <strong>C# 6 Syntactic Sugar using expression bodies</strong>
    Note that since C# 6, this syntax can be simplified using expression body for the property:
    <pre><code>
private List<FooBar> _fooBars;
public List<FooBar> FooBars => _fooBars ?? ( _fooBars = new List<FooBar>() );
// Subsequent accesses to the property will yield the value stored in the _fooBars variable.
</code></pre>
    <b>Example in the MVVM pattern</b>
    This is often used when implementing commands in the MVVM pattern. Instead of initializing the commands
    eagerly with the construction of a viewmodel, commands are lazily initialized using this pattern as follows:
    <pre><code>
private ICommand _actionCommand = null;
public ICommand ActionCommand =>
_actionCommand ?? ( _actionCommand = new DelegateCommand( DoAction ) ); 
</code></pre>

    <b>Class Member Operators: Null Conditional Indexing</b>
    The ?. operator is syntactic sugar to avoid verbose null checks. It's also known as the Safe navigation operator.
    <pre><code>
//Example 1:
public class Person
{
public int Age { get; set; }
public string Name { get; set; }
public Person Spouse { get; set; }
}
//If an object is potentially null (such as a function that returns a reference type) 
//the object must first be checked for null to prevent a possible NullReferenceException. 
//Without the null-conditional operator, this would look like:
Person person = GetPerson();
int? age = null;
if (person != null)
age = person.Age;

//The same example using the null-conditional operator:
Person person = GetPerson();
var age = person?.Age; // 'age' will be of type 'int?', even if 'person' is not null

//Example 2:

var letters = null;
char? letter = letters?[1];
Console.WriteLine("Second Letter is {0}",letter);
//in the above example rather than throwing an error because letters is null
//letter is assigned the value null  

//Chaining the Operator:
//The null-conditional operator can be combined on the members and sub-members of an object.
// Will be null if either `person` or `person.Spouse` are null
int? spouseAge = person?.Spouse?.Age;

// Combining with the Null-Coalescing Operator
// The null-conditional operator can be combined with the null-coalescing operator to provide a default value:
// spouseDisplayName will be "N/A" if person, Spouse, or Name is null
var spouseDisplayName = person?.Spouse?.Name ?? "N/A";
</code></pre>
    <b>The Null-Conditional Index</b>
    <pre><code>
// Similarly to the ?. operator, the null-conditional index operator checks for null values
// when indexing into a collection that may be null.
string item = collection?[index];
is syntactic sugar for
string item = null;
if(collection != null)
{
item = collection[index];
}
</code></pre>
    <b>Avoiding NullReferenceExceptions</b>
    <pre><code>
var person = new Person
{
Address = null;
};
var city = person.Address.City; //throws a NullReferenceException
var nullableCity = person.Address?.City; //returns the value of null
This effect can be chained together:
var person = new Person
{
  Address = new Address
  {
    State = new State
      {
        Country = null
    }
  }
};
// this will always return a value of at least "null" to be stored instead
// of throwing a NullReferenceException
var countryName = person?.Address?.State?.Country?.Name;
</code></pre>
    <b>Null-conditional Operator can be used with Extension Method</b>
    Extension Method can work on null references, but you can use ?. to null-check anyway.
    <pre><code>
public class Person
{
  public string Name {get; set;}
}
public static class PersonExtensions
{
  public static int GetNameLength(this Person person)
  {
    return person == null ? -1 : person.Name.Length;
  }
}
//Normally, the method will be triggered for null references, and return -1:
Person person = null;
int nameLength = person.GetNameLength(); // returns -1
</code></pre>
    Using ?. the method will not be triggered for null references, and the type is int?:


    <b>typeof</b>
    Gets System.Type object for a type.
    <pre><code class="csharp">
System.Type type = typeof(Point); //System.Drawing.Point
System.Type type = typeof(IDisposable); //System.IDisposable
System.Type type = typeof(Colors); //System.Drawing.Color
System.Type type = typeof(List<>); //System.Collections.Generic.List`1[T]
</code></pre>
    To get the run-time type, use GetType method to obtain the System.Type of the current instance.
    Operator typeof takes a type name as parameter, which is specified at compile time.
    <pre><code>
public class Animal {}
public class Dog : Animal {}
var animal = new Dog();
Assert.IsTrue(animal.GetType() == typeof(Animal)); // fail, animal is typeof(Dog)
Assert.IsTrue(animal.GetType() == typeof(Dog)); // pass, animal is typeof(Dog)
Assert.IsTrue(animal is Animal); // pass, animal implements Animal
</code></pre>
    <b>nameof Operator</b>
    Returns a string that represents the unqualified name of a variable, type, or member.
    <pre><code>
int counter = 10;
nameof(counter); // Returns "counter"
Client client = new Client();  
nameof(client.Address.PostalCode)); // Returns "PostalCode"
The nameof operator was introduced in C# 6.0. 
It is evaluated at compile-time and the returned string value is inserted inline by the compiler,
so it can be used in most cases where the constant string can be used 
(e.g., the case labels in a switch statement, attributes, etc...). 
It can be useful in cases like raising & logging exceptions, attributes, MVC Action links, etc...
//=================================
// Raising PropertyChanged event

<pre><code>
public class Person : INotifyPropertyChanged
{
  private string _address;
  public event PropertyChangedEventHandler PropertyChanged;
  private void OnPropertyChanged(string propertyName)
  {
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
  }
  public string Address
  {
    get { return _address; }
    set
    {
      if (_address == value)
      {
        return;
      }
      _address = value;
      OnPropertyChanged(nameof(Address));
    }
  }
}
...
var person = new Person();
person.PropertyChanged += (s,e) => Console.WriteLine(e.PropertyName);
person.Address = "123 Fake Street";
//Console Output
//Address

//===============================================
//Argument Checking and Guard Clauses

//Prefer
if (orderLine == null) throw new ArgumentNullException(nameof(orderLine));

//Over
if (orderLine == null) throw new ArgumentNullException("orderLine");
//================================================
//Applied to a generic type parameter

public class SomeClass<TItem>
{
  public void PrintTypeName()
  {
    Console.WriteLine(nameof(TItem));
  }
}
</code></pre>

    </code></pre>
    <b>Class Member Operators: Aggregate Object Indexing</b>
    <pre><code>
var letters = "letters".ToCharArray();
char letter = letters[1];
Console.WriteLine("Second Letter is {0}",letter);
//in the above example we take the second character from the array
//by calling letters[1]
//NB: Array Indexing starts at 0; i.e. the first letter would be given by letters[0].
</code></pre>
</div>
<h2>GetHashCode</h2>
<div>
  <b>Writing a good GetHashCode override</b>
  GetHashCode has major performance effects on Dictionary<> and HashTable.
    Good GetHashCode Methods
    should have an even distribution
    every integer should have a roughly equal chance of returning for a random instance
    if your method returns the same integer (e.g. the constant '999') for each instance, you'll have bad
    performance
    should be quick
    These are NOT cryptographic hashes, where slowness is a feature
    the slower your hash function, the slower your dictionary
    must return the same HashCode on two instances that Equals evaluates to true
    if they do not (e.g. because GetHashCode returns a random number),
    items may not be found in a List,Dictionary, or similar.
    A good method to implement GetHashCode is to use one prime number as a starting value, and add the hashcodes
    of the fields of the type multiplied by other prime numbers to that:
    <pre><code>
public override int GetHashCode()
{
unchecked // Overflow is fine, just wrap
{
int hash = 3049; // Start value (prime number).
// Suitable nullity checks etc, of course :)
hash = hash * 5039 + field1.GetHashCode();
hash = hash * 883 + field2.GetHashCode();
hash = hash * 9719 + field3.GetHashCode();
return hash;
}
}</code></pre>
Only the fields which are used in the Equals-method should be used for the hash function.
If you have a need to treat the same type in different ways for Dictionary/HashTables, you can use
IEqualityComparer.

<b>Override Equals and GetHashCode on custom types</b>
For a class Person like:
<pre><code>
public class Person
{
public string Name { get; set; }
public int Age { get; set; }
public string Clothes { get; set; }
}
var person1 = new Person { Name = "Jon", Age = 20, Clothes = "some clothes" };
var person2 = new Person { Name = "Jon", Age = 20, Clothes = "some other clothes" };
bool result = person1.Equals(person2); //false because it's reference Equals
But defining Equals and GetHashCode as follows:
public class Person
{
public string Name { get; set; }
GoalKicker.com – C# Notes for Professionals 39
public int Age { get; set; }
public string Clothes { get; set; }
public override bool Equals(object obj)
{
  var person = obj as Person;
  if(person == null) return false;
  return Name == person.Name && Age == person.Age; //the clothes are not important when comparing two persons
  }
  public override int GetHashCode()
  {
    return Name.GetHashCode()*Age;
  }
}
var person1 = new Person { Name = "Jon", Age = 20, Clothes = "some clothes" };
var person2 = new Person { Name = "Jon", Age = 20, Clothes = "some other clothes" };
bool result = person1.Equals(person2); // result is true
Also using LINQ to make different queries on persons will check both Equals and GetHashCode:
var persons = new List<Person>
{
  new Person{ Name = "Jon", Age = 20, Clothes = "some clothes"},
  new Person{ Name = "Dave", Age = 20, Clothes = "some other clothes"},
  new Person{ Name = "Jon", Age = 20, Clothes = ""}
};
var distinctPersons = persons.Distinct().ToList();//distinctPersons has Count = 2

</code></pre>

    <b>Equals and GetHashCode in IEqualityComparator</b>
    For given type Person:
    <pre><code>
public class Person
{
  public string Name { get; set; }
  public int Age { get; set; }
  public string Clothes { get; set; }
}
List<Person> persons = new List<Person>
{
  new Person{ Name = "Jon", Age = 20, Clothes = "some clothes"},
  new Person{ Name = "Dave", Age = 20, Clothes = "some other clothes"},
  new Person{ Name = "Jon", Age = 20, Clothes = ""}
};
var distinctPersons = persons.Distinct().ToList();// distinctPersons has Count = 3
But defining Equals and GetHashCode into an IEqualityComparator :
public class PersonComparator : IEqualityComparer<Person>
{
public bool Equals(Person x, Person y)
{
  return x.Name == y.Name && x.Age == y.Age; //the clothes are not important when comparing
  two persons;
}
public int GetHashCode(Person obj) { return obj.Name.GetHashCode() * obj.Age; }
}
var distinctPersons = persons.Distinct(new PersonComparator()).ToList();// distinctPersons has Count = 2
</code></pre>
    Note that for this query, two objects have been considered equal if both the Equals returned true and the
    GetHashCode have returned the same hash code for the two persons.


</div>
<h2>Generics</h2>
<div>
  means not specific to a particular data type.
  Example :
  The DataStore is a generic class:
  <pre><code>
  class DataStore< T>
  {
    public T Data { get; set; } //generic field of the generic class
    public T GetData(int index) { ...} //generic method (which returns generic class).
                       //(generic methods can also be defined in a none-generic class)
  }
  </code></pre>
  T is called type parameter, which can be used as
  a type of fields, properties, method parameters, return types,and delegates in <strong> the DataStore class</strong>.
  <b> Instanciation:</b>
     You can create an instance of generic classes by specifying an actual type in angle brackets:
  <cl> DataStore<string> store = new DataStore<string>();</cl>
<b> C# Generic Constraints</b>
  You can use constraints to restrict the type to certain types while instantiating generic types.
  It will give a compile - time error if you try to instantiate a generic type using a type that is not allowed by
    the specified constraints.
  
  There are six types of constraints:

  where T: struct -Type argument must be a value type
  where T: class -Type argument must be a reference type
  where T: new() - Type argument must have a public parameterless constructor.
  where T :
  < base class> -Type argument must inherit from
  < base class> class.
  where T: < interface> -Type argument must implement from< interface> interface.
  where T: U - There are two type arguments T and U.T must be inherit from U.


  <a href='https://www.tutorialsteacher.com/csharp/constraints-in-generic-csharp'>more..</a>
  <b>multicast delegates</b>
  multicasting is the ability to create an invocation list, or chain, of methods that
  will be automatically called when a delegate is invoked.
  A delegate instance can reference not just a single target method, but also a list of target methods.
  As a result, one delegate instance can call many methods.It is called multicast.
  All delegate instances have multicast capability.

  Example:
  <pre><code>
  // All delegate instances have multicast capability:

  SomeDelegate d = SomeMethod1;
  d += SomeMethod2;

  d();
  " -- SomeMethod1 and SomeMethod2 both fired\r\n".Dump();

  d -= SomeMethod1;
  d();
  " -- Only SomeMethod2 fired".Dump();

  void SomeMethod1() => "SomeMethod1".Dump();
  void SomeMethod2() => "SomeMethod2".Dump();

  delegate void SomeDelegate();
  </code></pre>
</div>
<h2>Access modifiers</h2>
<div>
 <pre><code>
class Class1 {}         // Class1 is <b>internal</b> (default) - visible to other types in same assembly
public class Class2 {}  // Class2 is visible to everything, including types in other assemblies

class ClassA
{
  int x;               // x is private <b>(default)</b> - cannot be accessed from other types
}

class ClassB
{
  internal int x;    // x can be accessed from other types in same assembly
}

class BaseClass
{
  void Foo()           {}    // Foo is private (default)
  protected void Bar() {}    // <b>protected</b> is accessible to subclasses
}

class Subclass : BaseClass
{
   void Test1() { Foo(); }     // Error - cannot access Foo
   void Test2() { Bar(); }     // OK
}
Friend Assemblies

// Unsigned friend:
//    [assembly: InternalsVisibleTo ("Friend")]

// Signed friend:
//    [assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]

// To obtain an assembly's public key, hit F5 to run the following code:

using (var dialog = new OpenFileDialog())
{
  dialog.Title = "Locate assembly";
  dialog.Filter = "Assembly files|*.dll;*.exe";
  dialog.DefaultExt = ".dll";
  
  if (dialog.ShowDialog() != DialogResult.OK) return;
  if (!File.Exists (dialog.FileName)) return;
  
  var aName = Assembly.LoadFile (dialog.FileName).GetName();

  string key = string.Join ("", 
    aName.GetPublicKey().Select (b => b.ToString ("x2")).ToArray());
    
  string assemAttrib = "[assembly: InternalsVisibleTo (\"" 
    + aName.Name
    + ", PublicKey=" + key.Dump ("Full Key")
    + "\")]";
    
  assemAttrib.Dump ("Assembly Attribute");
  
  Clipboard.SetText (assemAttrib);
}
</code></pre> 
</div>
<h2>yield return</h2>
<div>
  if you want a collection that you can use "foreach" on, but gathering the items into the collection is
    expensive for some reason
    (like querying them out of a database), AND you will often not need the entire collection,
    then you create a function that builds the collection one item at a time and yields it back to the consumer
    (who can then terminate the collection effort early).

    t first sight, yield return is a .NET sugar to return an IEnumerable.

    Without yield, all the items of the collection are created at once:
    <pre><code>
  class SomeData
  {
      public SomeData() { }

      static public IEnumerable<SomeData> CreateSomeDatas()
      {
          return new List<SomeData> {
              new SomeData(), 
              new SomeData(), 
              new SomeData()
          };
      }
  }
  </code></pre>
 Same code using yield, it returns item by item:
  <pre><code>
    class SomeData
    {
        public SomeData() { }

        static public IEnumerable<SomeData> CreateSomeDatas()
        {
            yield return new SomeData();
            yield return new SomeData();
            yield return new SomeData();
        }
    }
  </code></pre>
  The advantage of using yield is that if the function consuming your data simply needs the first item of the
  collection,
  the rest of the items won't be created.
  The yield operator allows the creation of items as it is demanded. That's a good reason to use it.
  <b>yield break</b>
  <pre><code>
    // The yield break statement indicates that the iterator block should exit early,
    // without returning more elements:

    foreach (string s in Foo (true))
    Console.WriteLine (s);

    static IEnumerable<string> Foo (bool breakEarly)
    {
        yield return "One";
        yield return "Two";

        if (breakEarly)
            yield break;

        yield return "Three";
    }
  </code></pre>
</div>
<h2>yield break</h2>
<div>
  The yield break statement indicates that the iterator block should exit early,
                without returning more elements:
                <pre><code>
  foreach (string s in Foo (true))
    Console.WriteLine (s);

  static IEnumerable<string> Foo (bool breakEarly)
  {
    yield return "One";
    yield return "Two";

    if (breakEarly)
      yield break;

    yield return "Three";
  }
  </code></pre>
<b>Multiple yield Statements</b>
Multiple yield statements are permitted:
<pre><code>
   foreach (string s in Foo())
    Console.WriteLine (s);         // Prints "One","Two","Three"

  IEnumerable<string> Foo()
  {
    yield return "One";
    yield return "Two";
    yield return "Three";
  }
  </code></pre>
Example 2
<pre><code>
      IEnumerable<string> Foo()
      {
          try
          {
          yield return "One";
          yield return "Two";
          yield return "Three";
          }
  </code></pre>
<b>Null</b>
<pre><code>
      int? x = null;
      int y = x ?? 5;
      Console.WriteLine (y);  // 5    
  </code></pre>
<b>Extension Methods</b>
Extension methods allow an existing type to be extended with new methods without altering
the definition of the original type:
<pre><code>
  Console.WriteLine ("Perth".IsCapitalized());
  // Equivalent to:
  Console.WriteLine (StringHelper.IsCapitalized ("Perth"));

  // Interfaces can be extended, too:
  Console.WriteLine ("Seattle".First());   // S

  public static class StringHelper
  {
    public static bool IsCapitalized (this string s)
    {
      if (string.IsNullOrEmpty (s)) return false;
      return char.IsUpper (s [0]);
    }

    public static T First<T> (this IEnumerable<T> sequence)
    {
      foreach (T element in sequence)
        return element;

      throw new InvalidOperationException ("No elements!");
    }
  }
  </code></pre>
</div>
<h2>object oriented </h2>
<div>
  <h3>Inheritence</h3>
  <strong>What is difference between virtual and override in C#?</stong>

    The virtual keyword is used to modify a method, property, indexer, or event declared in the base class
    and allow it to be overridden in the derived class.
    The override keyword is used to extend or modify a virtual/abstract method, property, indexer, or event of
    base class into a derived class.
  
    <b>Polymorphism</b>:
    <pre><code>
    // A variable of type x can refer to an object that subclasses x.
  
      // The Display method below accepts an Asset. This means means we can pass it any subtype:
      Display (new Stock { Name="MSFT", SharesOwned=1000 });
      Display (new House { Name="Mansion", Mortgage=100000 });
  
      void Display (Asset asset)
      {
        Console.WriteLine (asset.Name);
      }
  
      public class Asset
      {
        public string Name;
      }
  
      public class Stock : Asset   // inherits from Asset
      {
       public long SharesOwned;
      }
  
      public class House : Asset   // inherits from Asset
      {
        public decimal Mortgage;
      }
    </code></pre>
                  <b>Reference Conversions - Upcasting</b>
                  <pre><code>
    // An upcast creates a base class reference from a subclass reference:
  
    Stock msft = new Stock();
    Asset a = msft;               // Upcast
  
    // After the upcast, the two variables still references the same Stock object:
  
    Console.WriteLine (a == msft);  // True
  
    public class Asset
    {
      public string Name;
    }
  
    public class Stock : Asset   // inherits from Asset
    {
      public long SharesOwned;
    }
  
    public class House : Asset   // inherits from Asset
    {
      public decimal Mortgage;
    }
    </code></pre>
                  <b>Virtual Function Members</b>
                  <pre><code>
    // A function marked as virtual can be overridden by subclasses wanting to provide a
    // specialized implementation:
  
    House mansion = new House { Name="McMansion", Mortgage=250000 };
    Console.WriteLine (mansion.Liability);      // 250000
  
    public class Asset
    {
      public string Name;
      public virtual decimal Liability => 0;    // Virtual
    }
  
    public class House : Asset
    {
      public decimal Mortgage;
      public override decimal Liability => Mortgage;   // Overridden
    }
  
    public class Stock : Asset
    {
      public long SharesOwned;
      // We won't override Liability here, because the default implementation will do.
    }
    </code></pre>
    <b>Covariant returns</b>

    From C# 9, we can override a method such that it returns a more derived (subclased) type:
    <pre><code>
    House mansion1 = new House { Name = "McMansion", Mortgage = 250000 };
    House mansion2 = mansion1.Clone();

    public class Asset
    {
      public string Name;
      public virtual Asset Clone() => new Asset { Name = Name };
    }

    public class House : Asset
    {
      public decimal Mortgage;
  
      // We can return House when overriding:
      public override House Clone() => new House { Name = Name, Mortgage = Mortgage };
    }
    </code></pre>
    <b>Abstract Classes & Members</b>

    A class declared as abstract can never be instantiated. Instead, only its concrete subclasses
    can be instantiated. Abstract classes are able to define abstract members.
    <pre><code>
    new Stock { SharesOwned = 200, CurrentPrice = 123.45M }.NetValue.Dump();

    public abstract class Asset    // Note abstract keyword
    {
      public abstract decimal NetValue { get; }  // Note empty implementation
    }

    public class Stock : Asset
    {
      public long SharesOwned;
      public decimal CurrentPrice;

      // Override like a virtual method.
      public override decimal NetValue => CurrentPrice * SharesOwned; 
    }
    </pre></code>
    <b>Sealing Functions & Classes</b>
    An overridden function member may seal its implementation with the sealed keyword to prevent it
    from being overridden by further subclasses:
    <pre><code>
    House mansion = new House { Name="McMansion", Mortgage=250000 };
    Console.WriteLine (mansion.Liability);      // 250000

    public class Asset
    {
      public string Name;
      public virtual decimal Liability => 0;    // Virtual
    }

    public class House : Asset
    {
      public decimal Mortgage;
      public sealed override decimal Liability => Mortgage;   // Overridden + sealed
    }

    // You can also seal the class itself, implicitly sealing all the virtual functions:

    public sealed class Stock : Asset { /* ... */ }
    </code></pre>

    <b>Overloading and Resolution</b>
    When calling an overload method, the method with the most specific
    parameter type match has precedence, based on the *compile-time* variable type:
    <pre><code>
    void Main()
    {
      Foo (new House());      // Calls Foo (House)
  
      Asset a = new House();
      Foo (a);                // Calls Foo (Asset)
    }

    static void Foo (Asset a) { "Foo Asset".Dump(); }
    static void Foo (House h) { "Foo House".Dump(); }

    public class Asset
    {
      public string Name;
    }

    public class Stock : Asset   // inherits from Asset
    {
      public long SharesOwned;
    }

    public class House : Asset   // inherits from Asset
    {
      public decimal Mortgage;
    }
    </code></pre>  
  </div>
<h2>Boxing & Unboxing</h2>
  <div>
   Boxing is the act of casting a value-type instance to a reference-type instance; unboxing is the reverse.
  <pre><code>
    int x = 9;
    object obj = x;           // Box the int
    int y = (int)obj;         // Unbox the int    
 </code></pre>  
  </div>
<h2>DateTime</h2>
  <div>
    <h3>Format DateTime</h3>
    <pre><code>
      //Create datetime
      DateTime dt = new DateTime(2016,08,01,18,50,23,230);
      var t = String.Format("{0:t}", dt); // "6:50 PM"                ShortTime
      var d = String.Format("{0:d}", dt); // "8/1/2016"               ShortDate
      var T = String.Format("{0:T}", dt); // "6:50:23 PM"             LongTime
      var D = String.Format("{0:D}", dt); // "Monday, August 1, 2016" LongDate
      var f = String.Format("{0:f}", dt); // "Monday, August 1, 2016 6:50 PM" LongDate+ShortTime
      var F = String.Format("{0:F}", dt); // "Monday, August 1, 2016 6:50:23 PM" FullDateTime
      var g = String.Format("{0:g}", dt); // "8/1/2016 6:50 PM"       ShortDate+ShortTime
      var G = String.Format("{0:G}", dt); // "8/1/2016 6:50:23 PM"    ShortDate+LongTime
      var m = String.Format("{0:m}", dt); // "August 1"               MonthDay
      var y = String.Format("{0:y}", dt); // "August 2016"            YearMonth
      var r = String.Format("{0:r}", dt); // "SMon, 01 Aug 2016 18:50:23 GMT" RFC1123
      var s = String.Format("{0:s}", dt); // "2016-08-01T18:50:23"    SortableDateTime
      var u = String.Format("{0:u}", dt); // "2016-08-01 18:50:23Z"   UniversalSortableDateTime
    </code></pre>
    <h3>Custom DateTime Formatting </h3>
    There are following custom format specifiers:
    y (year)
    M (month)
    d (day)
    h (hour 12)
    H (hour 24)
    m (minute)
    s (second)
    f (second fraction)
    F (second fraction, trailing zeroes are trimmed)
    t (P.M or A.M)
    z (time zone).
    <pre><code>
  var year = String.Format("{0:y yy yyy yyyy}", dt); // "16 16 2016 2016" year
  var month = String.Format("{0:M MM MMM MMMM}", dt); // "8 08 Aug August" month
  var day = String.Format("{0:d dd ddd dddd}", dt); // "1 01 Mon Monday" day
  var hour = String.Format("{0:h hh H HH}", dt); // "6 06 18 18" hour 12/24
  var minute = String.Format("{0:m mm}", dt); // "50 50" minute
  var secound = String.Format("{0:s ss}", dt); // "23 23" second
  var fraction = String.Format("{0:f ff fff ffff}", dt); // "2 23 230 2300" sec.fraction
  var fraction2 = String.Format("{0:F FF FFF FFFF}", dt); // "2 23 23 23" without zeroes
  var period = String.Format("{0:t tt}", dt); // "P PM" A.M. or P.M.
  var zone = String.Format("{0:z zz zzz}", dt); // "+0 +00 +00:00" time zone
 // You can use also date separator / (slash) and time sepatator : (colon)
</code></pre>
    <h3>AddDays(Double)</h3>
    <pre><code>
DateTime.AddDays(Double)
Add days into a dateTime object.
DateTime today = DateTime.Now;
DateTime answer = today.AddDays(36);
Console.WriteLine("Today: {0:dddd}", today);
Console.WriteLine("36 days from today: {0:dddd}", answer);

//You also can subtract days passing a negative value:
DateTime today = DateTime.Now;
DateTime answer = today.AddDays(-3);
Console.WriteLine("Today: {0:dddd}", today);
Console.WriteLine("-3 days from today: {0:dddd}", answer);
</code></pre>
    <h3>AddHours(Double)</h3>
    <pre><code>
// DateTime.AddHours(Double)
double[] hours = {.08333, .16667, .25, .33333, .5, .66667, 1, 2,
29, 30, 31, 90, 365};
DateTime dateValue = new DateTime(2009, 3, 1, 12, 0, 0);
foreach (double hour in hours)
  Console.WriteLine("{0} + {1} hour(s) = {2}", dateValue, hour,dateValue.AddHours(hour));
</code></pre>
    <h3>Parse(String)</h3>
    <pre><code>
// Converts the string representation of a date and time to its DateTime equivalent
var dateTime = DateTime.Parse("14:23 22 Jul 2016");
Console.WriteLine(dateTime.ToString());
</code>
</pre>
    <h3>TryParse(String, DateTime)</h3>
    <pre><code>
  // Converts the specified string representation of a date and time to its DateTime equivalent and
  returns a value that indicates whether the conversion succeeded
  string[] dateTimeStrings = new []{
    "14:23 22 Jul 2016",
    "99:23 2x Jul 2016",
    "22/7/2016 14:23:00"
  };
  foreach(var dateTimeString in dateTimeStrings){
    DateTime dateTime;
    bool wasParsed = DateTime.TryParse(dateTimeString, out dateTime);
    string result = dateTimeString +
    (wasParsed ? $"was parsed to {dateTime}"  : "can't be parsed to DateTime");
    Console.WriteLine(result);
  }
</code></pre>
    <h3>AddMilliseconds(Double)</h3>
    <pre><code>
    string dateFormat = "MM/dd/yyyy hh:mm:ss.fffffff";
    DateTime date1 = new DateTime(2010, 9, 8, 16, 0, 0);
    Console.WriteLine("Original date: {0} ({1:N0} ticks)\n",
    date1.ToString(dateFormat), date1.Ticks);

    DateTime date2 = date1.AddMilliseconds(1);
    Console.WriteLine("Second date: {0} ({1:N0} ticks)",
    date2.ToString(dateFormat), date2.Ticks);
    Console.WriteLine("Difference between dates: {0} ({1:N0} ticks)\n",
    date2 - date1, date2.Ticks - date1.Ticks);

    DateTime date3 = date1.AddMilliseconds(1.5);
    Console.WriteLine("Third date: {0} ({1:N0} ticks)",
    date3.ToString(dateFormat), date3.Ticks);
    Console.WriteLine("Difference between dates: {0} ({1:N0} ticks)",
    date3 - date1, date3.Ticks - date1.Ticks);
   </code></pre>
    <h3>Compare(DateTime t1, DateTime t2 )</h3>
    <pre><code>  
    DateTime date1 = new DateTime(2009, 8, 1, 0, 0, 0);
    DateTime date2 = new DateTime(2009, 8, 1, 12, 0, 0);
    int result = DateTime.Compare(date1, date2);
    string relationship;
    if (result < 0) 
      relationship="is earlier than" ; 
    else if (result==0) 
      relationship="is the same time as" ;
    else
      relationship="is later than" ;
    Console.WriteLine("{0} {1} {2}", date1, relationship, date2); 
    </code></pre>
    <h3>DaysInMonth(Int32, Int32)</h3>
    <pre><code>      
   const int July=7; 
   const int Feb=2; 

   int  daysInJuly=System.DateTime.DaysInMonth(2001, July); 
   Console.WriteLine(daysInJuly); 
   // daysInFeb gets 28 because the year 1998 was not a leap year. 
   
   int daysInFeb=System.DateTime.DaysInMonth(1998, Feb);
  Console.WriteLine(daysInFeb); 
  // daysInFebLeap gets 29 because the year 1996 was a leap year. 
  int daysInFebLeap=System.DateTime.DaysInMonth(1996, Feb); 
  Console.WriteLine(daysInFebLeap); 
    </code></pre>
    <h3>AddYears(Int32)</h3>
    Add years on the dateTime object
    <pre><code class="csharp">   
    baseDate = new DateTime(2000, 2, 29); 
    Console.WriteLine("Base Date: {0:d}\n", baseDate); 
    // Show dates of previous fifteen years. 
    for (int ctr=-1; ctr>= -15; ctr--)
        Console.WriteLine("{0,2} year(s) ago:{1:d}",Math.Abs(ctr), baseDate.AddYears(ctr));
    Console.WriteLine();    
    
    // Show dates of next fifteen years.
    for (int ctr = 1; ctr <= 15; ctr++) 
      Console.WriteLine("{0,2} year(s) from now: {1:d}", ctr, baseDate.AddYears(ctr));
    </code></pre>
    <h3>Pure functions warning when dealing with DateTime</h3>
    pure function is:
    1. The function always evaluates the same result value given the same argument value(s).
    The function result value cannot depend on any hidden information
    or state that may change while program execution proceeds or between different executions of the program,
    nor can it depend on any external input from I/O devices .

    2.Evaluation of the result does not cause any semantically observable side effect or output,
    such as mutation of mutable objects or output to I/O devices

    As a developer you need to be aware of pure methods and you will stumble upon these a lot in many areas.
    One I have seen that bites many junior developers is working with DateTime class methods.
    A lot of these are pure and if you are unaware of these you can be in for a suprise.
    An example:
    <pre><code>
     DateTime sample=new DateTime(2016, 12, 25); 
     sample.AddDays(1); 
     Console.WriteLine(sample.ToShortDateString()); 
     </code></pre>
    Given the example above one may expect the result printed to console to be '26/12/2016'
    but in reality you end up with the same date.
    This is because AddDays is a pure method and does not affect the original date.
    To get the expected output you would have to modify the AddDays call to the following:
    <cl>sample=sample.AddDays(1);</cl>

    <h3>TryParseExact(String, String, IFormatProvider, D ateTimeStyles, DateTime) </h3>
    - DateTime.Converts the specified string representation of a date and time
    to its DateTime equivalent using the specified format,culture-specific format information, and style.
    - The format of the string representation must match the specified format exactly.
    - The method returns a value that indicates whether the conversion succeeded.
    For Example
    <pre><code>
    CultureInfo enUS=new CultureInfo("en-US"); 
    string dateString; System.DateTime dateValue;
  
    //Parse date with no style flags.

    dateString=" 5/01/2009 8:30 AM" ;
    if (DateTime.TryParseExact(dateString, "g" ,enUS, DateTimeStyles.None, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    } else {
      Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    // Allow a leading space in the date string.
    if(DateTime.TryParseExact(dateString, "g" , enUS,DateTimeStyles.AllowLeadingWhite, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    //Use custom formats with M and MM.
    dateString="5/01/2009 09:00" ;
    if(DateTime.TryParseExact(dateString, "M/dd/yyyy hh:mm" , enUS, DateTimeStyles.None, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
      Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    // Allow a leading space in the date
    string. if(DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm" , enUS, DateTimeStyles.None, out dateValue)) {
    Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind); } else {
    Console.WriteLine("'{0}' is not in an acceptable format.", dateString); }

    //Parse a string with time zone information.
    dateString="05/01/2009 01:30:42 PM -05:00" ;
    if(DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm:ss tt zzz" ,
    enUS, DateTimeStyles.None, out dateValue)) {
    Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
    Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    // Allow a leading space in the date string.
    if (DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm:ss tt zzz" ,
    enUS, DateTimeStyles.AdjustToUniversal, out dateValue)) {
       Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    Parse a string represengting UTC.
    dateString="2008-06-11T16:11:20.0904778Z" ;
    if(DateTime.TryParseExact(dateString, "o" ,
    CultureInfo.InvariantCulture, DateTimeStyles.None, out dateValue)) {
        Console.WriteLine("Converted '{0}' to {1}({2}).", dateString, dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    if (DateTime.TryParseExact(dateString, "o" , CultureInfo.InvariantCulture,
    DateTimeStyles.RoundtripKind, out dateValue)) {
        Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    //Outputs ' 5/01/2009 8:30 AM' is not in an acceptable format.
    Converted ' 5/01/2009 8:30 AM' to 5/1/2009 8:30:00 AM(Unspecified).
    Converted '5/01/2009 09:00' to 5/1/2009 9:00:00 AM (Unspecified).
    '5/01/2009 09:00' is not in an acceptable format.
    Converted '05/01/2009 01:30:42 PM -05:00' to 5/1/2009 11:30:42 AM (Local).
    Converted '05/01/2009 01:30:42 PM -05:00' to 5/1/2009 6:30:42 PM (Utc).
    Converted '2008-06-11T16:11:20.0904778Z' to 6/11/2008 9:11:20 AM (Local).
    Converted '2008-06-11T16:11:20.0904778Z' to 6/11/2008 4:11:20 PM (Utc).
</code></pre>
    <h3>Add(TimeSpan)</h3>
    <pre><code>
    DateTime.Add(TimeSpan)
    // Calculate what day of the week is 36 days from this instant. 
    System.DateTime today=System.DateTime.Now; 
    System.TimeSpan duration=new System.TimeSpan(36, 0, 0, 0);
     System.DateTime answer=today.Add(duration); 
     System.Console.WriteLine("{0:dddd}", answer); 
     </code></pre>
    <h3>Parse and TryParse with culture info</h3>
    You might want to use it when parsing DateTimes from different cultures (languages),
    following example parses Dutch date.
    <pre><code>
  DateTime dateResult; 
    var dutchDateString="31 oktober 1999 04:20" ;
    var dutchCulture=CultureInfo.CreateSpecificCulture("nl-NL");
    DateTime.TryParse(dutchDateString, dutchCulture, styles, out dateResult); // output {31/10/1999 04:20:00} 
      //Example of Parse: 
    DateTime.Parse(dutchDateString, dutchCulture) // output {31/10/1999 04:20:00}  
    </code></pre>
    <h3> DateTime as initializer in for-loop</h3>
    <pre><code>
    // This iterates through a range between two DateTimes 
    // with the given iterator (any of the Add methods)
    
    DateTime start=new DateTime(2016, 01, 01); 
    DateTime until=new DateTime(2016, 02, 01); 
    // NOTICE: As the add methods return a new DateTime you have 
    // to overwrite dt in the iterator like dt=dt.Add() 
    for(DateTime dt=start; dt < until; dt=dt.AddDays(1)) { 
      Console.WriteLine("Added {0} days. Resulting DateTime: {1}", (dt
      - start).Days, dt.ToString()); 
    } 
    //Iterating on a TimeSpan works the same way. 
      
</code></pre>

    <h3> DateTime.ParseExact(String, String, IFormatProvider)</h3>
    Converts the specified string representation of a date and time to its DateTime equivalent using the specified
    format
    and culture-specific format information.
    The format of the string representation must match the specified format exactly.

    <b>Convert a specific format string to equivalent DateTime </b>
    Let's say we have a culture-specific DateTime string
    08-07-2016 11:30:12 PM as MM-dd-yyyy hh:mm:ss tt format and we want it to convert to equivalent DateTime object
    <pre><code>
 string str="08-07-2016 11:30:12 PM" ; 
 DateTime date=DateTime.ParseExact(str, "MM-dd-yyyy hh:mm:ss tt" , CultureInfo.CurrentCulture);
</code></pre>
    <b>Convert a date time string to equivalent DateTime object without any specific culture format</b>
    Let's say we have a DateTime string in dd-MM-yy hh:mm:ss tt format
    and we want it to convert to equivalent DateTime object, without any specific culture information
    <code>
string str="17-06-16 11:30:12 PM" ; 
DateTime date=DateTime.ParseExact(str, "dd-MM-yy hh:mm:ss tt" ,CultureInfo.InvariantCulture);   
</code>
    <b>Convert a date time string to equivalent DateTime object
      without any specific culture format with different format </b>

    Let's say we have a Date string , example like '23-12-2016' or '12/23/2016'
    and we want it to convert to equivalent DateTime object,
    without any specific culture information

    string date='23-12-2016' or date=12/23/2016';
    string[] formats=new string[] {"dd-MM-yyyy","MM/dd/yyyy"}; // even can add more possible formats.
    DateTime date=DateTime.ParseExact(date,formats, CultureInfo.InvariantCulture,DateTimeStyles.None);
    //NOTE : System.Globalization needs to be added for CultureInfo Class

    <h3>DateTime ToString, ToShortDateString,ToLongDateString and ToString formatted</h3>
    <pre><code>
 using System; public class Program { 
    public static void Main() {
      var date=new DateTime(2016,12,31); 
      Console.WriteLine(date.ToString()); 
      //Outputs: 12/31/2016 12:00:00 AM
      Console.WriteLine(date.ToShortDateString()); //Outputs: 12/31/2016 
      Console.WriteLine(date.ToLongDateString());//Outputs: Saturday, December 31, 2016 
      Console.WriteLine(date.ToString("dd/MM/yyyy")); //Outputs: 31/12/2016
    }
   }
  </code></pre>
    <h3>Current Date</h3>
    To get the current date you use the DateTime.Today property.
    This returns a DateTime object with today's date.
    When this is then converted .ToString() it is done so in your system's locality by default.
    For example:

    Console.WriteLine(DateTime.Today);

    Writes today's date, in your local format to the console.
  </div>
<h2>Arrays</h2>
  <div>
  <pre><code>
// Array Defenition :

int[] arr = new int[10];

// initializing using collection initialization syntax:
int[] arr = new int[] { 24, 2, 13, 47, 45 };
int[] arr = new int[3] {7,9,4};
Console.WriteLine(arr[0]); //outputs 7
Console.WriteLine(arr[1]); //outputs 9

int[] arr = null; // OK, declares a null reference to an array.
int first = arr[0]; // Throws System.NullReferenceException because there is no actual array.

// The new int[] portion can be omitted 
int[] arr = { 24, 2, 13, 47, 45 }; // OK

// This is not a self-contained expression, so
// using it as part of a different call does not work (for that, use the version with new):
int[] arr1;
arr1 = { 24, 2, 13, 47, 45 }; // Won't compile

// Implicitly typed arrays :

// In combination with the var keyword, the specific type may be omitted so that the type of the array is inferred:

// same as int[]
var arr = new [] { 1, 2, 3 };

// same as string[]
var arr = new [] { "one", "two", "three" };

// same as double[]
var arr = new [] { 1.0, 2.0, 3.0 };

// To create an array initialized with a non-default value:

int[] arr = new int[10];
//1. To create a bool array of size 10 filled with "true"
bool[] booleanArray = Enumerable.Repeat(true, 10).ToArray();

//2. To create an int array of size 5 filled with "100"
int[] intArray = Enumerable.Repeat(100, 5).ToArray();

//3. To create a string array of size 5 filled with "C#"
string[] strArray = Enumerable.Repeat("C#", 5).ToArray();

</code></pre>
<h3>Multidimensional Arrays</h3>
<pre><code>
int[, , , ,] arr5d; // five-dimensional array

int[,] arr2d = new int[3,2]{    {1, 2},  {3, 4}, {5, 6}   };
// or 
int[,] arr2d = {     {1, 2},   {3, 4},  {5, 6}    };
</code></pre>
<h3>Jagged Arrays: An Array of Array</h3>
<pre><code>
int[][] jArray = new int[2][]; 
jArray[0] = new int[3]{1, 2, 3};
jArray[1] = new int[4]{4, 5, 6, 7 };
</code></pre>
<h3>Copying arrays</h3>
<b>Array.Copy() </b>:
<pre><code>
var sourceArray = new int[] { 11, 12, 3, 5, 2, 9, 28, 17 };
var destinationArray= new int[3];
Array.Copy(sourceArray, destinationArray, 3);// destinationArray will have 11,12 and 3
</code></pre>
CopyTo() 
<pre><code>
//beginning at index 0 of the source and the specified index in the destination:
var sourceArray = new int[] { 11, 12, 7 };
var destinationArray = new int[6];
sourceArray.CopyTo(destinationArray, 2);
// destinationArray will have 0, 0, 11, 12, 7 and 0

//Clone is used to create a copy of an array object:

var sourceArray = new int[] { 11, 12, 7 };
var destinationArray = (int)sourceArray.Clone();
//destinationArray will be created and will have 11,12,17.  
</code></pre>
Both CopyTo and Clone perform shallow copy.
<b>shallow copy</b> means the contents contains references to the same object as the elements in the original array.
<h3>Comparing arrays for equality</h3>
<pre><code>
//SequenceEqual() :
int[] arr1 = { 3, 5, 7 };
int[] arr2 = { 3, 5, 7 };
bool result = arr1.SequenceEqual(arr2);
Console.WriteLine("Arrays equal? {0}", result);//prints: Arrays equal? True
</code></pre>
<h3>Multi-dimensional arrays</h3>
<pre><code>
  int[,] arr = new int[10, 10];
  int[,,] arr = new int[10, 10, 10];

 // You can also initialize the array upon declaration:
  int[,] arr = new int[4, 2] { {1, 1}, {2, 2}, {3, 3}, {4, 4} };
  Console.Out.WriteLine(arr[3, 1]); // 4  
</code></pre>
  <h3>Getting and setting array values</h3>
  <pre><code>
  int[] arr = new int[] { 0, 10, 20, 30};
  // Get
  Console.WriteLine(arr[2]); // 20

  // Set
  arr[2] = 100;
  Console.WriteLine(arr[2]); // 100
</code></pre>
<h3>Iterate over an array</h3>
<pre><code>
int[] arr = new int[] {1, 6, 3, 3, 9};
for (int i = 0; i < arr.Length; i++)
{
  Console.WriteLine(arr[i]);
}
// using foreach:
foreach (int element in arr)
{
  Console.WriteLine(element);
}

// using unsafe access with pointers 
unsafe
{
  int length = arr.Length;
  fixed (int* p = arr)
  {
    int* pInt = p;
    while (length-- > 0)
    {
      Console.WriteLine(*pInt);
      pInt++;// move pointer to next element
    }
  }
}
/*
Output:
1
6
3
3
9 */
</code></pre>
<h3>Enumerable.Range : Creating an array of sequential numbers</h3>
<pre><code>
int[] sequence = Enumerable.Range(1, 100).ToArray();
int[] squares = Enumerable.Range(2, 10).Select(  x => x * x ).ToArray();// 4 9 16 25 36 49 64 81 100 121
</code></pre>
<h3>Arrays as IEnumerable<> instances</h3>
- All arrays implement the non-generic <strong>IList</strong> interface.
(and hence non-generic <strong>ICollection</strong> and <strong>IEnumerable</strong> base interfaces).
- one-dimensional arrays implement the <strong>IList<></strong> and <strong>IReadOnlyList<></strong> generic interfaces.
(and their base interfaces) for the type of data that they contain.
This means that they can be treated as generic enumerable types
and passed in to a variety of methods without needing to first convert them to a non-array form.
<pre><code>
int[] arr1 = { 3, 5, 7 };
IEnumerable<int> enumerableIntegers = arr1; //Allowed because arrays implement IEnumerable<T>
List<int> listOfIntegers = new List<int>();
listOfIntegers.AddRange(arr1); //You can pass in a reference to an array to populate a List.
// the listOfIntegers will contain a List<int> containing the values 3, 5, and 7.
</code></pre>
 The IEnumerable<> support means arrays can be queried with LINQ, for example:
 <pre><code>arr1.Select(i => 10 * i)</code></pre> 
</div>
<h2>O(n) Algorithm, for circular rotation of an array</h2>
<div>
<h3>Example of a generic method that rotates an array by a given shift</h3>
<pre><code>
  public static void Main() {
    int[] array = {1,2,3,4,5,6,7,8,9,10};
    int shiftCount = 1;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    array = new[] {1,2,3,4,5,6,7,8, 9,10 };
    shiftCount = 15;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]

    array = new[] { 1,2,3,4,5,6,7,8,9,10};
    shiftCount = -1;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [2, 3, 4, 5, 6, 7, 8, 9, 10, 1]

    array = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    shiftCount = -35;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]
  }
  private static void Rotate < T > (ref T[] array, int shiftCount) {
    T[] backupArray = new T[array.Length];
    for (int index = 0; index < array.Length; index++) {
      backupArray[(index + array.Length + shiftCount % array.Length) % array.Length] = array[index];
    }
    array = backupArray;
  }
</code></pre>
</div>
<h2>Enum</h2>
<div>
<h3>Enum basics</h3>
- A type to define a set of named integral constants that may be assigned to a variable.
- An enum is a type that only allows a set of finite options,and each option corresponds to a number.
  By default, those numbers are increasing in the order the values are declared, starting from <b>zero</b>.
  
  For example:
<pre><code>
public enum Day
{
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
  Sunday
}
// usage :
Day myFavoriteDay = Day.Friday;
Day myLeastFavoriteDay = Day.Monday;
// Get the int that corresponds to myFavoriteDay
int myFavoriteDayIndex = (int)myFavoriteDay; //// Friday is number 4
Day dayFive = (Day)5;  //// Get the day that represents number 5

/* By default the underlying type of each element in the enum is int, 
but byte, sbyte, short, ushort, uint, long and ulong can be used as well. 
If you use a type other than int, you must specify the type using a colon after the enum name: */

public enum Weekday : byte { Monday = 1, Tuesday = 2, Wednesday = 3, Thursday = 4, Friday = 5 }
// The numbers after the name are now bytes instead of integers. 
//You could get the underlying type of the enum as  follows:
Enum.GetUnderlyingType(typeof(Days)));//Output:System.Byte  
/*
This is useful when Invoking to native code, mapping to data sources, and similar circumstances.
In general, the default int should be used, because most developers expect an enum to be an int.
*/
</code></pre>
<h3>Enum as flags</h3>
The <b>Flags</b> Attribute can be applied to an enum 
changing the behaviour of the ToString() to match the nature of the enum:
<pre><code>
 [Flags]
  enum MyEnum
  {
    //None = 0, can be used but not combined in bitwise operations
    FlagA = 1,
    FlagB = 2,
    FlagC = 4,
    FlagD = 8
    //you must use powers of two or combinations of powers of two
    //for bitwise operations to work
  }
  var twoFlags = MyEnum.FlagA | MyEnum.FlagB; 
  Console.WriteLine(twoFlags);// output : "FlagA, FlagB".
</code></pre>
- Because Flags Attribute relies on the enumeration constants to be powers of two (or their combinations)
and enum values are ultimately numeric values, you are limited by the size of the underlying numeric type.

- The largest available numeric type that you can use is UInt64,
which allows you to specify 64 distinct (non-combined) flag enum constants.

- The enum keyword defaults to the underlying type int, which is Int32.
- The compiler will allow the declaration of values wider than 32 bit.
- Those will wrap around without a warning and result in two or more enum members of the same value.
  Therefore, if an enum is meant to accomodate a bitset of more than 32 flags,
  you need to specify a bigger type explicitely:
<pre><code>
  public enum BigEnum : ulong
  {
    BigValue = 1 << 63
  }
  //  Although flags are often only a single bit, they can be combined into named "sets" for easier use.
  [Flags]
  enum FlagsEnum
  {
    None = 0,
    Option1 = 1,
    Option2 = 2,
    Option3 = 4,
    Default = Option1 | Option3,
    All = Option1 | Option2 | Option3,
  }
  //To avoid spelling out the decimal values of powers of two, 
  the left-shift operator (<<) can also be used to declare the same enum
  [Flags]
  enum FlagsEnum
  {
    None = 0,
    Option1 = 1 << 0,
    Option2 = 1 << 1,
    Option3 = 1 << 2,
    Default = Option1 | Option3,
    All = Option1 | Option2 | Option3,
  }  
 </code></pre>
- Starting with C# 7.0, binary literals can be used too.
- To check if the value of enum variable has a certain flag set,the HasFlag method can be used:
<pre><code>
[Flags]
enum MyEnum
{
  One = 1,
  Two = 2,
  Three = 4
}
//  And a value
var value = MyEnum.One | MyEnum.Two;
//With HasFlag we can check if any of the flags is set
if(value.HasFlag(MyEnum.One))
    Console.WriteLine("Enum has One");
if(value.HasFlag(MyEnum.Two))
    Console.WriteLine("Enum has Two");
if(value.HasFlag(MyEnum.Three))
    Console.WriteLine("Enum has Three");
//Also we can iterate through all values of enum to get all flags that are set
var type = typeof(MyEnum);
var names = Enum.GetNames(type);
foreach (var name in names)
{
    var item = (MyEnum)Enum.Parse(type, name);
    if (value.HasFlag(item))
      Console.WriteLine("Enum has " + name);
}

// Or
foreach(MyEnum flagToCheck in Enum.GetValues(typeof(MyEnum)))
{
    if(value.HasFlag(flagToCheck))
    {
      Console.WriteLine("Enum has " + flagToCheck);
    }
}

/*All three examples will print:
  Enum has One
  Enum has Two*/   
</code></pre>
<h3>Using << notation for flags </h3>
The left-shift operator (<<) can be used in flag enum declarations 
to ensure that each flag has exactly one 1 in binary representation, as flags should. 
        
This also helps to improve readability of large enums with plenty of flags in them. 
<pre><code>
[Flags] 
public enum MyEnum {
  None=0, Flag1=1 << 0, Flag2=1 << 1, Flag3=1 << 2, Flag4=1 << 3,
  Flag5=1 << 4, ... Flag31=1 << 30 
} 
</code></pre>          
It is obvious now that MyEnum contains proper flags only 
and not any messy stuff like Flag30=1073741822 (or 111111111111111111111111111110 in binary) which is inappropriate. 
  
<h3>Test flags-style enum values with bitwise logic </h3>
 A flags-style enum value needs to be tested with bitwise logic because it may not match any single value. 
 <pre><code>
 [Flags] 
 enum FlagsEnum {
   Option1=1, Option2=2, Option3=4,Option2And3=Option2 | Option3; Default=Option1 | Option3, 
} 
 </code></pre>

The Default value is actually a combination of two others merged with a bitwise OR. 
Therefore to test for the presence of a flag we need to use a bitwise AND.
<pre><code>
var value=FlagsEnum.Default; 
bool isOption2And3Set=(value & FlagsEnum.Option2And3)==FlagsEnum.Option2And3; 
Assert.True(isOption2And3Set);  
</code></pre>
<h3> Add and remove values from flagged enum </h3>
This code is to add and remove a value from a flagged enum-instance: 
<pre><code>
[Flags] 
public  enum MyEnum { Flag1=1 << 0, Flag2=1 << 1, Flag3=1 << 2 } 
var value=MyEnum.Flag1; // set additional value value
          |=MyEnum.Flag2; //value is now Flag1, Flag2 value 
          |=MyEnum.Flag3; //value is now Flag1, Flag2, Flag3 // remove
          flag value &=~MyEnum.Flag2; //value is now Flag1, Flag3   
</code></pre>
 <h3>Enum to string and back public enum</h3>
 <pre><code>
  DayOfWeek { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } // Enum to string string
  thursday=DayOfWeek.Thursday.ToString(); // "Thursday" 
  string seventhDay=Enum.GetName(typeof(DayOfWeek), 6);
  // "Saturday" string monday=Enum.GetName(typeof(DayOfWeek), DayOfWeek.Monday); // "Monday" 
  // String to enum (.NET 4.0+ only - see below for alternative syntax for earlier .NET versions) 
  DayOfWeek tuesday;
  Enum.TryParse("Tuesday", out tuesday); // DayOfWeek.Tuesday 
  DayOfWeek sunday; 
  bool matchFound1=Enum.TryParse("SUNDAY", out sunday); // Returns false (case-sensitive match) 
  DayOfWeek wednesday;
  bool matchFound2=Enum.TryParse("WEDNESDAY", true, out wednesday); 
  // Returns true; DayOfWeek.Wednesday (case-insensitive match) // String to enum (all .NET versions) 
  DayOfWeek friday=(DayOfWeek)Enum.Parse(typeof(DayOfWeek), "Friday" ); // DayOfWeek.Friday DayOfWeek
  caturday=(DayOfWeek)Enum.Parse(typeof(DayOfWeek), "Caturady" ); // Thows ArgumentException // All names of an
  enum type as strings string[] weekdays=Enum.GetNames(typeof(DayOfWeek)); 
 </code></pre>
<h3>Enums can have unexpected values </h3>
 Since an enum can be cast to and from its underlying integral type,
  the value may fall outside the range of values given in the definition of the enum type. 
  
  Although the below enum type DaysOfWeek only has 7 defined values, it can still hold any int value. 
  <pre><code>
public enum DaysOfWeek {
   Monday=1, Tuesday=2,Wednesday=3, Thursday=4, Friday=5, Saturday=6, Sunday=7 
} 
DaysOfWeek d=(DaysOfWeek)31; Console.WriteLine(d);
// prints 31 DaysOFWeek
s=DaysOfWeek.Sunday; s++; 
// No error There is currently no way to define an enum which does not have this behavior. 
// However, undefined enum values can be detected by using the method Enum.IsDefined. 
// For example, DaysOfWeek d=(DaysOfWeek)31;
Console.WriteLine(Enum.IsDefined(typeof(DaysOfWeek),d)); 
// prints False 
</code></pre>  
<h3> Default value for enum==ZERO </h3>
The default value for an enum is zero. 
If an enum does not define an item with a value of zero, its default value will be zero. 
<pre><code>
public class Program { enum EnumExample { one=1, two=2 } 
public void Main() { 
  var e=default(EnumExample); 
  if (e==EnumExample.one) 
    Console.WriteLine("defaults to one");   
  else Console.WriteLine("Unknown"); } } 
  Example: https://dotnetfiddle.net/l5Rwie  
</code></pre>
<h3>Adding additional description information to an enum value </h3>
In some cases you might want to add an additional description to an enum value,
for instance when the enum value itself is less readable than what you might want to display to the user.

In such cases you can use the  <cle>System.ComponentModel.DescriptionAttribute class</cle> 

For example:
<pre><code>
public enum PossibleResults {
          [Description("Success")] 
          OK=1, 
          [Description("File not found")] 
          FileNotFound=2, 
          [Description("Access denied")]
          AccessDenied=3 
        } 
</code></pre>
Now, if you would like to return the description of a specific enum value you can do the following: 
<pre><code>
public static string GetDescriptionAttribute(PossibleResults result) {
   return
          ((DescriptionAttribute)Attribute.GetCustomAttribute((result.GetType().GetField(result.ToString())),
          typeof(DescriptionAttribute))).Description; 
}
static void Main(string[] args) { P
  ossibleResults  result=PossibleResults.FileNotFound; 
  Console.WriteLine(result); // Prints "FileNotFound"
  Console.WriteLine(GetDescriptionAttribute(result)); // Prints "File not found" 
}
</code></pre>
This can also be easily transformed to an extension method for all enums: 
<pre><code>
static class EnumExtensions { 
  public static string GetDescription(this Enum enumValue) { 
    return
          ((DescriptionAttribute)Attribute.GetCustomAttribute(
            (enumValue.GetType().GetField(enumValue.ToStrin g())),
          typeof(DescriptionAttribute))).Description; } 
}
</code></pre>

And then easily used like this:
 <pre><code>Console.WriteLine(result.GetDescription()); </code></pre>         
          
<h3>  Get all the members values of an enum</h3>  
<pre><code>
enum MyEnum { One, Two, Three } 
foreach(MyEnum e in Enum.GetValues(typeof(MyEnum))) 
  Console.WriteLine(e); //This will print: One Two Three   
</code></pre>   

<h3>Bitwise Manipulation using enums </h3>
- The FlagsAttribute should be used whenever the enumerable represents a collection of flags, rather than a single value. 
- The numeric value assigned to each enum value helps when manipulating enums using bitwise operators.
<pre><code>
 //Example 1 : With [Flags] 
 [Flags] 
 enum Colors { Red=1, Blue=2, Green=4, Yellow=8 } 
 var color=Colors.Red | Colors.Blue; 
 Console.WriteLine(color.ToString()); 
 prints Red,Blue 
 
 //Example 2 : Without [Flags] 
 enum Colors { Red=1, Blue=2, Green=4, Yellow=8 } 
 var color=Colors.Red | Colors.Blue;
  Console.WriteLine(color.ToString()); prints 3 
</code></pre>
</div>
<h2>Tuples</h2>
<div>
<h3>Accessing tuple elements</h3>
To access tuple elements use <b>Item1-Item8</b> properties. 

<pre><code>
var tuple = new Tuple<string, int, bool, MyClass>("foo", 123, true, new MyClass());
var item1 = tuple.Item1; // "foo"
var item2 = tuple.Item2; // 123
var item3 = tuple.Item3; // true
var item4 = tuple.Item4; // new My Class()   

// Only the properties with index number less or equal to tuple size are going to be available 
var item5 = tuple.Item5; // Invalid
</code></pre>

<h3>Creating tuples</h3>
Tuples are created using generic types Tuple< T1>-Tuple< T1,T2,T3,T4,T5,T6,T7,T8>. 
Each of the types represents a tuple containing 1 to 8 elements. 
Elements can be of different types.
<pre><code>
// tuple with 4 elements
var tuple = new Tuple<string, int, bool, MyClass>("foo", 123, true, new MyClass());
</code></pre>
Tuples can also be created using <strong>static Tuple.Create</strong> methods. 
In this case, the types of the elements are inferred by the C# Compiler.
<pre><code>
// tuple with 4 elements
var tuple = Tuple.Create("foo", 123, true, new MyClass());  
</code></pre>
Version ≥ 7.0
Since C# 7.0, Tuples can be easily created using ValueTuple.
<pre><code>
var tuple = ("foo", 123, true, new MyClass());  
</code></pre>
Elements can be named for easier decomposition.
<pre><code>
 (int number, bool flag, MyClass instance) tuple = (123, true, new MyClass()); 
</code></pre>
<h3>Comparing and sorting Tuples</h3>
Tuples can be compared based on their elements.
As an example, an enumerable whose elements are of type Tuple can be sorted 
based on comparisons operators defined on a specified element
<pre><code>
list.Add(new Tuple<int, string>(2, "foo"));
list.Add(new Tuple<int, string>(1, "bar"));
list.Add(new Tuple<int, string>(3, "qux"));
list.Sort((a, b) => a.Item2.CompareTo(b.Item2)); //sort based on the string element
foreach (var element in list) {
    Console.WriteLine(element);
}
//(1, bar)
// (2, foo)
// (3, qux)

// Or to reverse the sort use:
//  list.Sort((a, b) => b.Item2.CompareTo(a.Item2));
  </code></pre>
<h3>Return multiple values from a method</h3>
Tuples can be used to return multiple values from a method without using out parameters. 
In the following example AddMultiply is used to return two values (sum, product).
<pre><code>
  void Write()
  {
    var result = AddMultiply(25, 28);
    Console.WriteLine(result.Item1);
    Console.WriteLine(result.Item2);
  }
  Tuple<int, int> AddMultiply(int a, int b)
  {
  return new Tuple<int, int>(a + b, a * b);
  }
  Output:
  53
  700</code></pre>
Now C# 7.0 offers an alternative way to return multiple values from methods 
using value tuples More info about ValueTuple struct.
  </div>
  <h2>Tuple literals</h2>
  <div>
  <pre><code>
  var bob = ("Bob", 23);    // Allow compiler to infer the element types
  Console.WriteLine (bob.Item1);   // Bob
  Console.WriteLine (bob.Item2);   // 23
  </code></pre>  
  </div>
  <h2>Guid</h2>
  <div>
    GUID (or UUID) is an acronym for 'Globally Unique Identifier' (or 'Universally Unique Identifier').
    It is a 128-bit integer number used to identify resources.
    <h3>Getting the string representation of a Guid</h3>
    A string representation of a Guid can be obtained by using the built in ToString method
    <cl>string myGuidString = myGuid.ToString();</cl>
    Depending on your needs you can also format the Guid,
    by adding a format type argument to the ToString call.
    <pre><code>var guid = new Guid("7febf16f-651b-43b0-a5e3-0da8da49e90d");
    // None "7febf16f651b43b0a5e30da8da49e90d"
    Console.WriteLine(guid.ToString("N"));
    // Hyphens "7febf16f-651b-43b0-a5e3-0da8da49e90d"
    Console.WriteLine(guid.ToString("D"));
    // Braces "{7febf16f-651b-43b0-a5e3-0da8da49e90d}"
    Console.WriteLine(guid.ToString("B"));
    // Parentheses "(7febf16f-651b-43b0-a5e3-0da8da49e90d)"
    Console.WriteLine(guid.ToString("P"));
    // Hex "{0x7febf16f,0x651b,0x43b0{0xa5,0xe3,0x0d,0xa8,0xda,0x49,0xe9,0x0d}}"
    Console.WriteLine(guid.ToString("X"));</code></pre>
    <h3>Creating a Guid</h3>
    These are the most common ways to create an instance of Guid:
    <pre><code>
   //Creating an empty guid (00000000-0000-0000-0000-000000000000):
    Guid g = Guid.Empty;
    Guid g2 = new Guid();

    //Creating a new (pseudorandom) Guid:
    Guid g = Guid.NewGuid();

    //Creating Guids with a specific value:
    Guid g = new Guid("0b214de7-8958-4956-8eed-28f9ba2c47c6");
    Guid g2 = new Guid("0b214de7895849568eed28f9ba2c47c6");
    Guid g3 = Guid.Parse("0b214de7-8958-4956-8eed-28f9ba2c47c6");      
    </code></pre>
 
    <h3>Declaring a nullable GUID</h3>
    Like other value types, GUID also has a nullable type which can take null value.
    <cl>Guid? myGuidVar = null;</cl>
    This is particularly useful when retrieving data from the data base
    when there is a possibility that value from a table is NULL.
</div>
<h2>BigInteger</h2>
<div>
<h3>Calculate the First 1,000-Digit Fibonacci Number</h3>
<pre><code> 
  using System;
  using System.Numerics;
  namespace Euler_25 {
      class Program {
          static void Main(string[] args) {
              BigInteger l1 = 1;
              BigInteger l2 = 1;
              BigInteger current = l1 + l2;
              while (current.ToString().Length < 1000) {
                  l2 = l1;
                  l1 = current;
                  current = l1 + l2;
              }
              Console.WriteLine(current);
          }
      }
    </code></pre>
  </div>

<h2>collections</h2>
  <div>
  <h3>Collection Initializers</h3>

  Initialize a collection type with values
  <pre><code>var stringList = new List< string>{ "foo", "bar", };

  //  Collection initializers are syntactic sugar for Add() calls.
  // Above code is equivalent to
  var temp = new List< string>();
  temp.Add("foo");
  temp.Add("bar");
  var stringList = temp;
  </code></pre>
  - Note that the intialization is done atomically using a temporary variable,to avoid race conditions.
  - For types that offer multiple parameters in their Add() method, enclose the comma-separated arguments in curly braces:
  <pre><code>
    var numberDictionary = new Dictionary < int,string > 
    {
      {
          1,
          "One"
      },
      {
          2,
          "Two"
      },
  };

  //This is equivalent to:
  var temp = new Dictionary<int, string>();
  temp.Add(1, "One");
  temp.Add(2, "Two");
  var numberDictionarynumberDictionary = temp;
  </code></pre>
  <h3>Index Initializers</h3>
  Starting with C# 6, 
  collections with indexers can be initialized by specifying the index to assign in square brackets,
  followed by an equals sign, followed by the value to assign.
  Dictionary Initialization
  An example of this syntax using a Dictionary:
  <pre><code>
  var dict = new Dictionary < string,int > {
        ["key1"] = 1,
        ["key2"] = 50
    };
  //This is equivalent to:
  var dict = new Dictionary < string, int > ();
  dict["key1"] = 1;
  dict["key2"] = 50

  //The collection initializer syntax to do this before C # 6 was:
  var dict = new Dictionary < string, int > {
              {
                  "key1",
                  1
              },
              {
                  "key2",
                  50
              }
          };
  //Which would correspond to:
  var dict = new Dictionary < string, int > ();
  dict.Add("key1", 1);
  dict.Add("key2", 50);
  </code></pre>
  example2:
  <pre><code>
  public class IndexableClass {
    public int this[int index] {
      set {
          Console.WriteLine("{0} was assigned to index {1}", value, index);
      }
    }
  }
  var foo = new IndexableClass {
      [0] = 10,
      [1] = 20
  }
  /*
  This would output:
  10 was assigned to index 0
  20 was assigned to index 1
  */
    </code></pre>
  <h3>Collection initializers in custom classes</h3>
  To make a class support collection initializers, 
  it must implement IEnumerable interface and have at least one Add method. 
  Since C# 6, any collection implementing IEnumerable can be extended with custom Add methods using extension methods.
  <pre><code>
  class Program
  {
    static void Main()
    {
    var col = new MyCollection {
      "foo",
      { "bar", 3 },  
      class Program {
        static void Main() {
            var col = new MyCollection {
                "foo",
                {
                    "bar",
                    3
                },
                "baz",
                123.45 d,
            };
        }
    }
  class MyCollection: IEnumerable {
      private IList list = new ArrayList();
      public void Add(string item) {
          list.Add(item)
      }
      public void Add(string item, int count) {
          for (int i = 0; i < count; i++) {
              list.Add(item);
          }
      }
      public IEnumerator GetEnumerator() {
          return list.GetEnumerator();
      }
  }
  static class MyCollectionExtensions {
      public static void Add(this MyCollection @this, double value) =>
          @this.Add(value.ToString());
  }
  </code></pre>
  <h3>Using collection initializer inside object initializer</h3>
  <pre><code>
    public class Tag {
      public IList < string > Synonyms {
          get;
          set;
      }
  }
  // Synonyms is a collection - type property.When the Tag object is created using object initializer syntax, 
  //Synonyms can also be initialized with collection initializer syntax:
Tag t = new Tag {
    Synonyms = new List < string > {
        "c#",
        "c-sharp"
    }
};
  // The collection property can be readonly and still support collection initializer syntax.Consider this modified
  example(Synonyms property now has a private setter):
  public class Tag {
      public Tag() {
          Synonyms = new List < string > ();
      } 
  public IList<string> Synonyms { get; private set; }
  }
  //    A new Tag object can be created like this:
      Tag t = new Tag
      {
      Synonyms = {"c#", "c-sharp"}
      };
  // This works because collection initializers are just syntatic sugar over calls to Add(). There's no new list being created
    // here, the compiler is just generating calls to Add() on the exiting object
  </code></pre>
  <h3>Collection Initializers with Parameter Arrays</h3>
  You can mix normal parameters and parameter arrays:
  <pre><code>
  public class LotteryTicket : IEnumerable{
      public int[] LuckyNumbers;
      public string UserName;
      public void Add(string userName, params int[] luckyNumbers){
        UserName = userName;
        Lottery = luckyNumbers;
      }
    }
  //This syntax is now possible:
  var Tickets = new List<LotteryTicket>{
      {"Mr Cool" , 35663, 35732, 12312, 75685},
      {"Bruce" , 26874, 66677, 24546, 36483, 46768, 24632, 24527},
      {"John Cena", 25446, 83356, 65536, 23783, 24567, 89337}
    }
  </code></pre>
    <h3>HashSet< T>
    </h3>
    This is a collection of unique items, with O(1) lookup.
    <pre><code>
    HashSet<int> validStoryPointValues = new HashSet<int>() { 1, 2, 3, 5, 8, 13, 21 };
    bool containsEight = validStoryPointValues.Contains(8); // O(1)
    
    // By way of comparison, doing a Contains on a List yields poorer performance:
    List<int> validStoryPointValues = new List<int>() { 1, 2, 3, 5, 8, 13, 21 };
    bool containsEight = validStoryPointValues.Contains(8); // O(n)

    //HashSet.Contains uses a hash table, so that lookups are extremely fast
   </code></pre>
    <h3>Dictionary< TKey, TValue>
    </h3>
    <b>Dictionary< TKey, TValue></TKey></b> is a map. 
    For a given key there can be one value in the dictionary
    <pre><code>
      using System.Collections.Generic;
      var people = new Dictionary < string, int > {
              {  "John",   30     },
              { "Mary",    35     },
              { "Jack",   40      }
          };
      // Reading data :
      Console.WriteLine(people["John"]); // 30
      Console.WriteLine(people["George"]); // throws KeyNotFoundException
      int age;
      if (people.TryGetValue("Mary", out age)) {
          Console.WriteLine(age); // 35
      }

      // Adding and changing data :
      people["John"] = 40;    // Overwriting values this way is ok
      people.Add("John", 40); // Throws ArgumentException since "John" already exists

      // Iterating through contents
      foreach(KeyValuePair < string, int > person in people) {
          Console.WriteLine("Name={0}, Age={1}", person.Key, person.Value);
      }
      foreach(string name in people.Keys) {
          Console.WriteLine("Name={0}", name);
      }
      foreach(int age in people.Values) {
          Console.WriteLine("Age={0}", age);
      }
      var people = new Dictionary < string, int > {
              { "John",   30              },
              {"Mary",    35              },
              {"Jack",    40              },
              {"Jack",    40              }
     }; // throws ArgumentException since "Jack" already exists 
    </code></pre>
      <h3>SortedSet< T>
      </h3>
      <pre><code>
      // create an empty set
      var mySet = new SortedSet<int>();

      // add something
      // note that we add 2 before we add 1
      mySet.Add(2);
      mySet.Add(1);

      // enumerate through the set
      foreach(var item in mySet)
      {
        Console.WriteLine(item);
      }
      // output:
      // 1
      // 2
    </code></pre>
      <h3>T[ ] (Array of T)</h3>
      <pre><code>
      var myArray = new [] {
        "one",
        "two"
    };
    // enumerate through the array
    foreach(var item in myArray) {
        Console.WriteLine(item);
    }
    // output:
    // one
    // two

    // exchange the element on the first position
    myArray[0] = "something else";

    // enumerate through the array again
    foreach(var item in myArray) {
        Console.WriteLine(item);
    }
    // output:
    // something else
    // two
    </code></pre>
      <h3>List< T>
      </h3>
      List< T> is a list of a given type. 
      Items can be added, inserted, removed and addressed by index.
    <pre><code>
    using System.Collections.Generic;
    var list = new List<int>() { 1, 2, 3, 4, 5 };
    list.Add(6);
    Console.WriteLine(list.Count); // 6
    list.RemoveAt(3);
    Console.WriteLine(list.Count); // 5
    Console.WriteLine(list[3]); // 5
    </code></pre>
- List< T> can be thought of as an array that you can resize.
- Enumerating over the collection in order is quick, as is access to individual elements via their index.
- To access elements based on some aspect of their value, 
  or some other key, a Dictionary< T> will provide faster lookup.
<h3>Stack < T> </h3>
elements are stored with "first in, last out" order.
<pre><code>
// Initialize a stack object of integers
var stack = new Stack<int>();

// add some data
stack.Push(3);
stack.Push(5);
stack.Push(8);

// stack from top to bottom is: 8, 5, 3
// We can use peek to see the top element of the stack.
Console.WriteLine(stack.Peek()); // prints 8

// Pop removes the top element of the stack and returns it.
Console.WriteLine(stack.Pop()); // prints 8
Console.WriteLine(stack.Pop()); // prints 5
Console.WriteLine(stack.Pop()); // prints 3 
</code></pre>
<h3>LinkedList< T></h3> 
Note that LinkedList< T> represents the doubly linked list.
So, it's simply collection of nodes and each node
contains an element of type T.
Each node is linked to the preceding node and the following node
<pre><code>
  // initialize a LinkedList of integers
  LinkedList list = new LinkedList<int>();
  // add some numbers to our list.
  list.AddLast(3);
  list.AddLast(5);
  list.AddLast(8);
  // the list currently is 3, 5, 8
  list.AddFirst(2);
  // the list now is 2, 3, 5, 8
  list.RemoveFirst();
  // the list is now 3, 5, 8
  list.RemoveLast();
  // the list is now 3, 5
</code></pre>
           
<h3>Queue</h3>
<pre><code>
// Initalize a new queue of integers
var queue = new Queue<int>();
// Add some data
queue.Enqueue(6);
queue.Enqueue(4);
queue.Enqueue(9);
// Elements in a queue are stored in "first in, first out" order.
// The queue from first to last is: 6, 4, 9
// View the next element in the queue, without removing it.
Console.WriteLine(queue.Peek()); // prints 6
// Removes the first element in the queue, and returns it.
Console.WriteLine(queue.Dequeue()); // prints 6
Console.WriteLine(queue.Dequeue()); // prints 4
Console.WriteLine(queue.Dequeue()); // prints 9
</code></pre>
</div>

<h2>Looping</h2>
<div>
<h3>For Loop</h3>
<pre><code>
  for (int i = 0; i < 5; i++)
  {
    Console.WriteLine(i);
  }// output: 01234
</code></pre>
<h3>Do - While Loop</h3>
<pre><code>
  int[] numbers = new int[] { 6, 7, 8, 10 };
  int sum = 0;
  int i = 0;
  do
  {
    sum += numbers[i];
    i++;
  } while (sum <= 10 && i < numbers.Length);
  System.Console.WriteLine(sum); // 13
</code></pre>
<h3>Foreach Loop</h3>
- will iterate over any object of a class that implements <b>IEnumerable</b> 
- Such objects include some built-in ones, but not limit to: 
  <cl>List< T >, T[] (arrays of any type), Dictionary< TKey, TSource>, </cl>
  as well as interfaces like IQueryable and ICollection, etc.
<pre><code>
  var list = new List<string>();
  list.Add("Ion");
  list.Add("Andrei");
  foreach(var name in list)
  {
    Console.WriteLine("Hello " + name);
  }
    
  //is equivalent to:
  var list = new List<string>();
  list.Add("Ion");
  list.Add("Andrei");
  IEnumerator enumerator;
  try
  {
    enumerator = list.GetEnumerator();
    while (enumerator.MoveNext())
    {
      string name = (string)enumerator.Current;
      Console.WriteLine("Hello " + name);
    }
  }
  finally
  {
    if (enumerator != null)
      enumerator.Dispose();
  }
  </code></pre>
<h3>Foreach Method</h3>
<pre><code>
list.ForEach(item => item.DoSomething());
// or
list.ForEach(item => DoSomething(item));
// or using a method group
list.ForEach(Console.WriteLine);
// using an array
Array.ForEach(myArray, Console.WriteLine); 
</code></pre>
<h3>Linq Parallel Foreach</h3>
Just like Linq Foreach, except this one does the job in a parallel manner. 
Meaning that
all the items in the collection will run the given action <strog>at the same time</strog>, simultaneously.    
<pre><code>
collection.AsParallel().ForAll(item => item.DoSomething());
/// or
collection.AsParallel().ForAll(item => DoSomething(item));
</code></pre>
  <h3>continue</h3>
  Instead of breaking completely the loop, it will simply skip the current iteration. 
  
  <pre><code>
    for (int i = 1; i <= 10; i++)
    {
      if (i < 9)
        continue;
      Console.Write(i);  
    }//output 910
  </code></pre>
  <h3>IEnumrator</h3>
  <pre><code>
    // gets a list of strings with the names of the largest city metro areas:
    IEnumerator<string> largestMetroAreas = GetLargestMetroAreas(4);
    while (largestMetroAreas.MoveNext())
    {
      Console.WriteLine(largestMetroAreas.Current);
    }
 /* output:
    Tokyo / Yokohama
    New York Metro
    Sao Paulo
    Seoul / Incheon */
  </code></pre>
  </div>

<h2>Iterators</h2>
<div>
  
<h3>Creating Iterators Using Yield</h3>
- Iterators produce enumerators. 
- an iterator is a producer of an enumerator:
<pre><code>
foreach (int fib in Fibs(6))
  Console.Write (fib + "  ");

IEnumerable< int > Fibs (int fibCount)
{
  for (int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)
  {
    yield return prevFib;
    int newFib = prevFib+curFib;
    prevFib = curFib;
    curFib = newFib;
  }
}    
</code></pre>   
- enumerators are produced by defining methods, properties or indexers that contain yield statements.

- Most methods will return control to their caller through normal return statements,
which disposes all state local to that method. 
  In contrast, methods that use <b>yield</b> statements,
   allow them to return multiple values to the caller on request 
   while preserving local state in-between returning those values. 
- These returned values constitute a sequence. 

- There are two types of yield statements used within iterators:
  - <b>yield return</b>, which returns control to the caller but preserves state. 
    The callee will continue execution from this line when control is passed back to it.
  - <b>yield break</b>, which functions similarly to a normal return statement - this signifies the end of the sequence.
  Normal return statements themselves are illegal within an iterator block.
This example below demonstrates an iterator method that can be used to generate the Fibonacci sequence:
<pre><code>
IEnumerable<int> Fibonacci(int count)
  {
    int prev = 1;
    int curr = 1;
    for (int i = 0; i < count; i++)
    {
      yield return prev;
      int temp = prev + curr;
      prev = curr;
      curr = temp;
    }
  }
  // This iterator can then be used to produce an enumerator of the Fibonacci sequence 
  // that can be consumed by a calling method. 
  // The code below demonstrates how the first ten terms within the Fibonacci sequence can be enumerated:
  void Main()
  {
    foreach (int term in Fibonacci(10))
    {
      Console.Write(term);
      Console.Write(' ');
    }
  }
  // Output: 1 1 2 3 5 8 13 21
</code></pre>
<h3>Simple Numeric Iterator Example</h3>
    A common use-case for iterators is to perform some operation over a collection of numbers.
    The example below demonstrates how each element within an array of numbers can be individually printed out to the console.
    This is possible because arrays implement the IEnumerable interface, 
    allowing clients to obtain an iterator for the array using the GetEnumerator() method. 
    This method returns an enumerator, which is a read-only, forward-only cursor over each number in the array.
    <pre><code>
      int[] numbers = { 1, 2, 3, 4, 5 };
      IEnumerator iterator = numbers.GetEnumerator();
      while (iterator.MoveNext())
      {
        Console.Write(iterator.Current);
        Console.Write('\t')
      }
      // Output:   1    2     3     4     5

      //It's also possible to achieve the same results using a foreach statement:
      foreach (int number in numbers)
      {
        Console.WriteLine(number);
      }
    </code></pre>

  </div>

<h2>IEnumerable</h2>
 <div> 
  - IEnumerable is the base interface for all non-generic collections like ArrayList that can be enumerated.
  - IEnumerator< T> is the base interface for all generic enumerators like List< >.
  - IEnumerable is an interface which implements the method GetEnumerator.
  - The GetEnumerator method returns an IEnumerator 
    which provides options to iterate through the collection like foreach.      
    <h3>IEnumerable with custom Enumerator</h3>
    - Implementing the IEnumerable interface allows classes to be enumerated in the same way as BCL collections.
    - This requires extending the Enumerator class which tracks the state of the enumeration.
    - Other than iterating over a standard collection, examples include:
      . Using ranges of numbers based on a function rather than a collection of objects
      . Implementing different iteration algorithms over collections, like DFS or BFS on a graph collection

    <pre><code>    
public static void Main(string[] args)
  {
    foreach (var coffee in new CoffeeCollection())
    {
      Console.WriteLine(coffee);
    }
  }
  
  public class CoffeeCollection : IEnumerable
  {
    private CoffeeEnumerator enumerator;
    public CoffeeCollection()
    {
      enumerator = new CoffeeEnumerator();
    }
    public IEnumerator GetEnumerator()
    {
      return enumerator;
    }
    public class CoffeeEnumerator : IEnumerator
    {
      string[] beverages = new string[3] { "espresso", "macchiato", "latte" };
      int currentIndex = -1;
      public object Current
      {
        get
        {
          return beverages[currentIndex];
        }
      }
      public bool MoveNext()
      {
        currentIndex++;
        if (currentIndex < beverages.Length)
        {
          return true;
        }
        return false;
      }
      public void Reset()
      {
        currentIndex = 0;
      }</code></pre>
<h3>IEnumerable< int></int></h3>
- In its most basic form, an object that implements IEnumerable represents a series of objects.
- The objects in  question can be iterated using the c# foreach keyword.
- In the example below, the object sequenceOfNumbers implements IEnumerable. It represents a series of integers.
- The foreach loop iterates through each in turn.
<pre><code>
  int AddNumbers(IEnumerable<int> sequenceOfNumbers) {
    int returnValue = 0;
    foreach(int i in sequenceOfNumbers) {
    returnValue += i;
    }
    return returnValue;
  }
</code></pre>

</div>

<h2>Value type vs Reference type</h2>
<div>

<h3>Passing by reference using ref keyword</h3>
  - arguments can be passed to parameters either by value or by reference.
  - Passing by reference enables function to change the value of the parameters 
    and have that change persist in the calling environment.
  - To pass a parameter by reference, use the<b> ref or out</b> keyword.
  - The difference between ref and out is that :
     out means that the passed parameter has to be assigned before the function ends.
    in contrast parameters passed with ref can be changed or left unchanged
<pre><code>
  using System;
  class Program
  {
    static void Main(string[] args)
    {
      int a = 20;
      Console.WriteLine("Inside Main - Before Callee: a = {0}", a);
      Callee(a);
      Console.WriteLine("Inside Main - After Callee: a = {0}", a);
      Console.WriteLine("Inside Main - Before CalleeRef: a = {0}", a);
      CalleeRef(ref a);
      Console.WriteLine("Inside Main - After CalleeRef: a = {0}", a);
      Console.WriteLine("Inside Main - Before CalleeOut: a = {0}", a);
      CalleeOut(out a);
      Console.WriteLine("Inside Main - After CalleeOut: a = {0}", a);
      Console.ReadLine();
    }
    static void Callee(int a)
    {
      a = 5;
      Console.WriteLine("Inside Callee a : {0}", a);
    }
    static void CalleeRef(ref int a)
    {
      a = 6;
      Console.WriteLine("Inside CalleeRef a : {0}", a);
    }
    static void CalleeOut(out int a)
    {
      a = 7;
      Console.WriteLine("Inside CalleeOut a : {0}", a);
    }
  }
  /*Output:

  Inside Main - Before Callee: a = 20
  Inside Callee a: 5
  Inside Main -After Callee: a = 20
  Inside Main -Before CalleeRef: a = 20
  Inside CalleeRef a: 6
  Inside Main -After CalleeRef: a = 6
  Inside Main -Before CalleeOut: a = 6
  Inside CalleeOut a: 7
  Inside Main -After CalleeOut: a = 7 */
</code></pre>  
<h3>Changing values elsewhere</h3>
<pre><code>
  public static void Main(string[] args)
  {
    var studentList = new List<Student>();
    studentList.Add(new Student("Scott", "Nuke"));
    studentList.Add(new Student("Vincent", "King"));
    studentList.Add(new Student("Craig", "Bertt"));
    // make a separate list to print out later
    var printingList = studentList; // this is a new list object, but holding the same student
    objects inside it
    // oops, we've noticed typos in the names, so we fix those
    studentList[0].LastName = "Duke";
    studentList[1].LastName = "Kong";
    studentList[2].LastName = "Brett";
    // okay, we now print the list
    PrintPrintingList(printingList);
  }
  private static void PrintPrintingList(List<Student> students)
  {
    foreach (Student student in students)
    {
      Console.WriteLine(string.Format("{0} {1}", student.FirstName, student.LastName));
    }
  }
</code></pre>
You'll notice that even though the printingList list was made before the corrections to student names after the
typos, the PrintPrintingList method still prints out the corrected names:
Scott Duke
Vincent Kong
Craig Brett
This is because both lists hold a list of references to the same students. SO changing the underlying student object
propogates to usages by either list.
Here's what the student class would look like.
<pre><code>
  public class Student
  {
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public Student(string firstName, string lastName)
    {
      this.FirstName = firstName;
      this.LastName = lastName;
    }
  }
</code></pre>
<h3>ref vs out parameters</h3>
<pre><code>
  class Program
  {
    static void Main(string[] args)
    {
      int a = 20;
      Console.WriteLine("Inside Main - Before Callee: a = {0}", a);
      Callee(a);
      Console.WriteLine("Inside Main - After Callee: a = {0}", a);
      Console.WriteLine();
      Console.WriteLine("Inside Main - Before CalleeRef: a = {0}", a);
      CalleeRef(ref a);
      Console.WriteLine("Inside Main - After CalleeRef: a = {0}", a);
      Console.WriteLine();
      Console.WriteLine("Inside Main - Before CalleeOut: a = {0}", a);
      CalleeOut(out a);
      Console.WriteLine("Inside Main - After CalleeOut: a = {0}", a);
      Console.ReadLine();
    }
    static void Callee(int a)
    {
      a += 5;
      Console.WriteLine("Inside Callee a : {0}", a);
    }
    static void CalleeRef(ref int a)
    {
      a += 10;
      Console.WriteLine("Inside CalleeRef a : {0}", a);
    }
    static void CalleeOut(out int a)
    {
      // can't use a+=15 since for this method 'a' is not intialized only declared in the method
      declaration
      a = 25; //has to be initialized
      Console.WriteLine("Inside CalleeOut a : {0}", a);
    }
  }
  Output
  Inside Main - Before Callee: a = 20
  Inside Callee a: 25
  Inside Main -After Callee: a = 20
  Inside Main -Before CalleeRef: a = 20
  Inside CalleeRef a: 30
  Inside Main -After CalleeRef: a = 30
  Inside Main - Before CalleeOut: a = 30
  Inside CalleeOut a: 25
  Inside Main -After CalleeOut: a = 25
</code></pre>
<h3>Assignment</h3>
<pre><code>
  var a = new List<int>();
    var b = a;
    a.Add(5);
    Console.WriteLine(a.Count); // prints 1
    Console.WriteLine(b.Count); // prints 1 as well

    Assigning to a variable of a List<int> does not create a copy of the List<int>. Instead, it copies the reference to
    the List<int>. We call types that behave this way reference types.
</code></pre>
<h3>Difference with method parameters ref and out</h3>
There are two possible ways to pass a value type by reference: ref and out. The difference is that by passing it with
ref the value must be initialized but not when passing it with out. Using out ensures that the variable has a value
after the method call:
<pre><code>
  public void ByRef(ref int value)
  {
    Console.WriteLine(nameof(ByRef) + value);
    value += 4;
    Console.WriteLine(nameof(ByRef) + value);
  }
  public void ByOut(out int value)
  {
    value += 4 // CS0269: Use of unassigned out parameter `value'
  Console.WriteLine(nameof(ByOut) + value); // CS0269: Use of unassigned out parameter `value'
    value = 4;
    Console.WriteLine(nameof(ByOut) + value);
  }
  public void TestOut()
  {
    int outValue1;
    ByOut(out outValue1); // prints 4
    int outValue2 = 10; // does not make any sense for out
    ByOut(out outValue2); // prints 4
  }
  public void TestRef()
  {
    int refValue1;
    ByRef(ref refValue1); // S0165 Use of unassigned local variable 'refValue'
    int refValue2 = 0;
    ByRef(ref refValue2); // prints 0 and 4
    int refValue3 = 10;
    ByRef(ref refValue3); // prints 10 and 14
  }
  The catch is that by using out the parameter must be initialized before leaving the method, therefore the following
  GoalKicker.com – C# Notes for Professionals 133
  method is possible with ref but not with out:
  public void EmtyRef(bool condition, ref int value)
  {
    if (condition)
    {
      value += 10;
    }
  }
  public void EmtyOut(bool condition, out int value)
  {
    if (condition)
    {
      value = 10;
    }
  } //CS0177: The out parameter 'value' must be assigned before control leaves the current method
</code></pre>
This is because if condition does not hold, value goes unassigned.
<h3>Passing by reference</h3>
If you want the Value Types vs Reference Types in methods example to work properly, use the ref keyword in your
method signature for the parameter you want to pass by reference, as well as when you call the method.
<pre><code>
  public static void Main(string[] args)
  {
    ...
  DoubleNumber(ref number); // calling code
    Console.WriteLine(number); // outputs 8
    ...
  }
  public void DoubleNumber(ref int number)
  {
    number += number;
  }
</code></pre>
Making these changes would make the number update as expected, meaning the console output for number would
be 8.

</div> 
<h2>Built-in Types</h2>
<div>
<h3>Conversion of boxed value types</h3>
  Boxed value types can only be unboxed into their original Type, even if a conversion of the two Types is valid, e.g.:
<pre><code>
  object boxedInt = (int)1; // int boxed in an object
  long unboxedInt1 = (long)boxedInt; // invalid cast
  This can be avoided by first unboxing into the original Type, e.g.:
  long unboxedInt2 = (long)(int)boxedInt; // valid
</code></pre>  
<h3>Comparisons with boxed value types</h3>
<pre><code>
  If value types are assigned to variables of type object they are boxed - the value is stored in an instance of a
  System.Object. This can lead to unintended consequences when comparing values with ==, e.g.:
  object left = (int)1; // int in an object box
  object right = (int)1; // int in an object box
  var comparison1 = left == right; // false
  This can be avoided by using the overloaded Equals method, which will give the expected result.
  var comparison2 = left.Equals(right); // true
  Alternatively, the same could be done by unboxing the left and right variables so that the int values are
  compared:
  var comparison3 = (int)left == (int)right; // true
</code></pre>
<h3>Immutable reference type - string</h3>
<pre><code>
  // assign string from a string literal
  string s = "hello";
  // assign string from an array of characters
  char[] chars = new char[] { 'h', 'e', 'l', 'l', 'o' };
  string s = new string(chars, 0, chars.Length);
  // assign string from a char pointer, derived from a string
  string s;
  unsafe
  {
    fixed (char* charPointer = "hello")
    {
      s = new string(charPointer);
    }
  }
</code></pre>
<h3>Value type - char</h3>
<pre><code>// single character s
  char c = 's';
  // character s: casted from integer value
  char c = (char)115;
  // unicode character: single character s
  char c = '\u0073';
  // unicode character: smiley</code></pre>
<h3>Value type - short, int, long (signed 16 bit, 32 bit, 64 bit integers)</h3>
<pre><code>// assigning a signed short to its minimum value
  short s = -32768;
  // assigning a signed short to its maximum value
  short s = 32767;
  // assigning a signed int to its minimum value
  int i = -2147483648;
  // assigning a signed int to its maximum value
  int i = 2147483647;
  // assigning a signed long to its minimum value (note the long postfix)
  long l = -9223372036854775808L;
  // assigning a signed long to its maximum value (note the long postfix)
  long l = 9223372036854775807L;
  It is also possible to make these types nullable, meaning that additionally to the usual values, null can be assigned,
  too. If a variable of a nullable type is not initialized, it will be null instead of 0. Nullable types are marked by adding a
  question mark (?) after the type.
  int a; //This is now 0.
  int? b; //This is now null.</code></pre>
<h3>Value type - ushort, uint, ulong (unsigned 16 bit,
  32 bit, 64 bit integers)</h3>
<pre><code>
  // assigning an unsigned short to its minimum value
  ushort s = 0;
  // assigning an unsigned short to its maximum value
  ushort s = 65535;
  // assigning an unsigned int to its minimum value
  uint i = 0;
  // assigning an unsigned int to its maximum value
  uint i = 4294967295;

  // assigning an unsigned long to its minimum value (note the unsigned long postfix)
  ulong l = 0UL;
  // assigning an unsigned long to its maximum value (note the unsigned long postfix)
  ulong l = 18446744073709551615UL;
  It is also possible to make these types nullable, meaning that additionally to the usual values, null can be assigned,
  too. If a variable of a nullable type is not initialized, it will be null instead of 0. Nullable types are marked by adding a
  question mark (?) after the type.
  uint a; //This is now 0.
  uint? b; //This is now null.
</code></pre>
<h3>Value type - bool</h3>
<pre><code>// default value of boolean is false
  bool b;
  //default value of nullable boolean is null
  bool? z;
  b = true;
  if(b) {
  Console.WriteLine("Boolean has true value");
  }
  The bool keyword is an alias of System.Boolean. It is used to declare variables to store the Boolean values, true and
  false.</code></pre>

</div>

<h2>Aliases of built-in types</h2>
<div>
<h3>Built-In Types Table</h3>
The following table shows the keywords for built-in C# types, which are aliases of predefined types in the System
namespaces.
C# Type .NET Framework Type
bool System.Boolean
byte System.Byte
sbyte System.SByte
char System.Char
decimal System.Decimal
double System.Double
float System.Single
int System.Int32
uint System.UInt32
long System.Int64
ulong System.UInt64
object System.Object
short System.Int16
ushort System.UInt16
string System.String
The C# type keywords and their aliases are interchangeable. For example, you can declare an integer variable by
using either of the following declarations:

<pre><code>int number = 123;
System.Int32 number = 123;</code></pre>

</div>

<h2>Anonymous types</h2>
<div>
<h3>Anonymous vs dynamic</h3>
<pre><code>Anonymous types allow the creation of objects without having to explicitly define their types ahead of time, while
  maintaining static type checking.
  var anon = new { Value = 1 };
  Console.WriteLine(anon.Id); // compile time error
  Conversely, dynamic has dynamic type checking, opting for runtime errors, instead of compile-time errors.
  dynamic val = "foo";
  Console.WriteLine(val.Id); // compiles, but throws runtime error</code></pre>
<h3>Creating an anonymous type</h3>
<pre><code>Since anonymous types are not named, variables of those types must be implicitly typed (var).
  var anon = new { Foo = 1, Bar = 2 };
  // anon.Foo == 1
  // anon.Bar == 2
  If the member names are not specified, they are set to the name of the property/variable used to initialize the
  object.
  int foo = 1;
  int bar = 2;
  var anon2 = new { foo, bar };
  // anon2.foo == 1
  // anon2.bar == 2
  Note that names can only be omitted when the expression in the anonymous type declaration is a simple property
  access; for method calls or more complex expressions, a property name must be specified.
  string foo = "some string";
  var anon3 = new { foo.Length };
  // anon3.Length == 11
  var anon4 = new { foo.Length <= 10 ? "short string" : "long string" };
  // compiler error - Invalid anonymous type member declarator.
  var anon5 = new { Description = foo.Length <= 10 ? "short string" : "long string" };
  // OK</code></pre>
<h3>Anonymous type equality</h3>
<pre><code>Anonymous type equality is given by the Equals instance method. Two objects are equal if they have the same type
  and equal values (through a.Prop.Equals(b.Prop)) for every property.
  var anon = new { Foo = 1, Bar = 2 };
  var anon2 = new { Foo = 1, Bar = 2 };
  var anon3 = new { Foo = 5, Bar = 10 };
  var anon3 = new { Foo = 5, Bar = 10 };
  var anon4 = new { Bar = 2, Foo = 1 };
  // anon.Equals(anon2) == true
  // anon.Equals(anon3) == false
  // anon.Equals(anon4) == false (anon and anon4 have different types, see below)
  Two anonymous types are considered the same if and only if their properties have the same name and type and
  appear in the same order.
  var anon = new { Foo = 1, Bar = 2 };
  var anon2 = new { Foo = 7, Bar = 1 };
  var anon3 = new { Bar = 1, Foo = 3 };
  var anon4 = new { Fa = 1, Bar = 2 };
  // anon and anon2 have the same type
  // anon and anon3 have diferent types (Bar and Foo appear in different orders)
  // anon and anon4 have different types (property names are different)
</code></pre>
<h3>Generic methods with anonymous types</h3>
<pre><code>Generic methods allow the use of anonymous types through type inference.
  void Log<T>(T obj) {
  // ...
  }
  Log(new { Value = 10 });
  This means LINQ expressions can be used with anonymous types:
  var products = new[] {
  new { Amount = 10, Id = 0 },
  new { Amount = 20, Id = 1 },
  new { Amount = 15, Id = 2 }
  };
  var idsByAmount = products.OrderBy(x => x.Amount).Select(x => x.Id);
  // idsByAmount: 0, 2, 1</code></pre>
<h3>generic types with anonymous types</h3>
<pre><code>Using generic constructors would require the anonymous types to be named, which is not possible. Alternatively,
  generic methods may be used to allow type inference to occur.
  var anon = new { Foo = 1, Bar = 2 };
  var anon2 = new { Foo = 5, Bar = 10 };
  List<T> CreateList<T>(params T[] items) {
  return new List<T>(items);
  }
  var list1 = CreateList(anon, anon2);
  In the case of List<T>, implicitly typed arrays may be converted to a List<T> through the ToList LINQ method:
  var list2 = new[] {anon, anon2}.ToList();</code></pre>
<h3>Implicitly typed arrays</h3>
<pre><code>Arrays of anonymous types may be created with implicit typing.
  var arr = new[] {
    new { Id = 0 },
    new { Id = 1 }
  };
</code></pre>

</div>

<h2>Dynamic type</h2>
<div>
  <h3>Creating a dynamic object with properties</h3>
<pre><code>using System;
  using System.Dynamic;
  dynamic info = new ExpandoObject();
  info.Id = 123;
  info.Another = 456;
  Console.WriteLine(info.Another);
  // 456
  Console.WriteLine(info.DoesntExist);
  // Throws RuntimeBinderException</code></pre>

<h3>Creating a dynamic variable</h3>
<pre><code>dynamic foo = 123;
  Console.WriteLine(foo + 234);
  // 357 Console.WriteLine(foo.ToUpper())
  // RuntimeBinderException, since int doesn't have a ToUpper method
  foo = "123";
  Console.WriteLine(foo + 234);
  // 123234
  Console.WriteLine(foo.ToUpper()):
  // NOW A STRING</code></pre>
<h3>Returning dynamic</h3>
<pre><code>using System;
  public static void Main()
  {
    var value = GetValue();
    Console.WriteLine(value);
    // dynamics are useful!
  }
  private static dynamic GetValue()
  {
    return "dynamics are useful!";
  }</code></pre>

<h3>Handling Specific Types Unknown at Compile Time</h3>
 The following output equivalent results: 
<pre><code>class IfElseExample
{
public string DebugToString(object a)
{
if (a is StringBuilder)
{
  return DebugToStringInternal(a as StringBuilder);
  }
  else if (a is List<string>)
  {
  return DebugToStringInternal(a as List<string>);
  }
  else
  {
  return a.ToString();
  }
  }
  private string DebugToStringInternal(object a)
  {
  // Fall Back
  return a.ToString();
  }
  private string DebugToStringInternal(StringBuilder sb)
  {
    return $"StringBuilder - Capacity: {sb.Capacity}, MaxCapacity: {sb.MaxCapacity}, Value:
    {sb.ToString()}";
  }
  private string DebugToStringInternal(List<string> list)
  {
    return $"List<string> - Count: {list.Count}, Value: {Environment.NewLine + "\t" +
    string.Join(Environment.NewLine + "\t", list.ToArray())}";
  }
  }
  class DynamicExample
  {
  public string DebugToString(object a)
  {
  return DebugToStringInternal((dynamic)a);
  }
  private string DebugToStringInternal(object a)
  {
  // Fall Back
  return a.ToString();
  }
  private string DebugToStringInternal(StringBuilder sb)
  {
  return $"StringBuilder - Capacity: {sb.Capacity}, MaxCapacity: {sb.MaxCapacity}, Value:
  {sb.ToString()}";
  }
  private string DebugToStringInternal(List<string> list)
  {
  return $"List<string> - Count: {list.Count}, Value: {Environment.NewLine + "\t" +
  string.Join(Environment.NewLine + "\t", list.ToArray())}";
  }
  }</code></pre>


  The advantage to the dynamic, is adding a new Type to handle just requires adding an overload of
  DebugToStringInternal of the new type. Also eliminates the need to manually cast it to the type as well.


</div>

<h2>Type Conversion</h2>
<div>
<h3>Explicit Type Conversion</h3>
<pre><code>using System;
  namespace TypeConversionApplication
  {
    class ExplicitConversion
    {
      static void Main(string[] args)
      {
        double d = 5673.74;
        int i;
        // cast double to int.
        i = (int)d;
        Console.WriteLine(i);
        Console.ReadKey();
      }
    }
  }</code></pre>
<h3>MSDN implicit operator example</h3>
<pre><code>
  class Digit
  {
    public Digit(double d) { val = d; }
    public double val;
    // User-defined conversion from Digit to double
    public static implicit operator double(Digit d)
    {
      Console.WriteLine("Digit to double implict conversion called");
      return d.val;
    }
    // User-defined conversion from double to Digit
    public static implicit operator Digit(double d)
    {
      Console.WriteLine("double to Digit implict conversion called");
      return new Digit(d);
    }
  }
  class Program
  {
    static void Main(string[] args)
    {
      Digit dig = new Digit(7);
      //This call invokes the implicit "double" operator
      double num = dig;
      //This call invokes the implicit "Digit" operator
      Digit dig2 = 12;
      Console.WriteLine("num = {0} dig2 = {1}", num, dig2.val);
      Console.ReadLine();
    }
  }
 /* Output:
  Digit to double implict conversion called
  double to Digit implict conversion called
  num = 7 dig2 = 12*/
</code></pre>

</div>

<h2>Casting</h2>
<div>
<h3>Checking compatibility without casting</h3>
<pre><code>If you need to know whether a value's type extends or implements a given type, but you don't want to actually cast
  it as that type, you can use the is operator.
  if(value is int)
  {
  Console.WriteLine(value + "is an int");
  }</code></pre>
<h3>Cast an object to a base type</h3>
<pre><code>Given the following definitions :
  public interface IMyInterface1
  {
    string GetName();
  }
  public interface IMyInterface2
  {
    string GetName();
  }
  public class MyClass : IMyInterface1, IMyInterface2
  {
    string IMyInterface1.GetName()
    {
      return "IMyInterface1";
    }
    string IMyInterface2.GetName()
    {
      return "IMyInterface2";
    }
  }
  Casting an object to a base type example :
  MyClass obj = new MyClass();
  IMyInterface1 myClass1 = (IMyInterface1)obj;
  IMyInterface2 myClass2 = (IMyInterface2)obj;
  Console.WriteLine("I am : {0}", myClass1.GetName());
  Console.WriteLine("I am : {0}", myClass2.GetName());
  // Outputs :
  // I am : IMyInterface1
  // I am : IMyInterface2
  Section 37.3: Conversion Operators
  In C#, types can define custom Conversion Operators, which allow values to be converted to and from other types
  using either explicit or implicit casts.For example, consider a class that is meant to represent a JavaScript
  GoalKicker.com – C# Notes for Professionals 146
  expression:
  public class JsExpression
  {
    private readonly string expression;
    public JsExpression(string rawExpression)
    {
      this.expression = rawExpression;
    }
    public override string ToString()
    {
      return this.expression;
    }
    public JsExpression IsEqualTo(JsExpression other)
    {
      return new JsExpression("(" + this + " == " + other + ")");
    }
  }
  If we wanted to create a JsExpression representing a comparison of two JavaScript values, we could do something
  like this:
  JsExpression intExpression = new JsExpression("-1");
  JsExpression doubleExpression = new JsExpression("-1.0");
  Console.WriteLine(intExpression.IsEqualTo(doubleExpression)); // (-1 == -1.0)
  But we can add some explicit conversion operators to JsExpression, to allow a simple conversion when using explicit
  casting.
  public static explicit operator JsExpression(int value)
  {
    return new JsExpression(value.ToString());
  }
  public static explicit operator JsExpression(double value)
  {
    return new JsExpression(value.ToString());
  }
  // Usage:
  JsExpression intExpression = (JsExpression)(-1);
  JsExpression doubleExpression = (JsExpression)(-1.0);
  Console.WriteLine(intExpression.IsEqualTo(doubleExpression)); // (-1 == -1.0)
  Or, we could change these operators to implicit to make the syntax much simpler.
  public static implicit operator JsExpression(int value)
  {
    return new JsExpression(value.ToString());
  }
  public static implicit operator JsExpression(double value)
  {
    return new JsExpression(value.ToString());
  }
  // Usage:
  JsExpression intExpression = -1;
  Console.WriteLine(intExpression.IsEqualTo(-1.0)); // (-1 == -1.0)
</code></pre>
<h3>LINQ Casting operations</h3>
<pre><code>
  Suppose you have types like the following:
  interface IThing { }
  class Thing : IThing { }
  LINQ allows you to create a projection that changes the compile-time generic type of an IEnumerable<> via the
  Enumerable.Cast<>() and Enumerable.OfType<>() extension methods.
  IEnumerable<IThing> things = new IThing[] {new Thing()};
  IEnumerable<Thing> things2 = things.Cast<Thing>();
  IEnumerable<Thing> things3 = things.OfType<Thing>();
  When things2 is evaluated, the Cast<>() method will try to cast all of the values in things into Things. If it
  encounters a value that cannot be cast, an InvalidCastException will be thrown.
  When things3 is evaluated, the OfType<>() method will do the same, except that if it encounters a value that
  cannot be cast, it will simply omit that value rather than throw an exception.
  Due to the generic type of these methods, they cannot invoke Conversion Operators or perform numeric
  conversions.
  double[] doubles = new[]{1,2,3}.Cast<double>().ToArray(); // Throws InvalidCastException
  You can simply perform a cast inside a .Select() as a workaround:
  double[] doubles = new[]{1,2,3}.Select(i => (double)i).ToArray();
</code></pre>
<h3>Explicit Casting</h3>
<pre><code>If you know that a value is of a specific type, you can explicitly cast it to that type in order to use it in a context
  where that type is needed.
  object value = -1;
  int number = (int) value;
  Console.WriteLine(Math.Abs(number));
  If we tried passing value directly to Math.Abs(), we would get a compile-time exception because Math.Abs()
  doesn't have an overload that takes an object as a parameter.
  If value could not be cast to an int, then the second line in this example would throw an InvalidCastException</code></pre>
<h3>Safe Explicit Casting (`as` operator)</h3>
<pre><code>If you aren't sure whether a value is of the type you think it is, you can safely cast it using the as operator. If the
  value is not of that type, the resulting value will be null.
  object value = "-1";
  int? number = value as int?;
  if(number != null)
  {
  Console.WriteLine(Math.Abs(number.Value));
  }
</code></pre>
Note that null values have no type, so the as keyword will safely yield null when casting any null value.
<h3>Implicit Casting</h3>
A value will automatically be cast to the appropriate type if the compiler knows that it can always be converted to
that type.
<pre><code>int number = -1;
object value = number;
Console.WriteLine(value);
In this example, we didn't need to use the typical explicit casting syntax because the compiler knows all ints can be
cast to objects. In fact, we could avoid creating variables and pass -1 directly as the argument of
Console.WriteLine() that expects an object.
Console.WriteLine(-1);</code></pre>

<h3>Explicit Numeric Conversions</h3>
Explicit casting operators can be used to perform conversions of numeric types, even though they don't extend or
  implement one another.
<pre><code>
  double value = -1.1;
  int number = (int) value;
 // Note that in cases where the destination type has less precision than the original type, precision will be lost. For
//  example, -1.1 as a double value in the above example becomes -1 as an integer value.
//  Also, numeric conversions rely on compile-time types, so they won't work if the numeric types have been "boxed" into objects.
  object value = -1.1;
  int number = (int) value; // throws InvalidCastException
</code></pre>
</div>
<h2>Nullable types</h2>
<div>
<h3>Initialising a nullable</h3>
<pre><code>For null values:
  Nullable< int> i = null;
  Or:
  int? i = null;
  Or:
  var i = (int?)null;
  For non-null values:
  Nullable< int> i = 0;
  Or:
  int? i = 0;</code></pre>

<h3>Check if a Nullable has a value</h3>
<pre><code>int? i = null;
  if (i != null)
  {
    Console.WriteLine("i is not null");
  }
  else
  {
    Console.WriteLine("i is null");
  }
  
  //Which is the same as:
  if (i.HasValue)
  {
    Console.WriteLine("i is not null");
  }
  else
  {
    Console.WriteLine("i is null");
  }</code></pre>

<h3>Get the value of a nullable type</h3>
Given following nullable int
<pre><code>int? i = 10;</code></pre>
In case default value is needed, you can assign one using null coalescing operator, 
GetValueOrDefault method or check if nullable int HasValue before assignment.
<pre><code>int j = i ?? 0;
int j = i.GetValueOrDefault(0);
int j = i.HasValue ? i.Value : 0;</code></pre>

The following usage is always unsafe. 
If i is null at runtime, a System.InvalidOperationException will be thrown.
At design time, if a value is not set, you'll get a Use of unassigned local variable 'i' error.
int j = i.Value;
<h3>Getting a default value from a nullable</h3>
The .GetValueOrDefault() method returns a value even if the .HasValue property is false 
(unlike the Value property, which throws an exception).
<pre><code>
  class Program
  {
    static void Main()
    {
      int? nullableExample = null;
      int result = nullableExample.GetValueOrDefault();
      Console.WriteLine(result); // will output the default value for int - 0
      int secondResult = nullableExample.GetValueOrDefault(1);
      Console.WriteLine(secondResult) // will output our specified default - 1
      int thirdResult = nullableExample ?? 1;
      Console.WriteLine(secondResult) // same as the GetValueOrDefault but a bit shorter
    }
  }
  Output:
  0
  1</code></pre>

<h3>Default value of nullable types is null</h3>
<pre><code>
  public class NullableTypesExample
  {
    static int? _testValue;
    public static void Main()
    {
      if(_testValue == null)
        Console.WriteLine("null");
      else
        Console.WriteLine(_testValue.ToString());
    }
  }
  Output:
  null</code></pre>

<h3>Effective usage of underlying Nullable< T >argument</h3>
<pre><code>
  Any nullable type is a generic type.And any nullable type is a value type.
  There are some tricks which allow to effectively use the result of the Nullable.GetUnderlyingType method when
  creating code related to reflection/code-generation purposes:
  public static class TypesHelper
  {
    public static bool IsNullable(this Type type)
    {
      Type underlyingType;
      return IsNullable(type, out underlyingType);
    }
    public static bool IsNullable(this Type type, out Type underlyingType)
    {
      underlyingType = Nullable.GetUnderlyingType(type);
      return underlyingType != null;
    }
    public static Type GetNullable(Type type)
    {
      Type underlyingType;
      return IsNullable(type, out underlyingType) ? type : NullableTypesCache.Get(type);
    }
    public static bool IsExactOrNullable(this Type type, Func< Type, bool> predicate)
    {
      Type underlyingType;
      if (IsNullable(type, out underlyingType))
        return IsExactOrNullable(underlyingType, predicate);
      return predicate(type);
    }
    public static bool IsExactOrNullable< T>(this Type type)
    where T : struct
    {
      return IsExactOrNullable(type, t => Equals(t, typeof(T)));
    }
  }
  The usage:
  Type type = typeof(int).GetNullable();
  Console.WriteLine(type.ToString());
  if (type.IsNullable())
    Console.WriteLine("Type is nullable.");
  Type underlyingType;
  if (type.IsNullable(out underlyingType))
    Console.WriteLine("The underlying type is " + underlyingType.Name + ".");
  if (type.IsExactOrNullable< int>())
    Console.WriteLine("Type is either exact or nullable Int32.");
  if (!type.IsExactOrNullable(t => t.IsEnum))
    Console.WriteLine("Type is neither exact nor nullable enum.");
  Output:
  System.Nullable`1[System.Int32]
  Type is nullable.
  The underlying type is Int32.
  Type is either exact or nullable Int32.
  Type is neither exact nor nullable enum.
 
  PS.The NullableTypesCache is defined as follows:
 
  static class NullableTypesCache
  {
    readonly static ConcurrentDictionary< Type, Type> cache = new ConcurrentDictionary< Type,
    Type>();
    static NullableTypesCache()
    {
      cache.TryAdd(typeof(byte), typeof(Nullable< byte>));
      cache.TryAdd(typeof(short), typeof(Nullable< short>));
      cache.TryAdd(typeof(int), typeof(Nullable< int>));
      cache.TryAdd(typeof(long), typeof(Nullable< long>));
      cache.TryAdd(typeof(float), typeof(Nullable< float>));
      cache.TryAdd(typeof(double), typeof(Nullable< double>));
      cache.TryAdd(typeof(decimal), typeof(Nullable< decimal>));
      cache.TryAdd(typeof(sbyte), typeof(Nullable< sbyte>));
      cache.TryAdd(typeof(ushort), typeof(Nullable< ushort>));
      cache.TryAdd(typeof(uint), typeof(Nullable< uint>));
      cache.TryAdd(typeof(ulong), typeof(Nullable< ulong>));
      //...
    }
    readonly static Type NullableBase = typeof(Nullable<>);
    internal static Type Get(Type type)
    {
      // Try to avoid the expensive MakeGenericType method call
      return cache.GetOrAdd(type, t => NullableBase.MakeGenericType(t));
    }
  }
</code></pre>

<h3>Check if a generic type parameter is a nullable type</h3>
<pre><code>public bool IsTypeNullable<T>()
  {
  return Nullable.GetUnderlyingType( typeof(T) )!=null;
  }</code></pre>
</div>

<h2>Constructors and Finalizers</h2>
<div>
  Constructors are methods in a class that are invoked when an instance of that class is created. Their main
  responsibility is to leave the new object in a useful and consistent state.
  Destructors/Finalizers are methods in a class that are invoked when an instance of that is destroyed. In C# they are
  rarely explicitely written/used.
<h3>Static constructor</h3>
- A static constructor is called the first time any member of a type is initialized, 
  a static class member is called or a static method. 
- The static constructor is thread safe. 
- A static constructor is commonly used to:
  . Initialize static state, that is state which is shared across different instances of the same class.
  . Create a singleton
<pre><code>
  {
  // * A static constructor is executed only once,
  // when a class is first accessed.
  // * A static constructor cannot have any access modifiers
  // * A static constructor cannot have any parameters
  static Animal()
  {
    Console.WriteLine("Animal initialized");
  }
  // Instance constructor, this is executed every time the class is created
  public Animal()
  {
    Console.WriteLine("Animal created");
  }
  public static void Yawn()
  {
    Console.WriteLine("Yawn!");
  }
}
var turtle = new Animal();
var giraffe = new Animal();
Output:
Animal initialized
Animal created
Animal created</code></pre>
If the first call is to a static method, the static constructor is invoked without the instance constructor. This is OK,
because the static method can't access instance state anyways.
<pre><code>
  Animal.Yawn();
  This will output:
  Animal initialized
  Yawn!
  See also Exceptions in static constructors and Generic Static Constructors .
  Singleton example:
  public class SessionManager
  {
    public static SessionManager Instance;
    static SessionManager()
    {
      Instance = new SessionManager();
    }
  }</code></pre>
<h3>Singleton constructor pattern</h3>
<pre><code>public class SingletonClass
  {
    public static SingletonClass Instance { get; } = new SingletonClass();
    private SingletonClass()
    {
      // Put custom constructor code here
    }
  }</code></pre>
  Because the constructor is private, no new instances of SingletonClass can be made by consuming code. 
  The only way to access the single instance of SingletonClass is by using the static property SingletonClass.Instance.
  The Instance property is assigned by a static constructor that the C# compiler generates. 
  The .NET runtime guarantees that the static constructor is run at most once and is run before Instance is first read. 
  Therefore, all synchronization and initialization concerns are carried out by the runtime.
  Note, that if the static constructor fails the Singleton class becomes permanently unusable 
  for the life of the AppDomain.
  Also, the static constructor is not guaranteed to run at the time of the first access of Instance. 
  Rather, it will run at some point before that. 
  This makes the time at which initialization happens non-deterministic. 
  In practical cases the JIT often calls the static constructor during compilation (not execution) 
  of a method referencing Instance. 
  This is a performance optimization.
  See the Singleton Implementations page for other ways to implement the singleton pattern.
<h3>Default Constructor</h3>
When a type is defined without a constructor:
<pre><code>
  public class Animal
  {
  }
  then the compiler generates a default constructor equivalent to the following:
  public class Animal
  {
  public Animal() {}
  }
  The definition of any constructor for the type will suppress the default constructor generation. If the type were
  defined as follows:
  public class Animal
  {
  public Animal(string name) {}
  }
  then an Animal could only be created by calling the declared constructor.
  
  // This is valid
  var myAnimal = new Animal("Fluffy");
  // This fails to compile
  var unnamedAnimal = new Animal();
  
  For the second example, the compiler will display an error message:
  'Animal' does not contain a constructor that takes 0 arguments
  If you want a class to have both a parameterless constructor and a constructor that takes a parameter, you can do
  it by explicitly implementing both constructors.
  
  public class Animal
  {
    public Animal() {} //Equivalent to a default constructor.
    public Animal(string name) {}
  }
  
  The compiler will not be able to generate a default constructor if the class extends another class which doesn't have
  a parameterless constructor. For example, if we had a class Creature:
  
  public class Creature
  {
    public Creature(Genus genus) {}
  }
  then Animal defined as class Animal : Creature {} would not compile.
  Section 39.4: Forcing a static constructor to be called
  While static constructors are always called before the first usage of a type it's sometimes useful to be able to force
  them to be called and the RuntimeHelpers class provide an helper for it:
  
  using System.Runtime.CompilerServices;
  // ...
  RuntimeHelpers.RunClassConstructor(typeof(Foo).TypeHandle);
  Remark: All static initialization (fields initializers for example) will run, not only the constructor itself.
  Potential usages: Forcing initialization during the splash screen in an UI application or ensuring that a static
  constructor doesn't fail in an unit test.
</code></pre>

<h3>Calling a constructor from another constructor</h3>
<pre><code>public class Animal
  {
    public string Name { get; set; }
    public Animal() : this("Dog")
    {
    }
    public Animal(string name)
    {
      Name = name;
    }
  }
  var dog = new Animal(); // dog.Name will be set to "Dog" by default.
  var cat = new Animal("Cat"); // cat.Name is "Cat", the empty constructor is not called.</code></pre>

<h3>Calling the base class constructor</h3>
A constructor of a base class is called before a constructor of a derived class is executed. For example, if Mammal
extends Animal, then the code contained in the constructor of Animal is called first when creating an instance of a
Mammal.
If a derived class doesn't explicitly specify which constructor of the base class should be called, the compiler
assumes the parameterless constructor.
<pre><code>public class Animal
  {
    public Animal() { Console.WriteLine("An unknown animal gets born."); }
    public Animal(string name) { Console.WriteLine(name + " gets born"); }
  }
  public class Mammal : Animal
  {
    public Mammal(string name)
    {
      Console.WriteLine(name + " is a mammal.");
    }
  }
  In this case, instantiating a Mammal by calling new Mammal("George the Cat") will print
  An unknown animal gets born.
  George the Cat is a mammal.
  Calling a different constructor of the base class is done by placing : base(args) between the constructor's
  signature and its body:
  public class Mammal : Animal
  {
    public Mammal(string name) : base(name)
    {
      Console.WriteLine(name + " is a mammal.");
    }
  }
  Calling new Mammal("George the Cat") will now print:
  George the Cat gets born.
  George the Cat is a mammal
</code></pre>

<h3>Finalizers on derived classes</h3>
When an object graph is finalized, the order is the reverse of the construction.
 E.g. the super-type is finalized before
the base-type as the following code demonstrates
<pre><code>class TheBaseClass
  {
    ~TheBaseClass()
    {
      Console.WriteLine("Base class finalized!");
    }
  }
  class TheDerivedClass : TheBaseClass
  {
    ~TheDerivedClass()
    {
      Console.WriteLine("Derived class finalized!");
    }
  }
  //Don't assign to a variable
  //to make the object unreachable
  new TheDerivedClass();
  //Just to make the example work;
  //this is otherwise NOT recommended!
  GC.Collect();
  //Derived class finalized!
  //Base class finalized</code></pre>

<h3>Exceptions in static constructors</h3>
If a static constructor throws an exception, it is never retried.
 The type is unusable for the lifetime of the
AppDomain. Any further usages of the type will raise a TypeInitializationException wrapped around the original exception.
<pre><code>public class Animal
  {
    static Animal()
    {
      Console.WriteLine("Static ctor");
      throw new Exception();
    }
    public static void Yawn() { }
  }
  try
  {
    Animal.Yawn();
  }
  catch (Exception e)
  {
    Console.WriteLine(e.ToString());
  }
  try
  {
    Animal.Yawn();
  }
  catch (Exception e)
  {
    Console.WriteLine(e.ToString());
  }
  This will output:
  Static ctor
  System.TypeInitializationException: The type initializer for 'Animal' threw an exception. --->
  System.Exception: Exception of type 'System.Exception' was thrown.
  [...]
  System.TypeInitializationException: The type initializer for 'Animal' threw an exception. --->
  System.Exception: Exception of type 'System.Exception' was thrown.
  where you can see that the actual constructor is only executed once, and the exception is re - used.</code></pre>

<h3>Constructor and Property Initialization</h3>
Shall the property value's assignment be executed before or after the class' constructor?
<pre><code>
  public class TestClass
  {
    public int TestProperty { get; set; } = 2;
    public TestClass()
    {
      if (TestProperty == 1)
      {
        Console.WriteLine("Shall this be executed?");
      }
      if (TestProperty == 2)
      {
        Console.WriteLine("Or shall this be executed");
      }
    }
  }
  var testInstance = new TestClass() { TestProperty = 1 };
  In the example above, shall the TestProperty value be 1 in the class' constructor or after the class constructor?
  Assigning property values in the instance creation like this:
  var testInstance = new TestClass() {TestProperty = 1};
  Will be executed after the constructor is run. However, initializing the property value in the class' property in C# 6.0
  like this:
  public class TestClass
  {
  public int TestProperty { get; set; } = 2;
  public TestClass()
  {
  }
  }
  will be done before the constructor is run.
  Combining the two concepts above in a single example:
  public class TestClass
  {
  public int TestProperty { get; set; } = 2;
  public TestClass()
  {
  if (TestProperty == 1)
  {
  Console.WriteLine("Shall this be executed?");
  }
  if (TestProperty == 2)
  {
  Console.WriteLine("Or shall this be executed");
  }
  }
  }
  static void Main(string[] args)
  {
    var testInstance = new TestClass() { TestProperty = 1 };
    Console.WriteLine(testInstance.TestProperty); //resulting in 1
  }

  Final result:
  "Or shall this be executed"
  "1"
  Explanation:
  The TestProperty value will first be assigned as 2, then the TestClass constructor will be run, resulting in printing
  of
  "Or shall this be executed"
  And then the TestProperty will be assigned as 1 due to new TestClass() { TestProperty = 1 }, making the final
  value for the TestProperty printed by Console.WriteLine(testInstance.TestProperty) to be
  "1"
</code></pre>

<h3>Generic Static Constructors</h3>
If the type on which the static constructor is declared is generic, the static constructor will be called once for each
  unique combination of generic arguments.
<pre><code>
  class Animal<T>
  {
    static Animal()
    {
      Console.WriteLine(typeof(T).FullName);
    }
    public static void Yawn() { }
  }
  Animal< Object>.Yawn();
  Animal< String>.Yawn();
  This will output:
  System.Object
  System.String</code></pre>

<h3>Calling virtual methods in constructor</h3>
<pre><code>
  Unlike C++ in C# you can call a virtual method from class constructor (OK, you can also in C++ but behavior at first is
  surprising). For example:
  abstract class Base
  {
    protected Base()
    {
      _obj = CreateAnother();
    }
    protected virtual AnotherBase CreateAnother()
    {
      return new AnotherBase();
    }
    private readonly AnotherBase _obj;
  }
  sealed class Derived : Base
  {
    public Derived() { }
    protected override AnotherBase CreateAnother()
    {
      return new AnotherDerived();
    }
  }
  var test = new Derived();
  // test._obj is AnotherDerived
  If you come from a C++ background this is surprising, base class constructor already sees derived class virtual
  method table!
  Be careful: derived class may not been fully initialized yet (its constructor will be executed after base class
  constructor) and this technique is dangerous (there is also a StyleCop warning for this). Usually this is regarded as
  bad practice.
</code></pre>
</div>

<h2>Access Modifiers</h2>
<div>

<h3>public</h3>
<pre><code>The public keyword makes a class (including nested classes), property, method or field available to every
  consumer:
  public class Foo()
  {
  public string SomeProperty { get; set; }
  public class Baz
  {
    public int Value { get; set; }
  }
  }
  public class Bar()
  {
    public Bar()
    {
      var myInstance = new Foo();
      var someValue = foo.SomeProperty;
      var myNestedInstance = new Foo.Baz();
      var otherValue = myNestedInstance.Value;
    }
  }</code></pre>

<h3>private</h3>
<pre><code>The private keyword marks properties, methods, fields and nested classes for use inside the class only:
  public class Foo()
  {
  private string someProperty { get; set; }
  private class Baz
  {
  public string Value { get; set; }
  }
  public void Do()
  {
  var baz = new Baz { Value = 42 };
  }
  }
  public class Bar()
  {
  public Bar()
  {
  var myInstance = new Foo();
  // Compile Error - not accessible due to private modifier
  var someValue = foo.someProperty;
  // Compile Error - not accessible due to private modifier
  var baz = new Foo.Baz();
  }
  }
</code></pre>

<h3>protected internal</h3>
<pre><code>The protected internal keyword marks field, methods, properties and nested classes for use inside the same
  assembly or derived classes in another assembly:
  Assembly 1
  public class Foo
  {
    public string MyPublicProperty { get; set; }
    protected internal string MyProtectedInternalProperty { get; set; }
    protected internal class MyProtectedInternalNestedClass
    {
      private string blah;
      public int N { get; set; }
    }
  }
  public class Bar
  {
    void MyMethod1()
    {
      Foo foo = new Foo();
      var myPublicProperty = foo.MyPublicProperty;
      var myProtectedInternalProperty = foo.MyProtectedInternalProperty;
      var myProtectedInternalNestedInstance =
      new Foo.MyProtectedInternalNestedClass();
    }
  }
  Assembly 2
  public class Baz : Foo
  {
    void MyMethod1()
    {
      var myPublicProperty = MyPublicProperty;
      var myProtectedInternalProperty = MyProtectedInternalProperty;
      var thing = new MyProtectedInternalNestedClass();
    }
    void MyMethod2()
  GoalKicker.com – C# Notes for Professionals 165
  {
  Foo foo = new Foo();
    var myPublicProperty = foo.MyPublicProperty;
    // Compile Error
    var myProtectedInternalProperty = foo.MyProtectedInternalProperty;
    // Compile Error
    var myProtectedInternalNestedInstance =
    new Foo.MyProtectedInternalNestedClass();
  }
  }
  public class Qux
  {
    void MyMethod1()
    {
      Baz baz = new Baz();
      var myPublicProperty = baz.MyPublicProperty;
      // Compile Error
      var myProtectedInternalProperty = baz.MyProtectedInternalProperty;
      // Compile Error
      var myProtectedInternalNestedInstance =
      new Baz.MyProtectedInternalNestedClass();
    }
    void MyMethod2()
    {
      Foo foo = new Foo();
      var myPublicProperty = foo.MyPublicProperty;
      //Compile Error
      var myProtectedInternalProperty = foo.MyProtectedInternalProperty;
      // Compile Error
      var myProtectedInternalNestedInstance =
      new Foo.MyProtectedInternalNestedClass();
    }
  }</code></pre>

<h3>internal</h3>
<pre><code>The internal keyword makes a class (including nested classes), property, method or field available to every
  consumer in the same assembly:
  internal class Foo
  {
  internal string SomeProperty {get; set;}
  }
  internal class Bar
  {
  var myInstance = new Foo();
  internal string SomeField = foo.SomeProperty;
  internal class Baz
  {
  private string blah;
  public int N { get; set; }
  }
}
//This can be broken to allow a testing assembly to access the code via adding code to AssemblyInfo.cs file:
using System.Runtime.CompilerServices;
[assembly:InternalsVisibleTo("MyTests")]
</code></pre>

<h3>protected</h3>
<pre><code>The protected keyword marks field, methods properties and nested classes for use inside the same class and
  derived classes only:
  public class Foo()
  {
  protected void SomeFooMethod()
  {
  //do something
  }
  protected class Thing
  {
  private string blah;
  public int N { get; set; }
  }
  }
  public class Bar() : Foo
  {
    private void someBarMethod()
    {
      SomeFooMethod(); // inside derived class
      var thing = new Thing(); // can use nested class
    }
  }
  public class Baz()
  {
    private void someBazMethod()
    {
      var foo = new Foo();
      foo.SomeFooMethod(); //not accessible due to protected modifier
    }
  }
</code></pre>

</div>

<h2>Interfaces</h2>
<div>

<h3>Implementing an interface</h3>
<pre><code>with the keyword interface and a class can 'implement' it by adding: InterfaceName after the class name. A class
  can implement multiple interfaces by separating each interface with a comma.
  : InterfaceName, ISecondInterface
  public interface INoiseMaker
  {
    string MakeNoise();
  }
  public class Cat : INoiseMaker
  {
    public string MakeNoise()
    {
      return "Nyan";
    }
  }
  public class Dog : INoiseMaker
  {
    public string MakeNoise()
    {
      return "Woof";
    }
  }
  Because they implement INoiseMaker, both cat and dog are required to include the string MakeNoise() method
  and will fail to compile without it.</code></pre>

<h3>Explicit interface implementation</h3>
Explicit interface implementation is necessary when you implement multiple interfaces who define a common
method, but different implementations are required depending on which interface is being used to call the method
(note that you don't need explicit implementations if multiple interfaces share the same method and a common
implementation is possible).
<pre><code>
  interface IChauffeur
  {
    string Drive();
  }
  interface IGolfPlayer
  {
    string Drive();
  }
  class GolfingChauffeur : IChauffeur, IGolfPlayer
  {
    public string Drive()
    {
      return "Vroom!";
    }
    string IGolfPlayer.Drive()
    {
      return "Took a swing...";
    }
  }
  GolfingChauffeur obj = new GolfingChauffeur();
  IChauffeur chauffeur = obj;
  IGolfPlayer golfer = obj;
  Console.WriteLine(obj.Drive()); // Vroom!
  Console.WriteLine(chauffeur.Drive()); // Vroom!
  Console.WriteLine(golfer.Drive()); // Took a swing...
                     // The implementation cannot be called from anywhere else except by using the interface:
  public class Golfer : IGolfPlayer
  {
    string IGolfPlayer.Drive()
    {
      return "Swinging hard...";
    }
    public void Swing()
    {
      Drive(); // Compiler error: No such method
    }
  }
  /*
  Due to this, it may be advantageous to put complex implementation code of an explicitly implemented interface in
  a separate, private method.
  An explicit interface implementation can of course only be used for methods that actually exist for that interface:*/
  public class ProGolfer : IGolfPlayer
  {
  string IGolfPlayer.Swear() // Error
  {
  return "The ball is in the pit";
  }
  }
 
</code></pre>
  Similarly, using an explicit interface implementation without declaring that interface on the class causes an error,
  too.
  Hint:
  Implementing interfaces explicitly can also be used to avoid dead code. When a method is no longer needed and
  gets removed from the interface, the compiler will complain about each still existing implementation.
  Note:
  Programmers expect the contract to be the same regardless of the context of the type and explicit implementation
  should not expose different behavior when called. So unlike the example above, IGolfPlayer.Drive and Drive
  should do the same thing when possible.

<h3>Interface Basics</h3>
<pre><code>An Interface's function known as a "contract" of functionality. It means that it declares properties and methods but
  it doesn't implement them.
  So unlike classes Interfaces:
  Can't be instantiated
  Can't have any functionality
  Can only contain methods *(Properties and Events are methods internally)
  Inheriting an interface is called "Implementing"
  You can inherit from 1 class, but you can "Implement" multiple Interfaces
  public interface ICanDoThis
  {
    void TheThingICanDo();
    int SomeValueProperty { get; set; }
  }
  Things to notice:
  The "I" prefix is a naming convention used for interfaces.
  The function body is replaced with a semicolon ";".
  Properties are also allowed because internally they are also methods
  public class MyClass : ICanDoThis
  {
    public void TheThingICanDo()
    {
      // do the thing
    }
    public int SomeValueProperty { get; set; }
    public int SomeValueNotImplemtingAnything { get; set; }
  }
  .
  ICanDoThis obj = new MyClass();
  // ok
  obj.TheThingICanDo();
  // ok
  obj.SomeValueProperty = 5;
  // Error, this member doesn't exist in the interface
  obj.SomeValueNotImplemtingAnything = 5;
  // in order to access the property in the class you must "down cast" it
  ((MyClass)obj).SomeValueNotImplemtingAnything = 5; // ok
  This is especially useful when you're working with UI frameworks such as WinForms or WPF because it's mandatory
  to inherit from a base class to create user control and you loose the ability to create abstraction over different
  control types.An example? Coming up:
  public class MyTextBlock : TextBlock
  {
    public void SetText(string str)
    {
      this.Text = str;
    }
    GoalKicker.com – C# Notes for Professionals 170
  }
  public class MyButton : Button
  {
    public void SetText(string str)
    {
      this.Content = str;
    }
  }
  The problem proposed is that both contain some concept of "Text" but the property names differ.And you can't
  create create a abstract base class because they have a mandatory inheritance to 2 different classes.An interface
  can alleviate that
  public interface ITextControl
  {
    void SetText(string str);
  }
  public class MyTextBlock : TextBlock, ITextControl
  {
    public void SetText(string str)
    {
      this.Text = str;
    }
  }
  public class MyButton : Button, ITextControl
  {
    public void SetText(string str)
    {
      this.Content = str;
    }
    public int Clicks { get; set; }
  }
  Now MyButton and MyTextBlock is interchangeable.
  var controls = new List<ITextControls>{
  new MyTextBlock(),
  new MyButton()
  };
  foreach (var ctrl in controls)
  {
    ctrl.SetText("This text will be applied to both controls despite them being different");
    // Compiler Error, no such member in interface
    ctrl.Clicks = 0;
    // Runtime Error because 1 class is in fact not a button which makes this cast invalid
    ((MyButton)ctrl).Clicks = 0;
    /* the solution is to check the type first.
    This is usually considered bad practice since
    it's a symptom of poor abstraction */
    var button = ctrl as MyButton;
    if (button != null)
      button.Clicks = 0; // no errors
  }
  </code></pre>

<h3>IComparable<T> as an Example of Implementing
  an Interface</h3>
  Interfaces can seem abstract until you seem them in practice. 
  The IComparable and IComparable< T> are great
  examples of why interfaces can be helpful to us.
  Let's say that in a program for a online store, we have a variety of items you can buy. 
  Each item has a name, an ID
  number, and a price.
<pre><code>
  public class Item {
    public string name; // though public variables are generally bad practice,
    public int idNumber; // to keep this example simple we will use them instead
    public decimal price; // of a property.
    // body omitted for brevity
  }
  We have our Items stored inside of a List< Item>, and in our program somewhere, we want to sort our list by ID
  number from smallest to largest. Instead of writing our own sorting algorithm, we can instead use the Sort()
  method that List<T> already has. However, as our Item class is right now, there is no way for the List<T> to
  understand what order to sort the list. Here is where the IComparable interface comes in.
  To correctly implement the CompareTo method, CompareTo should return a positive number if the parameter is "less
  than" the current one, zero if they are equal, and a negative number if the parameter is "greater than".
  Item apple = new Item();
  apple.idNumber = 15;
  Item banana = new Item();
  banana.idNumber = 4;
  Item cow = new Item();
  cow.idNumber = 15;
  Item diamond = new Item();
  diamond.idNumber = 18;
  Console.WriteLine(apple.CompareTo(banana)); // 11
  Console.WriteLine(apple.CompareTo(cow)); // 0
  Console.WriteLine(apple.CompareTo(diamond)); // -3
  Here's the example Item's implementation of the interface:
  public class Item : IComparable< Item> {
    private string name;
    private int idNumber;
    private decimal price;
    public int CompareTo(Item otherItem) {
      return (this.idNumber - otherItem.idNumber);
    }
  // rest of code omitted for brevity
  }
</code></pre>
 
  On a surface level, the CompareTo method in our item simply returns the difference in their ID numbers, but what
  does the above do in practice?
  Now, when we call Sort() on a List< Item> object, the List will automatically call the Item's CompareTo method
  when it needs to determine what order to put objects in. Furthermore, besides List<T>, any other objects that
  need the ability to compare two objects will work with the Item because we have defined the ability for two
  different Items to be compared with one another.
<h3>Implementing multiple interfaces</h3>
<pre><code>public interface IAnimal
  {
    string Name { get; set; }
  }
  public interface INoiseMaker
  {
    string MakeNoise();
  }
  public class Cat : IAnimal, INoiseMaker
  {
    public Cat()
    {
      Name = "Cat";
    }
    public string Name { get; set; }
    public string MakeNoise()
    {
      return "Nyan";
    }
  }</code></pre>

<h3>Why we use interfaces</h3>
An interface is a definition of a contract between the user of the interface and the class that implement it. One way
to think of an interface is as a declaration that an object can perform certain functions.
Let's say that we define an interface IShape to represent different type of shapes, we expect a shape to have an
area, so we will define a method to force the interface implementations to return their area :
<pre><code>
  public interface IShape
  {
    double ComputeArea();
  }
  Let's that we have the following two shapes : a Rectangle and a Circle
    public class Rectangle : IShape
  {
    private double length;
    private double width;
    public Rectangle(double length, double width)
    {
      this.length = length;
      this.width = width;
    }
    public double ComputeArea()
    {
      return length * width;
    }
  }
  public class Circle : IShape
  {
    private double radius;
    public Circle(double radius)
    {
      this.radius = radius;
    }
    public double ComputeArea()
    {
      return Math.Pow(radius, 2.0) * Math.PI;
    }
  }
  // Each one of them have its own definition of its area, but both of them are shapes. 
  // So it's only logical to see them as IShape in our program :
  private static void Main(string[] args)
  {
    var shapes = new List< IShape>() { new Rectangle(5, 10), new Circle(5) };
    ComputeArea(shapes);
    Console.ReadKey();
  }
  private static void ComputeArea(IEnumerable< IShape> shapes)
  {
    foreach (shape in shapes)
    {
      Console.WriteLine("Area: {0:N}, shape.ComputeArea());
      }
  }
  // Output:
  // Area : 50.00
  // Area : 78.54
</code></pre>

<h3>"Hiding" members with Explicit Implementation</h3>
Don't you hate it when interfaces pollute you class with too many members you don't even care about? Well I got a
solution! Explicit Implementations
<pre><code>
  public interface IMessageService {
    void OnMessageRecieve();
    void SendMessage();
    string Result { get; set; }
    int Encoding { get; set; }
    // yadda yadda
  }
//Normally you'd implement the class like this
public class MyObjectWithMessages : IMessageService
{
  public void OnMessageRecieve()
  {
  }
  public void SendMessage()
  {
  }
  public string Result { get; set; }
  public int Encoding { get; set; }
}

Every member is public.
var obj = new MyObjectWithMessages();
// why would i want to call this function?
obj.OnMessageRecieve();
Answer: I don't. So neither should it be declared public but simply declaring the members as private will make the
compiler throw an error
The solution is to use explicit implementation:
public class MyObjectWithMessages : IMessageService{
void IMessageService.OnMessageRecieve() {
}
void IMessageService.SendMessage() {
}
string IMessageService.Result { get; set; }
int IMessageService.Encoding { get; set; }
}

So now you have implemented the members as required and they won't expose any members in as public.
var obj = new MyObjectWithMessages();
/* error member does not exist on type MyObjectWithMessages.
* We've succesfully made it "private" */
obj.OnMessageRecieve();
If you seriously still want to access the member even though is explicitly implement all you have to do is cast the
object to the interface and you good to go.
((IMessageService)obj).OnMessageRecieve();

</code></pre>

</div>

<h2>Static Classes</h2>
<div>

<h3>Static Classes</h3>
<pre><code>The "static" keyword when referring to a class has three effects:
  1. You cannot create an instance of a static class (this even removes the default constructor)
  2. All properties and methods in the class must be static as well.
  3. A static class is a sealed class, meaning it cannot be inherited.
  public static class Foo
  {
    //Notice there is no constructor as this cannot be an instance
    public static int Counter { get; set; }
    public static int GetCount()
    {
      return Counter;
    }
  }
  public class Program
  {
    static void Main(string[] args)
    {
      Foo.Counter++;
      Console.WriteLine(Foo.GetCount()); //this will print 1
                         //var foo1 = new Foo();
                         //this line would break the code as the Foo class does not have a constructor
    }
  }

</code></pre>

<h3>Static class lifetime</h3>
<pre><code>A static class is lazily initialized on member access and lives for the duration of the application domain.
  void Main()
  {
    Console.WriteLine("Static classes are lazily initialized");
    Console.WriteLine("The static constructor is only invoked when the class is first accessed");
    Foo.SayHi();
    Console.WriteLine("Reflecting on a type won't trigger its static .ctor");
    var barType = typeof(Bar);
    Console.WriteLine("However, you can manually trigger it with
  
    System.Runtime.CompilerServices.RuntimeHelpers");
  
    RuntimeHelpers.RunClassConstructor(barType.TypeHandle);
  }
  // Define other methods and classes here
  public static class Foo
  {
    static Foo()
    {
      Console.WriteLine("static Foo.ctor");
    }
    public static void SayHi()
    {
      Console.WriteLine("Foo: Hi");
    }
  }
  public static class Bar
  {
    static Bar()
    {
      Console.WriteLine("static Bar.ctor");
    }
  }
</code></pre>

<h3>Static keyword</h3>
The static keyword means 2 things:
1. This value does not change from object to object but rather changes on a class as a whole
2. Static properties and methods don't require an instance.
<pre><code>public class Foo
  {
    public Foo{
  Counter++;
  NonStaticCounter++;
  }
  public static int Counter { get; set; }
  public int NonStaticCounter { get; set; }
  }
  public class Program
  {
    static void Main(string[] args)
    {
      //Create an instance
      var foo1 = new Foo();
      Console.WriteLine(foo1.NonStaticCounter); //this will print "1"
                            //Notice this next call doesn't access the instance but calls by the class name.
      Console.WriteLine(Foo.Counter); //this will also print "1"
                      //Create a second instance
      var foo2 = new Foo();
      Console.WriteLine(foo2.NonStaticCounter); //this will print "1"
      Console.WriteLine(Foo.Counter); //this will now print "2"
                      //The static property incremented on both instances and can persist for the whole class
    }
  }</code></pre>

</div>
<h2>Singleton Implementation</h2>
<div>

<h3>Statically Initialized Singleton</h3>
<pre><code>public class Singleton
  {
  private readonly static Singleton instance = new Singleton();
  private Singleton() { }
  public static Singleton Instance => instance;
  }
  This implementation is thread-safe because in this case instance object is initialized in the static constructor. The
  CLR already ensures that all static constructors are executed thread-safe.
  Mutating instance is not a thread-safe operation, therefore the readonly attribute guarantees immutability after
  initialization.</code></pre>

<h3>Lazy, thread-safe Singleton (using Lazy<T>)</h3>
<pre><code>.Net 4.0 type Lazy guarantees thread-safe object initialization, so this type could be used to make Singletons.
  public class LazySingleton
  {
    private static readonly Lazy<LazySingleton> _instance =
    new Lazy<LazySingleton>(() => new LazySingleton());
    public static LazySingleton Instance
    {
      get { return _instance.Value; }
    }
    private LazySingleton() { }
  }
  Using Lazy<T> will make sure that the object is only instantiated when it is used somewhere in the calling code.
  A simple usage will be like:
  using System;
  public class Program
  {
    public static void Main()
    {
      var instance = LazySingleton.Instance;
    }
  }</code></pre>

<h3>Lazy, thread-safe Singleton (using Double
  Checked Locking)</h3>
<pre><code>This thread-safe version of a singleton was necessary in the early versions of .NET where static initialization was
  not guaranteed to be thread-safe. In more modern versions of the framework a statically initialized singleton is

  usually preferred because it is very easy to make implementation mistakes in the following pattern.
  public sealed class ThreadSafeSingleton
  {
    private static volatile ThreadSafeSingleton instance;
    private static object lockObject = new Object();
    private ThreadSafeSingleton()
    {
    }
    public static ThreadSafeSingleton Instance
    {
      get
      {
        if (instance == null)
        {
          lock (lockObject)
          {
            if (instance == null)
            {
              instance = new ThreadSafeSingleton();
            }
          }
        }
        return instance;
      }
    }
  }
</code></pre>
Notice that the if (instance == null) check is done twice: once before the lock is acquired, and once afterwards.
This implementation would still be thread-safe even without the first null check. However, that would mean that a
lock would be acquired every time the instance is requested, and that would cause performance to suffer. The first
null check is added so that the lock is not acquired unless it's necessary. The second null check makes sure that
only the first thread to acquire the lock then creates the instance. The other threads will find the instance to be
populated and skip ahead.
<h3>Lazy, thread safe singleton (for .NET 3.5 or
  older, alternate implementation)</h3>
<pre><code>Because in .NET 3.5 and older you don't have Lazy<T> class you use the following pattern:

    This is inspired from Jon Skeet's blog post.
    Because the Nested class is nested and private the instantiation of the singleton instance will not be triggered by
    accessing other members of the Sigleton class (such as a public readonly property, for example).

    public class Singleton
    {
      private Singleton() // prevents public instantiation
      {
      }
      public static Singleton Instance
      {
        get
        {
          return Nested.instance;
        }
      }
      private class Nested
      {
        // Explicit static constructor to tell C# compiler
        // not to mark type as beforefieldinit
        static Nested()
        {
        }
        internal static readonly Singleton instance = new Singleton();
      }
    }
  </code></pre>

</div>

<h2>Dependency Injection</h2>
<div>

<h3>Dependency Injection C# and ASP.NET with Unity</h3>
First why we should use depedency injection in our code ? 
We want to decouple other components from other classes in our program. 
For example we have class AnimalController which have code like this :
<pre><code>
  public class AnimalController()
  {
    private SantaAndHisReindeer _SantaAndHisReindeer = new SantaAndHisReindeer();
    public AnimalController(){
      Console.WriteLine("");
    } 
  }</code></pre>
  We look at this code and we think everything is ok but now our AnimalController is reliant on object
  _SantaAndHisReindeer. Automatically my Controller is bad to testing and reusability of my code will be very hard.
  Very good explanation why we should use Depedency Injection and interfaces here.
  If we want Unity to handle DI, the road to achieve this is very simple :) With NuGet( package manager) we can easily
  import unity to our code.
  in Visual Studio Tools -> NuGet Package Manager -> Manage Packages for Solution -> in search input write
  unity -> choose our project-> click install
  Now two files with nice comments will be created.
  in App-Data folder UnityConfig.cs and UnityMvcActivator.cs
  UnityConfig - in RegisterTypes method, we can see type that will be injection in our constructors.
  <pre><code>
    namespace Vegan.WebUi.App_Start
    {
      public class UnityConfig
      {
        #region Unity Container
        private static Lazy<IUnityContainer> container = new Lazy<IUnityContainer>(() =>
        {
          var container = new UnityContainer();
          RegisterTypes(container);
          return container;
        });
        /// <summary>
        /// Gets the configured Unity container.
        /// </summary>
        public static IUnityContainer GetConfiguredContainer()
        {
          return container.Value;
        }
        #endregion
        /// <summary>Registers the type mappings with the Unity container.</summary>
        /// <param name="container">The unity container to configure.</param>
        /// <remarks>There is no need to register concrete types such as controllers or API controllers
        (unless you want to
    /// change the defaults), as Unity allows resolving a concrete type even if it was not previously
    registered.</remarks>
    public static void RegisterTypes(IUnityContainer container)
        {
          // NOTE: To load from web.config uncomment the line below. Make sure to add a
          Microsoft.Practices.Unity.Configuration to the using statements.
          // container.LoadConfiguration();
          // TODO: Register your types here
          // container.RegisterType<IProductRepository, ProductRepository>();
          container.RegisterType<ISanta, SantaAndHisReindeer>();
        }
      }
    } 
  </code></pre>
  UnityMvcActivator - > also with nice comments which say that this class integrates Unity with ASP.NET
  MVC
<pre><code>void Main()
  {
  }
  
  [assembly:
  WebActivatorEx.PreApplicationStartMethod(typeof(Vegan.WebUi.App_Start.UnityWebActivator), "Start")]
  [assembly:
  WebActivatorEx.ApplicationShutdownMethod(typeof(Vegan.WebUi.App_Start.UnityWebActivator),
  "Shutdown")]
  namespace Vegan.WebUi.App_Start
  {
    /// <summary>Provides the bootstrapping for integrating Unity with ASP.NET MVC.</summary>
    public static class UnityWebActivator
    {
      /// <summary>Integrates Unity when the application starts.</summary>
      public static void Start()
      {
        var container = UnityConfig.GetConfiguredContainer();
        FilterProviders.Providers.Remove(FilterProviders.Providers.OfType<FilterAttributeFilterProvider>().
        First());
        FilterProviders.Providers.Add(new UnityFilterAttributeFilterProvider(container));
        DependencyResolver.SetResolver(new UnityDependencyResolver(container));
        // TODO: Uncomment if you want to use PerRequestLifetimeManager
        //
        Microsoft.Web.Infrastructure.DynamicModuleHelper.DynamicModuleUtility.RegisterModule(typeof(UnityPerR
        equestHttpModule));
      }
      /// <summary>Disposes the Unity container when the application is shut down.</summary>
      public static void Shutdown()
      {
        var container = UnityConfig.GetConfiguredContainer();
        container.Dispose();
      }
    }
  }
  //Now we can decouple our Controller from class SantAndHisReindeer :)
  public class AnimalController()
  {
  private readonly SantaAndHisReindeer _SantaAndHisReindeer;
  public AnimalController(SantaAndHisReindeer SantaAndHisReindeer)
  {
    _SantAndHisReindeer = SantaAndHisReindeer;
  }
  }</code></pre>
  There is one final thing we must do before running our application.
  In Global.asax.cs we must add new line: UnityWebActivator.Start() which will start, configure Unity and register our
  types.
 <pre><code>namespace Vegan.WebUi
  {
    public class MvcApplication : System.Web.HttpApplication
    {
      protected void Application_Start()
      {
        AreaRegistration.RegisterAllAreas();
        FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
        RouteConfig.RegisterRoutes(RouteTable.Routes);
        BundleConfig.RegisterBundles(BundleTable.Bundles);
        UnityWebActivator.Start();
      }
    }
  }</code></pre> 
<h3>Dependency injection using MEF</h3>
<pre><code>
  public interface ILogger
  {
    void Log(string message);
  }
  [Export(typeof(ILogger))]
  [ExportMetadata("Name", "Console")]
  public class ConsoleLogger : ILogger
  {
    public void Log(string message)
    {
      Console.WriteLine(message);
    }
  }
  [Export(typeof(ILogger))]
  [ExportMetadata("Name", "File")]
  public class FileLogger : ILogger
  {
    public void Log(string message)
    {
      //Write the message to file
    }
  }
  public class User
  {
    private readonly ILogger logger;
    public User(ILogger logger)
    {
      this.logger = logger;
    }
    public void LogUser(string message)
    {
      logger.Log(message);
    }
  }
  public interface ILoggerMetaData
  {
    string Name { get; }
  }
  internal class Program
  {
    private CompositionContainer _container;
    [ImportMany]
    private IEnumerable<Lazy<ILogger, ILoggerMetaData>> _loggers;
    private static void Main()
    {
      ComposeLoggers();
      Lazy<ILogger, ILoggerMetaData> loggerNameAndLoggerMapping = _ loggers.First((n) =>
      ((n.Metadata.Name.ToUpper() == "Console"));
      ILogger logger = loggerNameAndLoggerMapping.Value
    var user = new User(logger);
      user.LogUser("user name");
    }
    private void ComposeLoggers()
    {
      //An aggregate catalog that combines multiple catalogs
      var catalog = new AggregateCatalog();
      string loggersDllDirectory = Path.Combine(Utilities.GetApplicationDirectory(), "Loggers");
      if (!Directory.Exists(loggersDllDirectory))
      {
        Directory.CreateDirectory(loggersDllDirectory);
        GoalKicker.com – C# Notes for Professionals 184
  }
      //Adds all the parts found in the same assembly as the PluginManager class
      catalog.Catalogs.Add(new AssemblyCatalog(typeof(Program).Assembly));
      catalog.Catalogs.Add(new DirectoryCatalog(loggersDllDirectory));
      //Create the CompositionContainer with the parts in the catalog
      _container = new CompositionContainer(catalog);
      //Fill the imports of this object
      try
      {
        this._container.ComposeParts(this);
      }
      catch (CompositionException compositionException)
      {
        throw new CompositionException(compositionException.Message);
      }
    }
  }

</code></pre>
<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2>Partial class and methods</h2>
<div>
 Partial classes provides us an option to split classes into multiple parts and in multiple source files. All parts are
combined into one single class during compile time. All parts should contain the keyword partial,should be of the
same accessibility. All parts should be present in the same assembly for it to be included during compile time. 
<h3>Partial classes</h3>
Partial classes provide an ability to split class declaration (usually into separate files).
 A common problem that can
be solved with partial classes is allowing users to modify auto-generated code without fearing that their changes
will be overwritten if the code is regenerated.
 Also multiple developers can work on same class or methods.
<pre><code>namespace PartialClassAndMethods
  {
    public partial class PartialClass
    {
      public void ExampleMethod()
      {
        Console.WriteLine("Method call from the first declaration.");
      }
    }
    public partial class PartialClass
    {
      public void AnotherExampleMethod()
      {
        Console.WriteLine("Method call from the second declaration.");
      }
    }
    class Program
    {
      static void Main(string[] args)
      {
        PartialClass partial = new PartialClass();
        partial.ExampleMethod(); // outputs "Method call from the first declaration."
        partial.AnotherExampleMethod(); // outputs "Method call from the second declaration."
      }
    }
  }</code></pre>

<h3>Partial classes inheriting from a base class</h3>
When inheriting from any base class, only one partial class needs to have the base class specified.
<pre><code>
  // PartialClass1.cs
  public partial class PartialClass : BaseClass {}
  // PartialClass2.cs
  public partial class PartialClass {}
  You can specify the same base class in more than one partial class. It will get flagged as redundant by some IDE
  tools, but it does compile correctly.
  // PartialClass1.cs
  public partial class PartialClass : BaseClass {}
  // PartialClass2.cs
  public partial class PartialClass : BaseClass {} // base class here is redundant
  You cannot specify different base classes in multiple partial classes, it will result in a compiler error.
  // PartialClass1.cs
  public partial class PartialClass : BaseClass {} // compiler error
  // PartialClass2.cs
  public partial class PartialClass : OtherBaseClass {} // compiler error
</code></pre>

<h3>Partial methods</h3>
Partial method consists of the definition in one partial class declaration 
(as a common scenario - in the autogenerated one) and the implementation in another partial class declaration.
<pre><code>namespace PartialClassAndMethods
  {
    public partial class PartialClass // Auto-generated
    {
      partial void PartialMethod();
    }
    public partial class PartialClass // Human-written
    {
      public void PartialMethod()
      {
        Console.WriteLine("Partial method called.");
      }
    }
    class Program
    {
      static void Main(string[] args)
      {
        PartialClass partial = new PartialClass();
        partial.PartialMethod(); // outputs "Partial method called."
      }
    }
  }</code></pre>

</div>

<h2>Object initializers</h2>
<div>

<h3>Simple usage</h3>
Object initializers are handy when you need to create an object and set a couple of properties right away,
 but the available constructors are not sufficient. Say you have a class
<pre><code>
  public class Book
  {
  public string Title { get; set; }
  public string Author { get; set; }
  // the rest of class definition
  }
  // To initialize a new instance of the class with an initializer:
  Book theBook = new Book { Title = "Don Quixote", Author = "Miguel de Cervantes" };
  This is equivalent to
  Book theBook = new Book();
  theBook.Title = "Don Quixote";
  theBook.Author = "Miguel de Cervantes";
</code></pre>

<h3>Usage with non-default constructors</h3>
You can combine object initializers with constructors to initialize types if necessary. Take for example a class
  defined as such:
<pre><code>
  public class Book {
  public string Title { get; set; }
  public string Author { get; set; }
  public Book(int id) {
  //do things
  }
  // the rest of class definition
  }
  var someBook = new Book(16) { Title = "Don Quixote", Author = "Miguel de Cervantes" }

  //This will first instantiate a Book with the Book(int) constructor, then set each property in the initializer. 
  / It is equivalent to:
  var someBook = new Book(16);
  someBook.Title = "Don Quixote";
  someBook.Author = "Miguel de Cervantes";
</code></pre>

<h3>Usage with anonymous types</h3>
  Object initializers are the only way to initialize anonymous types, which are types generated by the compiler.
<pre><code>
  var album = new { Band = "Beatles", Title = "Abbey Road" };
</code></pre>
For that reason object initializers are widely used in LINQ select queries, 
since they provide a convenient way to
specify which parts of a queried object you are interested in.
<pre><code>var albumTitles = from a in albums
  select new
  {
  Title = a.Title,
  Artist = a.Band
  };</code></pre>
</div>

<h2>Methods</h2>
<div>
<h3>Calling a static Method</h3>
<pre><code>// Single argument
  System.Console.WriteLine("Hello World");
  // Multiple arguments
  string name = "User";
  System.Console.WriteLine("Hello, {0}!", name);
  Calling a static method and storing its return value:
  string input = System.Console.ReadLine();
  Calling an instance method:
  int x = 42;
  // The instance method called here is Int32.ToString()
  string xAsString = x.ToString();</code></pre>

<h3>Calling a generic method</h3>
<pre><code>// Assuming a method 'T[] CreateArray<T>(int size)'
  DateTime[] dates = CreateArray<DateTime>(8);</code></pre>

<h3>Anonymous method</h3>
Anonymous methods provide a technique to pass a code block as a delegate parameter.
 They are methods with a body, but no name.
<pre><code>delegate int IntOp(int lhs, int rhs);
  class Program
  {
    static void Main(string[] args)
    {
      // C# 2.0 definition
      IntOp add = delegate (int lhs, int rhs)
      {
        return lhs + rhs;
      };
      // C# 3.0 definition
      IntOp mul = (lhs, rhs) =>
      {
        return lhs * rhs;
      };
      // C# 3.0 definition - shorthand
      IntOp sub = (lhs, rhs) => lhs - rhs;
      // Calling each method
      Console.WriteLine("2 + 3 = " + add(2, 3));
      Console.WriteLine("2 * 3 = " + mul(2, 3));
      Console.WriteLine("2 - 3 = " + sub(2, 3));
    }
  }</code></pre>

<h3>Declaring a Method</h3>
Every method has a unique signature consisting of a accessor (public, private, ...) ,optional modifier (abstract), a
name and if needed method parameters. Note, that the return type is not part of the signature. A method
prototype looks like the following:
AccessModifier OptionalModifier ReturnType MethodName(InputParameters)
{
//Method body
}
AccessModifier can be public, protected, pirvate or by default internal.
OptionalModifier can be static abstract virtual override new or sealed.
ReturnType can be void for no return or can be any type from the basic ones, as int to complex classes.
a Method may have some or no input parameters. to set parameters for a method, you should declare each one
like normal variable declarations (like int a), and for more than one parameter you should use comma between
them (like int a, int b).
Parameters may have default values. for this you should set a value for the parameter (like int a = 0). if a
parameter has a default value, setting the input value is optional.
The following method example returns the sum of two integers:
<pre><code>private int Sum(int a, int b)
  {
  return a + b;
  }</code></pre>

<h3>Parameters and Arguments</h3>
A method can declare any number of parameters (in this example, i, s and o are the parameters):
<pre><code>
  static void DoSomething(int i, string s, object o) {
    Console.WriteLine(String.Format("i={0}, s={1}, o={2}", i, s, o));
  }
</code></pre>
  Parameters can be used to pass values into a method, so that the method can work with them. 
  This can be every kind of work like printing the values, 
  or making modifications to the object referenced by a parameter, or storing the values.
  When you call the method, you need to pass an actual value for every parameter.
   At this point, the values that you actually pass to the method call are called Arguments:
  DoSomething(x, "hello", new object());
<h3>Return Types</h3>
A method can return either nothing (void), or a value of a specified type:
<pre><code>// If you don't want to return a value, use void as return type.
  static void ReturnsNothing() {
    Console.WriteLine("Returns nothing");
  }
  // If you want to return a value, you need to specify its type.
  static string ReturnsHelloWorld() {
    return "Hello World";
  }</code></pre>
  If your method specifies a return value, the method must return a value. You do this using the return statement.
  Once a return statement has been reached, it returns the specified value and any code after it will not be run
  anymore (exceptions are finally blocks, which will still be executed before the method returns).
  If your method returns nothing (void), you can still use the return statement without a value if you want to return
  from the method immediately. At the end of such a method, a return statement would be unnecessary though.
  Examples of valid return statements:
  return;
  return 0;
  return x * 2;
  return Console.ReadLine();
  Throwing an exception can end method execution without returning a value. Also, there are iterator blocks, where
  return values are generated by using the yield keyword, but those are special cases that will not be explained at this
  point.

<h3>Default Parameters</h3>
You can use default parameters if you want to provide the option to leave out parameters:
<pre><code>static void SaySomething(string what = "ehh")
  {
    Console.WriteLine(what);
  }
  static void Main()
  {
    // prints "hello"
    SaySomething("hello");
    // prints "ehh"
    SaySomething(); // The compiler compiles this as if we had typed SaySomething("ehh")
  }</code></pre>
  When you call such a method and omit a parameter for which a default value is provided, 
  the compiler inserts that default value for you.
  Keep in mind that parameters with default values need to be written after parameters without default values.
<pre><code>static void SaySomething(string say, string what = "ehh")
  {
    //Correct
    Console.WriteLine(say + what);
  }
  static void SaySomethingElse(string what = "ehh", string say)
  {
    //Incorrect
    Console.WriteLine(say + what);
  }</code></pre>
  WARNING: Because it works that way, default values can be problematic in some cases. If you change the default
  value of a method parameter and don't recompile all callers of that method, those callers will still use the default
  value that was present when they were compiled, possibly causing inconsistencies
<h3>Method overloading</h3>
Definition : When multiple methods with the same name are declared with different parameters, it is referred to as
method overloading. Method overloading typically represents functions that are identical in their purpose but are
written to accept different data types as their parameters.
Factors affecting
  . Number of Arguments
  . Type of arguments
  . Return Type**
Consider a method named Area that will perform calculation functions, 
which will accepts various arguments and return the result.

Example
<pre><code>
  public string Area(int value1)
  {
    return String.Format("Area of Square is {0}", value1 * value1);
  }
  This method will accepts one argument and return a string, 
  if we call the method with an integer(say 5) the output
  will be "Area of Square is 25".
  
  public double Area(double value1, double value2)
  {
    return value1 * value2;
  }
  
  Similarly if we pass two double values to this method the output will be the product of the two values and are of type double. 
  This can be used of multiplication as well as finding the Area of rectangles
  public double Area(double value1)
  {
    return 3.14 * Math.Pow(value1,2);
  }
</code></pre>
This can be used specially for finding the area of circle, which will accepts a double value(radius) and return
another double value as its Area.
Each of these methods can be called normally without conflict - the compiler will examine the parameters of each
method call to determine which version of Area needs to be used.
<pre><code>string squareArea = Area(2);
  double rectangleArea = Area(32.0, 17.5);
  double circleArea = Area(5.0); // all of these are valid and will compile.

  public string Area(double width, double height) { ... }
  public double Area(double width, double height) { ... }
  // This will NOT compile.

  //If we need to have our class use the same method names that return different values,
  // we can remove the issues of ambiguity by implementing an interface 
  // and explicitly defining its usage.
  public interface IAreaCalculatorString {
    public string Area(double width, double height);
  }
  public class AreaCalculator : IAreaCalculatorString {
    public string IAreaCalculatorString.Area(double width, double height) { ... }
    // Note that the method call now explicitly says it will be used when called through
    // the IAreaCalculatorString interface, allowing us to resolve the ambiguity.
    public double Area(double width, double height) { ... }
</code></pre>

<h3>Access rights</h3>
<pre><code>// static: is callable on a class even when no instance of the class has been created
  public static void MyMethod()
  // virtual: can be called or overridden in an inherited class
  public virtual void MyMethod()
  // internal: access is limited within the current assembly
  internal void MyMethod()
  //private: access is limited only within the same class
  private void MyMethod()
  //public: access right from every class / assembly
  public void MyMethod()
  //protected: access is limited to the containing class or types derived from it
  protected void MyMethod()
  //protected internal: access is limited to the current assembly or types derived from the containing
  class.
  protected internal void MyMethod()</code></pre>


</div>

<h2>Extension Methods</h2>
<div>
-<b>this</b> : The first parameter of an extension method should always be preceded by the this keyword, 
followed by the identifier with which to refer to the "current" instance of the object you are extending
<h3>Extension methods - overview</h3>
Extension methods were introduced in C# 3.0. Extension methods extend and add behavior to existing types
without creating a new derived type, recompiling, or otherwise modifying the original type. They are especially
helpful when you cannot modify the source of a type you are looking to enhance. Extension methods may be created for
system types, types defined by third parties, and types that you have defined yourself. The extension method can
be invoked as though it were a member method of the original type. This allows for Method Chaining used to
implement a Fluent Interface.
An extension method is created by adding a static method to a static class which is distinct from the original type
being extended. The static class holding the extension method is often created for the sole purpose of holding
extension methods.
Extension methods take a special first parameter that designates the original type being extended. This first
parameter is decorated with the keyword this (which constitutes a special and distinct use of this in C#—it should
be understood as different from the use of this which allows referring to members of the current object instance).
In the following example, the original type being extended is the class string. String has been extended by a
method Shorten(), which provides the additional functionality of shortening. The static class StringExtensions
has been created to hold the extension method. The extension method Shorten() shows that it is an extension of
string via the specially marked first parameter. To show that the Shorten() method extends string, the first
parameter is marked with this. Therefore, the full signature of the first parameter is this string text, where
string is the original type being extended and text is the chosen parameter name.

<pre><code>static class StringExtensions
  {
    public static string Shorten(this string text, int length)
    {
      return text.Substring(0, length);
    }
  }
  class Program
  {
    static void Main()
    {
      // This calls method String.ToUpper()
      var myString = "Hello World!".ToUpper();
      // This calls the extension method StringExtensions.Shorten()
      var newString = myString.Shorten(5);
      // It is worth noting that the above call is purely syntactic sugar
      // and the assignment below is functionally equivalent
      var newString2 = StringExtensions.Shorten(myString, 5);
    }
  }</code></pre>
  The object passed as the first argument of an extension method (which is accompanied by the this keyword) is the
  instance the extension method is called upon.
  For example, when this code is executed:

  "some string".Shorten(5);
  
  The values of the arguments are as below:
  text: "some string"
  length: 5
  Note that extension methods are only usable if they are in the same namespace as their definition, if the namespace is
  imported explicitly by the code using the extension method, or if the extension class is namespace-less. The .NET
  framework guidelines recommend putting extension classes in their own namespace. However, this may lead to
  discovery issues.
  This results in no conflicts between the extension methods and the libraries being used, unless namespaces which
  might conflict are explicitly pulled in. For example LINQ Extensions:
<pre><code>using System.Linq; // Allows use of extension methods from the System.Linq namespace
  class Program
  {
    static void Main()
    {
      var ints = new int[] {1, 2, 3, 4};
      // Call Where() extension method from the System.Linq namespace
      var even = ints.Where(x => x % 2 == 0);
    }
  }</code></pre>
  Since C# 6.0, it is also possible to put a using static directive to the class containing the extension methods. For
  example, using static System.Linq.Enumerable;. This makes extension methods from that particular class
  available without bringing other types from the same namespace into scope.
  When a class method with the same signature is available, the compiler prioritizes it over the extension method
  call. For example:
 <pre><code>class Test
  {
    public void Hello()
    {
      Console.WriteLine("From Test");
    }
  }
  static class TestExtensions
  {
    public static void Hello(this Test test)
    {
      Console.WriteLine("From extension method");
    }
  }

  class Program
  {
    static void Main()
    {
      Test t = new Test();
      t.Hello(); // Prints "From Test"
    }
  }
</code></pre> 
Note that if there are two extension functions with the same signature, and one of them is in the same namespace,
then that one will be prioritized. On the other hand, if both of them are accessed by using, then a compile time
error will ensue with the message:
The call is ambiguous between the following methods or properties
Note that the syntactic convenience of calling an extension method via originalTypeInstance.ExtensionMethod()
is an optional convenience. The method can also be called in the traditional manner, so that the special first
parameter is used as a parameter to the method.
I.e., both of the following work:
<pre><code>//Calling as though method belongs to string--it seamlessly extends string
  String s = "Hello World";
  s.Shorten(5);
  //Calling as a traditional static method with two parameters
  StringExtensions.Shorten(s, 5);</code></pre>
<h3>Null checking</h3>
Extension methods are static methods which behave like instance methods. However, unlike what happens when
calling an instance method on a null reference, when an extension method is called with a null reference, it does
not throw a NullReferenceException. This can be quite useful in some scenarios.
For example, consider the following static class:
<pre><code>public static class StringExtensions
  {
    public static string EmptyIfNull(this string text)
    {
      return text ?? String.Empty;
    }
    public static string NullIfEmpty(this string text)
    {
      return String.Empty == text ? null : text;
    }
  }
  string nullString = null;
  string emptyString = nullString.EmptyIfNull();// will return ""
  string anotherNullString = emptyString.NullIfEmpty(); // will return null</code></pre>

<h3>Explicitly using an extension method</h3>
Extension methods can also be used like ordinary static class methods. 
This way of calling an extension method is
more verbose, but is necessary in some cases
<pre><code>static class StringExtensions
  {
    public static string Shorten(this string text, int length)
    {
      return text.Substring(0, length);
    }
  }</code></pre>
  Usage:
 
  <pre><code> var newString = StringExtensions.Shorten("Hello World", 5);</code></pre>
  When to call extension methods as static methods
  There are still scenarios where you would need to use an extension method as a static method:
    . Resolving conflict with a member method. 
      This can happen if a new version of a library introduces a new member method with the same signature. 
      In this case, the member method will be preferred by the compiler.
    . Resolving conflicts with another extension method with the same signature. 
      This can happen if two libraries include similar extension methods and 
      namespaces of both classes with extension methods are used in the same file.
    . Passing extension method as a method group into delegate parameter.
    . Doing your own binding through Reflection.
    . Using the extension method in the Immediate window in Visual Studio.
  Using static
    If a using static directive is used to bring static members of a static class into global scope, extension methods
    are skipped. Example:
    using static OurNamespace.StringExtensions; // refers to class in previous example
    // OK: extension method syntax still works.
    "Hello World".Shorten(5);
    // OK: static method syntax still works.
    OurNamespace.StringExtensions.Shorten("Hello World", 5);
    // Compile time error: extension methods can't be called as static without specifying class.
    Shorten("Hello World", 5);
    If you remove the this modifier from the first argument of the Shorten method, the last line will compile
<h3>Generic Extension Methods</h3>
Just like other methods, extension methods can use generics. For example:
<pre><code>static class Extensions
  {
    public static bool HasMoreThanThreeElements<T>(this IEnumerable<T> enumerable)
    {
      return enumerable.Take(4).Count() > 3;
    }
  }
  // and calling it would be like:
  IEnumerable<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
  var hasMoreThanThreeElements = numbers.HasMoreThanThreeElements();
  
  //Likewise for multiple Type Arguments:
  public static TU GenericExt<T, TU>(this T obj)
    {
      TU ret = default(TU);
      // do some stuff with obj
      return ret;
    }
  //Calling it would be like:
  IEnumerable<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
  var result = numbers.GenericExt<IEnumerable<int>, String>();
  
  // Likewise for multiple Type Arguments:
  public static TU GenericExt<T, TU>(this T obj)
    {
      TU ret = default(TU);
      // do some stuff with obj
      return ret;
    }
  // Calling it would be like:
  IEnumerable<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
  var result = numbers.GenericExt<IEnumerable<int>, String>();\
  //You can also specify type constraints with where :
  public static bool IsDefault<T>(this T obj) where T : struct, IEquatable<T>
  {
    return EqualityComparer<T>.Default.Equals(obj, default(T));
  }
  //Calling code:
  int number = 5;
  var IsDefault = number.IsDefault();
  </code></pre>

<h3>Extension methods can only see public (or
  internal) members of the extended class</h3>
<pre><code>public class SomeClass
  {
    public void DoStuff()
    {
    }
    protected void DoMagic()
    {
    }
  }
  public static class SomeClassExtensions
  {
    public static void DoStuffWrapper(this SomeClass someInstance)
    {
      someInstance.DoStuff(); // ok
    }
    public static void DoMagicWrapper(this SomeClass someInstance)
    {
      someInstance.DoMagic(); // compilation error
    }
  }</code></pre>
  Extension methods are just a syntactic sugar, and are not actually members of the class they extend. This means
  that they cannot break encapsulation—they only have access to public (or when implemented in the same
  assembly, internal) fields, properties and methods.
<h3>Extension methods for chaining</h3>

When an extension method returns a value that has the same type as its this argument, it can be used to "chain"
one or more method calls with a compatible signature. This can be useful for sealed and/or primitive types, and
allows the creation of so-called "fluent" APIs if the method names read like natural human language.
<pre><code>void Main()
  {
    int result = 5.Increment().Decrement().Increment();
    // result is now 6
  }
  public static class IntExtensions
  {
    public static int Increment(this int number)
    {
      return ++number;
    }
    public static int Decrement(this int number)
    {
      return --number;
    }
  }
//Or like this
void Main()
{
  int[] ints = new[] { 1, 2, 3, 4, 5, 6 };
  int[] a = ints.WhereEven();
  //a is { 2, 4, 6 };
  int[] b = ints.WhereEven().WhereGreaterThan(2);
  //b is { 4, 6 };
}
public static class IntArrayExtensions
{
  public static int[] WhereEven(this int[] array)
  {
    //Enumerable.* extension methods use a fluent approach
    return array.Where(i => (i % 2) == 0).ToArray();
  }
  public static int[] WhereGreaterThan(this int[] array, int value)
  {
    return array.Where(i => i > value).ToArray();
  }
}
</code></pre>

<h3>Extension methods with Enumeration</h3>
Extension methods are useful for adding functionality to enumerations.
One common use is to implement a conversion method
<pre><code>public enum YesNo
  {
    Yes,
    No,
  }
  public static class EnumExtentions
  {
    public static bool ToBool(this YesNo yn)
    {
      return yn == YesNo.Yes;
    }
    public static YesNo ToYesNo(this bool yn)
    {
      return yn ? YesNo.Yes : YesNo.No;
    }
  }
  // Now you can quickly convert your enum value to a different type.In this case a bool.
  bool yesNoBool = YesNo.Yes.ToBool(); // yesNoBool == true
  YesNo yesNoEnum = false.ToYesNo(); // yesNoEnum == YesNo.No
  // Alternatively extension methods can be used to add property like methods.
  public enum Element
  {
    Hydrogen,
    Helium,
    Lithium,
    Beryllium,
    Boron,
    Carbon,
    Nitrogen,
    Oxygen
    //Etc
  }
  public static class ElementExtensions
  {
    public static double AtomicMass(this Element element)
    {
      switch (element)
      {
        case Element.Hydrogen: return 1.00794;
        case Element.Helium: return 4.002602;
        case Element.Lithium: return 6.941;
        case Element.Beryllium: return 9.012182;
        case Element.Boron: return 10.811;
        case Element.Carbon: return 12.0107;
        case Element.Nitrogen: return 14.0067;
        case Element.Oxygen: return 15.9994;
          //Etc
      }
      return double.Nan;
    }
  }
  var massWater = 2 * Element.Hydrogen.AtomicMass() + Element.Oxygen.AtomicMass();
</code></pre>

<h3>Extension methods dispatch based on static</h3>
<pre><code>The static (compile-time) type is used rather than the dynamic(run - time type) to match parameters.
  public class Base
  {
    public virtual string GetName()
    {
      return "Base";
    }
  }
  public class Derived : Base
  {
    public override string GetName()
    {
      return "Derived";
    }
  }
  public static class Extensions
  {
    public static string GetNameByExtension(this Base item)
    {
      return "Base";
    }
    public static string GetNameByExtension(this Derived item)
    {
      return "Derived";
    }
  }
  public static class Program
  {
    public static void Main()
    {
      Derived derived = new Derived();
      Base @base = derived;
      // Use the instance method "GetName"
      Console.WriteLine(derived.GetName()); // Prints "Derived"
      Console.WriteLine(@base.GetName()); // Prints "Derived"
                        // Use the static extension method "GetNameByExtension"
      Console.WriteLine(derived.GetNameByExtension()); // Prints "Derived"
      Console.WriteLine(@base.GetNameByExtension()); // Prints "Base"
    }
  }
  //Also the dispatch based on static type does not allow an extension method to be called on a dynamic object:
  public class Person
  {
    public string Name { get; set; }
  }
  public static class ExtenionPerson
  {
    public static string GetPersonName(this Person person)
    {
      return person.Name;
    }
  }
  dynamic person = new Person { Name = "Jon" };
  var name = person.GetPersonName(); // RuntimeBinderException is thrown
</code></pre>

<h3>Extension methods on Interfaces</h3>
One useful feature of extension methods is that you can create common methods for an interface.
 Normally an interface cannot have shared implementations, but with extension methods they can
<pre><code>public interface IVehicle
  {
    int MilesDriven { get; set; }
  }
  public static class Extensions
  {
    public static int FeetDriven(this IVehicle vehicle)
    {
      return vehicle.MilesDriven * 5028;
    }
  }</code></pre>
  In this example, the method FeetDriven can be used on any IVehicle. 
  This logic in this method would apply to all
  IVehicles, so it can be done this way so that there doesn't have to be a FeetDriven in the IVehicle definition
  which would be implemented the same way for all children.
 <h3>Extension methods in combination with interfaces</h3>
 It is very convenient to use extension methods with interfaces as implementation can be stored outside of class and
 all it takes to add some functionality to class is to decorate class with interface.
<pre><code>{
  string Do()
}
public static class ExtensionMethods
{
  public static string DoWith(this IInterface obj)
  {
    //does something with IInterface instance
  }
}
public class Classy : IInterface
{
  // this is a wrapper method; you could also call DoWith() on a Classy instance directly,
  // provided you import the namespace containing the extension method
  public Do()
  {
    return this.DoWith();
  }
}
// use like:
var classy = new Classy();
classy.Do(); // will call the extension
classy.DoWith(); // Classy implements IInterface so it can also be called this way
</code></pre> 
<h3>Extension methods aren't supported by  dynamic code</h3>
<pre><code>
  class Program
  {
    static void Main()
    {
      dynamic dynamicObject = new ExpandoObject();
      string awesomeString = "Awesome";
      // Prints True
      Console.WriteLine(awesomeString.IsThisAwesome());
      dynamicObject.StringValue = awesomeString;
      // Prints True
      Console.WriteLine(StringExtensions.IsThisAwesome(dynamicObject.StringValue));
      // No compile time error or warning, but on runtime throws RuntimeBinderException
      Console.WriteLine(dynamicObject.StringValue.IsThisAwesome());
    }
  }
  static class StringExtensions
  {
    public static bool IsThisAwesome(this string value)
    {
      return value.Equals("Awesome");
    }
  }
</code></pre>

<h3>Extensions and interfaces together enable DRY code and mixin-like functionality</h3>
Extension methods enable you to simplify your interface definitions by only including core required functionality in
the interface itself and allowing you to define convenience methods and overloads as extension methods.
Interfaces with fewer methods are easier to implement in new classes. Keeping overloads as extensions rather than
including them in the interface directly saves you from copying boilerplate code into every implementation, helping
you keep your code DRY. This in fact is similar to the mixin pattern which C# does not support.
System.Linq.Enumerable’s extensions to IEnumerable< T> is a great example of this. IEnumerable<T> only requires
the implementing class to implement two methods: generic and non-generic GetEnumerator(). But
System.Linq.Enumerable provides countless useful utilities as extensions enabling concise and clear consumption
of IEnumerable< T>.
The following is a very simple interface with convenience overloads provided as extensions.
<pre><code>public interface ITimeFormatter
  {
    string Format(TimeSpan span);
  }
  public static class TimeFormatter
  {
    // Provide an overload to *all* implementers of ITimeFormatter.
    public static string Format(
    this ITimeFormatter formatter,
    int millisecondsSpan)
    => formatter.Format(TimeSpan.FromMilliseconds(millisecondsSpan));
  }
  // Implementations only need to provide one method. Very easy to
  // write additional implementations.
  {
    public string Format(TimeSpan span)
    {
      return $"{(int)span.TotalSeconds}s";
    }
  }
  class Program
  {
    static void Main(string[] args)
    {
      var formatter = new SecondsTimeFormatter();
      // Callers get two method overloads!
      Console.WriteLine($"4500ms is rougly {formatter.Format(4500)}");
      var span = TimeSpan.FromSeconds(5);
      Console.WriteLine($"{span} is formatted as {formatter.Format(span)}");
    }
  }</code></pre>

<h3>IList<T> Extension Method Example: Comparing 2 Lists</h3>
  You can use the following extension method for comparing the contents of two IList< T > instances of the same
  type.
  By default the items are compared based on their order within the list and the items themselves, passing false to
  the isOrdered parameter will compare only the items themselves regardless of their order.
  For this method to work, the generic type (T) must override both Equals and GetHashCode methods.
  Usage:
<pre><code>
  List< string> list1 = new List< string> {"a1", "a2", null, "a3"};
  List< string> list2 = new List< string> {"a1", "a2", "a3", null};
  list1.Compare(list2);//this gives false
  list1.Compare(list2, false);//this gives true. they are equal when the order is disregarded</code></pre>

Method:
<pre><code>
  public static bool Compare<T>(this IList<T> list1, IList<T> list2, bool isOrdered = true)
    {
      if (list1 == null && list2 == null)
        return true;
      if (list1 == null || list2 == null || list1.Count != list2.Count)
        return false;
      if (isOrdered)
      {
        for (int i = 0; i < list2.Count; i++)
        {
          var l1 = list1[i];
          var l2 = list2[i];
          if (
          (l1 == null && l2 != null) ||
          (l1 != null && l2 == null) ||
          (!l1.Equals(l2)))
          {
            return false;
          }
        }
        return true;
      }
      else
      {
        List<T> list2Copy = new List<T>(list2);
        //Can be done with Dictionary without O(n^2)
        for (int i = 0; i < list1.Count; i++)
        {
          if (!list2Copy.Remove(list1[i]))
            return false;
        }
        return true;
      }
    }
</code></pre>


<h3>Extension methods as strongly typed wrappers</h3>
Extension methods can be used for writing strongly typed wrappers for dictionary-like objects. 
For example a cache,
HttpContext.Items at cetera...
<pre><code>
  public static class CacheExtensions
  {
    public static void SetUserInfo(this Cache cache, UserInfo data) =>
       cache["UserInfo"] = data;
    public static UserInfo GetUserInfo(this Cache cache) =>
       cache["UserInfo"] as UserInfo;
  }
</code></pre>
This approach removes the need of using string literals as keys all over the codebase as well as the need of casting
to the required type during the read operation. 
Overall it creates a more secure, strongly typed way of interacting
with such loosely typed objects as Dictionaries.
<h3>Using Extension methods to create beautiful mapper classes</h3>
We can create a better mapper classes with extension methods, Suppose if i have some DTO classes like
<pre><code>class UserDTO
  {
    public AddressDTO Address { get; set; }
  }
  public class AddressDTO
  {
    public string Name { get; set; }
  }
  // and i need to map to corresponding view model classes
  public class UserViewModel
  {
    public AddressViewModel Address { get; set; }
  }

  public class AddressViewModel
  {
    public string Name { get; set; }
  }
  then I can create my mapper class like below
  public static class ViewModelMapper
  {
    public static UserViewModel ToViewModel(this UserDTO user)
    {
      return user == null ?
      null :
      new UserViewModel()
      {
        Address = user.Address.ToViewModel()
    // Job = user.Job.ToViewModel(),
    // Contact = user.Contact.ToViewModel() .. and so on
  };
    }
    public static AddressViewModel ToViewModel(this AddressDTO userAddr)
    {
      return userAddr == null ?
      null :
      new AddressViewModel()
      {
        Name = userAddr.Name
      };
    }
  }
  Then finally i can invoke my mapper like below
  UserDTO userDTOObj = new UserDTO()
  {
    Address = new AddressDTO()
    {
      Name = "Address of the user"
    }
  };
  UserViewModel user = userDTOObj.ToViewModel(); // My DTO mapped to Viewmodel
  The beauty here is all the mapping method have a common name(ToViewModel) and we can reuse it several ways
</code></pre>

<h3>Using Extension methods to build new collection types (e.g. DictList)</h3>
<pre><code>
  You can create extension methods to improve usability for nested collections like a Dictionary with a List < T >
  value.
  Consider the following extension methods:
  public static class DictListExtensions
  {
    public static void Add< TKey, TValue, TCollection>(this Dictionary< TKey, TCollection> dict, TKey
    key, TValue value)
    where TCollection : ICollection< TValue>, new()
    {
      TCollection list;
      if (!dict.TryGetValue(key, out list))
      {
        list = new TCollection();
        dict.Add(key, list);
      }
      list.Add(value);
    }
    public static bool Remove< TKey, TValue, TCollection>(this Dictionary< TKey, TCollection> dict,
    TKey key, TValue value)
    where TCollection : ICollection< TValue>
    {
      TCollection list;
      if (!dict.TryGetValue(key, out list))
      {
        return false;
      }
      var ret = list.Remove(value);
      if (list.Count == 0)
      {
        dict.Remove(key);
      }
      return ret;
    }
  }
  you can use the extension methods as follows:
  var dictList = new Dictionary< string, List< int>>();
  dictList.Add("example", 5);
  dictList.Add("example", 10);
  dictList.Add("example", 15);
  Console.WriteLine(String.Join(", ", dictList["example"])); // 5, 10, 15
  dictList.Remove("example", 5);
  dictList.Remove("example", 10);
  Console.WriteLine(String.Join(", ", dictList["example"])); // 15
  dictList.Remove("example", 15);
  Console.WriteLine(dictList.ContainsKey("example")); // False
</code></pre>

<h3>Extension methods for handling special cases</h3>
Extension methods can be used to "hide" processing of inelegant business rules that would otherwise require
cluttering up a calling function with if/then statements. This is similar to and analogous to handling nulls with
extension methods. For example,
<pre><code>public static class CakeExtensions
  {
    public static Cake EnsureTrueCake(this Cake cake)
    {
      //If the cake is a lie, substitute a cake from grandma, whose cakes aren't as tasty but are
      //known never to be lies.If the cake isn't a lie, don't do anything and return it.
  return CakeVerificationService.IsCakeLie(cake) ? GrandmasKitchen.Get1950sCake() : cake;
    }
  }
  Cake myCake = Bakery.GetNextCake().EnsureTrueCake();
  myMouth.Eat(myCake);//Eat the cake, confident that it is not a lie.</code></pre>

<h3>Using Extension methods with Static methods and Callbacks</h3>
Consider using Extension Methods as Functions which wrap other code, here's a great example that uses both a
static method and and extension method to wrap the Try Catch construct. Make your code Bullet Proof...
<pre><code>
  namespace Samples
  {
    /// <summary>
    /// Wraps a try catch statement as a static helper which uses
    /// Extension methods for the exception
    /// </summary>
    public static class Bullet
    {
      /// <summary>
      /// Wrapper for Try Catch Statement
      /// </summary>
      /// <param name="code">Call back for code</param>
      /// <param name="error">Already handled and logged exception</param>
      public static void Proof(Action code, Action<Exception> error)
      {
        try
        {
          code();
        }
        catch (Exception iox)
        {
          //extension method used here
          iox.Log("BP2200-ERR-Unexpected Error");
          //callback, exception already handled and logged
          error(iox);
        }
      }
      /// <summary>
      /// Example of a logging method helper, this is the extension method
      /// </summary>
      /// <param name="error">The Exception to log</param>
      /// <param name="messageID">A unique error ID header</param>
      public static void Log(this Exception error, string messageID)
      {
        Trace.WriteLine(messageID);
        Trace.WriteLine(error.Message);
        Trace.WriteLine(error.StackTrace);
        Trace.WriteLine("");
      }
    }
    /// <summary>
    /// Shows how to use both the wrapper and extension methods.
    /// </summary>
  public class UseBulletProofing
  {
  public UseBulletProofing()
    {
      var ok = false;
      var result = DoSomething();
      if (!result.Contains("ERR"))
      {
        ok = true;
        DoSomethingElse();
      }
    }
    /// <summary>
    /// How to use Bullet Proofing in your code.
    /// </summary>
    /// <returns>A string</returns>
    public string DoSomething()
    {
      string result = string.Empty;
      //Note that the Bullet.Proof method forces this construct.
      Bullet.Proof(() =>
      {
    //this is the code callback
    result = "DST5900-INF-No Exceptions in this code";
      }, error =>
      {
    //error is the already logged and handled exception
    //determine the base result
    result = "DTS6200-ERR-An exception happened look at console log";
        if (error.Message.Contains("SomeMarker"))
        {
      //filter the result for Something within the exception message
      result = "DST6500-ERR-Some marker was found in the exception";
        }
      });
      return result;
    }
    /// <summary>
    /// Next step in workflow
    /// </summary>
    public void DoSomethingElse()
    {
      //Only called if no exception was thrown before
    }
  }
  }
</code></pre>


</div>

<h2>Named Arguments</h2>
<div>


<h3>Argument order is not necessary</h3>
You can place named arguments in any order you want.
Sample Method:
<pre><code>
  public static string Sample(string left, string right)
  {
    return string.Join("-",left,right);
  }
  //Call Sample:
  Console.WriteLine (Sample(left:"A",right:"B"));
  Console.WriteLine (Sample(right:"A",left:"B"));
  /*Results:
  A-B
  B-A*/
</code></pre>

<h3>Named arguments and optional parameters</h3>
<pre><code>You can combine named arguments with optional parameters.
  Let see this method:
  public sealed class SmsUtil
  {
    public static bool SendMessage(string from, string to, string message, int retryCount = 5,
    object attachment = null)
    {
      // Some code
    }
  }
  When you want to call this method without set retryCount argument:
  var result = SmsUtil.SendMessage(
  from: "Cihan",
  to: "Yakar",
  message: "Hello there!",
  attachment: new object());</code></pre>

<h3>Named Arguments can make your code more
  clear</h3>
<pre><code>Consider this simple class:
  class SmsUtil
  {
    public bool SendMessage(string from, string to, string message, int retryCount, object
    attachment)
    {
      // Some code
    }
  }
  Before C# 3.0 it was:
  var result = SmsUtil.SendMessage("Mehran", "Maryam", "Hello there!", 12, null);
  you can make this method call even more clear with named arguments:
  var result = SmsUtil.SendMessage(
  from: "Mehran",
  to: "Maryam",
  message "Hello there!",
  retryCount: 12,
  attachment: null);</code></pre>
</div>

<h2>Named and Optional Arguments</h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

</body>

</html>
<!--script>
 //$('code').addClass('language-csharp hljs');
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((el) => {
    hljs.highlightElement(el);
  });
});
</script-->