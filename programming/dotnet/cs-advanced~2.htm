<head<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/nhab/assets/css/blocks.css">
<script src='/nhab/assets/js/blocks.js'></script>
<link rel="stylesheet" href="/nhab/libs/highlight/androidstudio2.css">
<!--https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/androidstudio.min.css"-->
<!--github-dark.min.css-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"
  integrity="sha512-9ia7twbVj1OAzFDTFTzf/x2LrAc/Hf1KlzHTbyxfJZXA+YQP2eXOFWr7E3ZZ6SgtAZZza2PDXvcQjXQ5nZ9GAw=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>

<body onload="AddToggleButtons()">
  <button onclick="toggleAll(this);">-</button>
  <h2>Resources</h2>
  <div>
    <a href='https://learn.microsoft.com/en-us/dotnet/csharp/'>Microsoft C# Reference and other resources</a>
    <a href='https://www.tutorialsteacher.com/csharp/csharp-generics'>generics</a>
    <a href='https://www.albahari.com/nutshell/code.aspx'>in a nutshell</a>
  </div>
  <h2>Extension Method Chaining</h2>
  <div>
      Extension methods, like instance methods, provide a tidy way to chain functions:
  <pre><code>
string x = "sausage".Pluralize().Capitalize();
x.Dump();

// Equivalent to:
string y = StringHelper.Capitalize (StringHelper.Pluralize ("sausage"));
y.Dump();

// LINQPad's Dump method is an extension method:
"sausage".Pluralize().Capitalize().Dump();

public static class StringHelper
{
  public static string Pluralize (this string s) => s + "s";   // Very naiive implementation!

  public static string Capitalize (this string s) => s.ToUpper();
}
</code></pre>    
  </div>  
  <h2>Anonymous Types</h2>
  <div>
An anonymous type is a simple class created by the compiler on the fly to store a set of values
<code>
var dude = new { Name = "Bob", Age = 23 };

//Anonymous Types - with keyword

    var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
    var a2 = a1 with { E = 10 };
    a2.Dump();
</code>    
  </div>
 <h2>Record</h2>
 <div>
 new in C# 9.0
- defines a reference type that provides built-in functionality for encapsulating data.
Defining a record
<pre><code>
new Point (2, 3).Dump();

// Run the line below to look at Point in ILSpy.
// Util.OpenILSpy (typeof (Point));

record Point
{
  public Point (double x, double y) => (X, Y) = (x, y);

  public double X { get; init; }
  public double Y { get; init; }    
}
</code></pre>
- Record types have a compiler-generated ToString method 
that displays the names and values of public properties and fields.
- A record can inherit from another record.
  However, a record can't inherit from a class, and a class can't inherit from a record.
- For two record variables to be equal, the run-time type must be equal. 
The types of the containing variables might be different.
<b>Dynamic Type</b>
is to avoid compile-time type checking.
The dynamic type changes its type at the run time based on the value present on the right-hand side
<pre><code>
    dynamic value = 123;
</code></pre>
 </div>
<h2>Unsafe code (using pointers)</h2>
<div>
<pre><code>
//    Unsafe Code

// C# supports direct memory manipulation via pointers within blocks of code marked unsafe
// and compiled with the /unsafe compiler option. LINQPad implicitly compiles with this option.

// Here's how to use pointers to quickly process a bitmap:

int [,] bitmap = { { 0x101010, 0x808080, 0xFFFFFF }, { 0x101010, 0x808080, 0xFFFFFF } };
BlueFilter (bitmap);
bitmap.Dump();

unsafe static void BlueFilter (int [,] bitmap)
{
  int length = bitmap.Length;
  fixed (int* b = bitmap)
  {
    int* p = b;
    for (int i = 0; i < length; i++)
      *p++ &= 0xFF;
  }
}
</code></pre>
</div>
<h2>Regx Parsing</h2>
<div>
Pattern The string pattern that has to be used for the lookup. 
The common options in here are Singleline and Multiline. They are changing the
behaviour of pattern-elements like the dot (.) which won't cover a NewLine (\n) in
Multiline-Mode but in SingleLine-Mode. Default behaviour: msdn
Timeout [Optional] Where patterns are getting more complex the lookup can consume more time.
 This is the
passed timeout for the lookup just as known from network-programming.
<b>Single match</b>
<pre><code>
 using System.Text.RegularExpressions;
string pattern = ":(.*?):";
string lookup = "--:text in here:--";
// Instanciate your regex object and pass a pattern to it
Regex rgxLookup = new Regex(pattern, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
// Get the match from your regex-object
Match mLookup = rgxLookup.Match(lookup);
// The group-index 0 always covers the full pattern.
// Matches inside parentheses will be accessed through the index 1 and above.
string found = mLookup.Groups[1].Value;
Result:
found = "text in here" 
</code></pre>
    <b>Multiple matches</b>
    <pre><code>
  using System.Text.RegularExpressions;
  List<string> found = new List<string>();
  string pattern = ":(.*?):";
  string lookup = "--:text in here:--:another one:-:third one:---!123:fourth:";
  // Instanciate your regex object and pass a pattern to it
  Regex rgxLookup = new Regex(pattern, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
  MatchCollection mLookup = rgxLookup.Matches(lookup);
  foreach(Match match in mLookup)
  {
  found.Add(match.Groups[1].Value);
  }
  Result:
  found = new List<string>() { "text in here", "another one", "third one", "fourth" }  
</code></pre>

  </div>

<h2>ToString()</h2>
  <div>
    The ToString() method is present on all reference object types.
    This is due to all reference types being derived from Object which has the ToString() method on it.
    The ToString() method on the object base class returns the type name.
    The fragment below will print out "User" to the console.
    <pre><code>
public class User
{
public string Name { get; set; }
public int Id { get; set; }
}
...
var user = new User {Name = "User1", Id = 5};
Console.WriteLine(user.ToString());

//However, the class User can also override ToString() in order to alter the string it returns. 
//The code fragment below prints out "Id: 5, Name: User1" to the console.
public class User
  {
  public string Name { get; set; }
  public int Id { get; set; }
  public override ToString()
  {
    return string.Format("Id: {0}, Name: {1}", Id, Name);
  }
}
...
var user = new User {Name = "User1", Id = 5};
Console.WriteLine(user.ToString());

string outsidetext = "I am outside of bracket";
string.Format("{{I am in brackets!}} {0}", outsidetext);
//Outputs "{I am in brackets!} I am outside of bracket"
</code></pre>
</div>
<h2>Formatting</h2>
  <div>
    <b>Numeric formats</b>
    <pre><code>
  // Integral types as hex
  string.Format("Hexadecimal: byte2: {0:x2}; byte4: {0:X4}; char: {1:x2}", 123, (int)'A');
  // Integers with thousand separators
  string.Format("Integer, thousand sep.: {0:#,#}; fixed length: >{0,10:#,#}<", 1234567);
  // Integer with leading zeroes
  string.Format("Integer, leading zeroes: {0:00}; ", 1);
  // Decimals
  string.Format("Decimal, fixed precision: {0:0.000}; as percents: {0:0.00%}", 0.12);
  Output:
  Hexadecimal: byte2: 7b; byte4: 007B; char: 41
  Integer, thousand sep.: 1,234,567; fixed length: > 1,234,567<
  Integer, leading zeroes: 01;
  Decimal, fixed precision: 0.120; as percents: 12.00%
</code></pre>
    <b>custom number format</b>
    <pre><code>
  // invariantResult is "1,234,567.89"
  var invarianResult = string.Format(CultureInfo.InvariantCulture, "{0:#,###,##}", 1234567.89);
  // NumberFormatInfo is one of classes that implement IFormatProvider
  var customProvider = new NumberFormatInfo
  {
  NumberDecimalSeparator = "_NS_", // will be used instead of ','
  NumberGroupSeparator = "_GS_", // will be used instead of '.'
  };
  // customResult is "1_GS_234_GS_567_NS_89"
  var customResult = string.Format(customProvider, "{0:#,###.##}", 1234567.89);  
</code></pre>
    <b>String formatting</b>
    <pre><code class="csharp">
// float with two decimal places
String.Format("{0:0.00}", 123.4567);      // "123.46"
String.Format("{0:0.00}", 123.4);         // "123.40"
String.Format("{0:0.00}", 123.0);         // "123.00"

//Since C# 6.0 it is possible to use string interpolation in place of String.Format.
string name = "John";
string lastname = "Doe";
Console.WriteLine($"Hello {name} {lastname}!");//Hello John Doe!

</code></pre>
    <b>Formatting using ToString</b>
    <pre><code>
 // Integer to formatted string:
  int intValue = 10;
  string zeroPaddedInteger = intValue.ToString("000"); // Output will be "010"
  string customFormat = intValue.ToString("Input value is 0"); // output will be "Input value is 10"
 // double to formatted string:
  double doubleValue = 10.456;
  string roundedDouble = doubleValue.ToString("0.00"); // output 10.46
  string integerPart = doubleValue.ToString("00"); // output 10
  string customFormat = doubleValue.ToString("Input value is 0.0"); // Input value is 10.5
 // Formatting DateTime using ToString
  DateTime currentDate = DateTime.Now; // {7/21/2016 7:23:15 PM}
  string dateTimeString = currentDate.ToString("dd-MM-yyyy HH:mm:ss"); // "21-07-2016 19:23:15"
  string dateOnlyString = currentDate.ToString("dd-MM-yyyy"); // "21-07-2016"
  string dateWithMonthInWords = currentDate.ToString("dd-MMMM-yyyy HH:mm:ss"); // "21-July-2016 19:23:15"
</code></pre>
    <b>Create a custom format provider</b>
    <pre><code>
  public class CustomFormat : IFormatProvider, ICustomFormatter
  {
    public string Format(string format, object arg, IFormatProvider formatProvider)
    {
      if (!this.Equals(formatProvider))
      {
        return null;
      }
      if (format == "Reverse")
      {
        return String.Join("", arg.ToString().Reverse());
      }
      return arg.ToString();
    }
    public object GetFormat(Type formatType)
    {
        return formatType==typeof(ICustomFormatter) ? this:null;
    }
  }
  //Usage:
    String.Format(new CustomFormat(), "-> {0:Reverse} <-", "Hello World");//Output:    -> dlroW olleH <-
</code></pre>
    <b>Format dates in strings</b>
    <pre><code>
  var date = new DateTime(2015, 11, 11);
  var str = $"It's {date:MMMM d, yyyy}, make a wish!";
  System.Console.WriteLine(str);
  
 // You can also use the DateTime.ToString method to format the DateTime object. This will produce the same output
 // as the code above.

  var date = new DateTime(2015, 11, 11);
  var str = date.ToString("MMMM d, yyyy");
  str = "It's " + str + ", make a wish!";
  Console.WriteLine(str);// Output:  It's November 11, 2015, make a wish!
</code></pre>
    <b>Align left/ right, pad with spaces</b>
    <pre><code>
  string.Format("LEFT: string: ->{0,-5}<- int: ->{1,-5}<-", "abc", 123);
  string.Format("RIGHT: string: ->{0,5}<- int: ->{1,5}<-", "abc", 123);
  Output:
  LEFT: string: ->abc <- int: ->123 <-
  RIGHT: string: -> abc<- int: -> 123<-  
</code></pre>
    <b>Padding with Format Specifiers</b>
    You can also use existing formatting specifiers in conjunction with padding.
    <pre><code>
var number = 42;
var str = $"The answer to life, the universe and everything is ${number, 5:f1}";
//str is "The answer to life, the universe and everything is 42.1 ";
//                                                           ^^^^^  
</code></pre>
</div>

<h2>Strings</h2>
  <div>
    <b>Expressions</b>
    <pre><code>
  var StrWithMathExpression = $"1 + 2 = {1 + 2}"; // -> "1 + 2 = 3"
  string world = "world";
  var StrWithFunctionCall = $"Hello, {world.ToUpper()}!"; // -> "Hello, WORLD!"
</code></pre>
    <b>Splitting a String by another string</b>
    <pre><code>
  string str = "this--is--a--complete--sentence";
  string[] tokens = str.Split(new[] { "--" }, StringSplitOptions.None);
 // Result:
//  [ "this", "is", "a", "complete", "sentence" ] 
</code></pre>
    <b>Splitting a String by specific character</b>
    <pre><code>
  string helloWorld = "hello world, how is it going?";
  string[] parts1 = helloWorld.Split(',');
  //parts1: ["hello world", " how is it going?"]
  string[] parts2 = helloWorld.Split(' ');
  //parts2: ["hello", "world,", "how", "is", "it", "going?"]
</code></pre>
    other things:
    <pre><code>
  string helloWorld = "Hello World!";

  string world = helloWorld.Substring(6); //world = "World!"
  string hello = helloWorld.Substring(0,5); // hello = "Hello"

  HelloWorld.StartsWith("Hello"); // true
  HelloWorld.StartsWith("Foo"); // false

  bool stringExists = s.Contains("ello"); //stringExists =true as the string contains the substring

  char c = s[1]; //Returns 'e'
</code></pre>
    <b>Joining an array of strings into a new one</b>
    <pre><code>
  var parts = new[] { "Foo", "Bar", "Fizz", "Buzz"};
  var joined = string.Join(", ", parts);
  //joined = "Foo, Bar, Fizz, Buzz" 
</code></pre>
<b>Replacing a string within a string</b>
<pre><code>
string s = "Hello World";

s = s.Replace("World", "Universe"); // s = "Hello Universe"  

//This method can also be used to remove part of a string, using the String.Empty field:
s = s.Replace("ell", String.Empty); // s = "Ho World"
</code></pre>
<b>Changing the case of characters within a String</b>
System.String.ToLowerInvariant is used to return a String object converted to lowercase.
System.String.ToUpperInvariant is used to return a String object converted to uppercase
<pre><code>
string s = "My String";
s = s.ToLowerInvariant(); // "my string"
s = s.ToUpperInvariant(); // "MY STRING"
</code></pre>
    <b>Concatenating </b>
    <pre><code>
  //an array of strings into a single
  string[] words = {"One", "Two", "Three", "Four"};
  string singleString = String.Join(",", words); // singleString = "One,Two,Three,Four"

//String Concatenation
string first = "Hello ";
string second = "World";
string concat = first + second; // concat = "Hello World"
concat = String.Concat(first, second); // concat = "Hello World"
In C# 6 this can be done as follows:
string concat = $"{first},{second}";
//Concat string array elements using String.Join
string[] value = {"apple", "orange", "grape", "pear"};
string separator = ", ";
string result = String.Join(separator, value, 1, 2);
Console.WriteLine(result);//Produces the following output: "orange, grape"
//=========================
//using $
var str1 = "text1";
var str2 = " ";
var str3 = "text3";
string result2 = $"{str1}{str2}{str3}"; //"text1 text3"
//=====================
StringBuilder sb = new StringBuilder();
for (int i = 1; i <= 5; i++)
{
sb.Append(i);
sb.Append(" ");
}
Console.WriteLine(sb.ToString()); // "1 2 3 4 5 "
Calls to Append() can be daisy chained, because it returns a reference to the StringBuilder:
StringBuilder sb = new StringBuilder();
sb.Append("some string ")
.Append("another string");

StringBuilder sb = new StringBuilder(10000); // initializes the capacity to 10000

//If we know in advance how long our StringBuilder needs to be, we can specify its size ahead of time, which will
//prevent it from needing to resize the character array it has internally.
sb.Append('k', 2000);
//Though using StringBuilder for appending is much faster than a string, it can run even faster if you only need to
//add a single character many times.

</code></pre>
    <b>Interpolated Verbatim Strings</b>
    Verbatim strings can be combined with the new String interpolation features found in C#6.
    <pre><code>
Console.WriteLine($@"Testing \n 1 2 {5 - 2}
New line");
//Output:
//Testing \n 1 2 3
//New line
</code></pre>
  As expected from a verbatim string, the backslashes are ignored as escape characters.
  And as expected from an interpolated string, any expression inside curly braces is evaluated
  before being inserted into the string at that position
  <b>Escaping </b>
  <pre><code>
//Double Quotes:
//Double Quotes inside verbatim strings can be escaped by using 2 sequential double quotes "" to represent one
//double quote " in the resulting string.  
var str = @"""I don't think so,"" he said.";
Console.WriteLine(str);
//Output:
//"I don't think so," he said. 

Backslash
// The filename will be c:\myfile.txt in both cases
string filename = "c:\\myfile.txt";
string filename = @"c:\myfile.txt";

Quotes
string text = "\"Hello World!\", said the quick brown fox.";         //"Hello World!", said the quick brown fox.
string verbatimText = @"""Hello World!"", said the quick brown fox.";//"Hello World!", said the quick brown fox.

Newlines
Verbatim string literals can contain newlines:
string text = "Hello\r\nWorld!";
string verbatimText = @"Hello
World!";

//Unicode character escape sequences
string sqrt = "\\u221A"; // √
string emoji = "\\U0001F601"; // ?
string text = "\\u0022Hello World\\u0022"; // "Hello World"
string variableWidth = "\\x22Hello World\\x22"; // "Hello World"

//Escaping special symbols in character literals
//Apostrophes
char apostrophe = '\'';

//Backslash
char oneBackslash = '\\';

</code></pre>
    <b>Padding a string to a fixed length</b>
    <pre><code>
 string s = "Foo";
string paddedLeft = s.PadLeft(5); // paddedLeft = " Foo" (pads with spaces by default)
string paddedRight = s.PadRight(6, '+'); // paddedRight = "Foo+++" 
string noPadded = s.PadLeft(2); // noPadded = "Foo" (original string is never shortened)
</code></pre>
    <b>Getting x characters from the right side of a string</b>
    <pre><code>
  public static class StringExtensions
  {
    public static string Left( this string stringparam, int numchars )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (numchars > stringparam.Length)
        numchars = stringparam.Length;
      return stringparam.Substring( 0, numchars );
    }
    public static string Right( this string stringparam, int numchars )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (numchars > stringparam.Length)
        numchars = stringparam.Length;
      return stringparam.Substring( stringparam.Length - numchars );
    }
  
    public static string Mid( this string stringparam, int startindex )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative startindex being passed
      startindex = Math.Abs( startindex );
      // Validate numchars parameter
      if (startindex > stringparam.Length)
        startindex = stringparam.Length;
      // C# strings are zero-based, convert passed startindex
      return stringparam.Substring( startindex - 1 );
    }
    
    public static string Mid( this string stringparam, int startindex, int numchars)
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative startindex being passed
      startindex = Math.Abs( startindex );
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (startindex > stringparam.Length)
        startindex = stringparam.Length;
      // C# strings are zero-based, convert passed startindex
      return stringparam.Substring( startindex - 1, numchars );
      }
  }
  //This extension method can be used as follows:
  //string myLongString = "Hello World!";
  //string myShortString = myLongString.Right(6); // "World!"
  //string myLeftString = myLongString.Left(5); // "Hello"
  //string myMidString1 = myLongString.Left(4); // "lo World"
  //string myMidString2 = myLongString.Left(2,3); // "ell"
</code></pre>
    <b>Checking for empty String using String.IsNullOrEmpty() and String.IsNullOrWhiteSpace()</b>
    <pre><code>
  string nullString = null;
  string emptyString = "";
  string whitespaceString = " ";
  string tabString = "\t";
  string newlineString = "\n";
  string nonEmptyString = "abc123";
  bool result;
result = String.IsNullOrEmpty(nullString); // true
result = String.IsNullOrEmpty(emptyString); // true
result = String.IsNullOrEmpty(whitespaceString); // false
result = String.IsNullOrEmpty(tabString); // false
result = String.IsNullOrEmpty(newlineString); // false
result = String.IsNullOrEmpty(nonEmptyString); // false
result = String.IsNullOrWhiteSpace(nullString); // true
result = String.IsNullOrWhiteSpace(emptyString); // true
result = String.IsNullOrWhiteSpace(tabString); // true
result = String.IsNullOrWhiteSpace(newlineString); // true
result = String.IsNullOrWhiteSpace(whitespaceString); // true
result = String.IsNullOrWhiteSpace(nonEmptyString); // false
</code></pre>
    <b>Trimming Unwanted Characters</b>
    <pre><code>
  String.Trim()
  string x = " Hello World! ";
  string y = x.Trim(); // "Hello World!"
  string q = "{(Hi!*";
  string r = q.Trim( '(', '*', '{' ); // "Hi!"
  String.TrimStart() and String.TrimEnd()
  string q = "{(Hi*";
  string r = q.TrimStart( '{' ); // "(Hi*"
  string s = q.TrimEnd( '*' ); // "{(Hi"
</code></pre>
    <b>Convert Decimal Number to Binary,Octal and Hexadecimal Format</b>
    <pre><code>
 // 1. To convert decimal number to binary format use base 2
  Int32 Number = 15;
  Console.WriteLine(Convert.ToString(Number, 2)); //OUTPUT : 1111
 // 2. To convert decimal number to octal format use base 8
  int Number = 15;
  Console.WriteLine(Convert.ToString(Number, 8)); //OUTPUT : 17
//  3. To convert decimal number to hexadecimal format use base 16
  var Number = 15;
  Console.WriteLine(Convert.ToString(Number, 16)); //OUTPUT : f 
</code></pre>
    <b>Construct a string from Array</b>
    <pre><code>
  string delimiter=",";
  char[] charArray = new[] { 'a', 'b', 'c' };
  string inputString = String.Join(delimiter, charArray);
 // Output : a,b,c if we change the delimiter as "" then the output will become abc.

String from List of char:
string delimiter = "|";
List<char> charList = new List<char>() { 'a', 'b', 'c' };
string inputString = String.Join(delimiter, charList);
//Output : a|b|c

String from List of Strings:
string delimiter = " ";
List<string> stringList = new List<string>() { "Ram", "is", "a","boy" };
string inputString = String.Join(delimiter, stringList);
//Output : Ram is a boy

String from array of strings:
string delimiter = "_";
string[] stringArray = new [] { "Ram", "is", "a","boy" };
string inputString = String.Join(delimiter, stringArray);
//Output : Ram_is_a_boy
</code></pre>
    <b>Finding a string within a string</b>
    <pre><code>
  string s = "Hello World";
  bool stringExists = s.Contains("ello"); //stringExists =true as the string contains the substring 
  int location = s.IndexOf("ello"); // location = 1
  int location = s.LastIndexOf("l"); // location = 9
</code></pre>
</div>

<h2>Operators</h2>
<div>

  <b>Implicit Cast and Explicit Cast Operators</b>
  C# allows user-defined types to control assignment and casting through the use of <strong>the explicit and
    implicit</strong> keywords.
  The signature of the method takes the form:
  <cl>public static < implicit/explicit> operator < ResultingType>(< SourceType> myType)</cl>
  The method cannot take any more arguments, nor can it be an instance method. It can, however, access any private
  members of type it is defined within.
  An example of both an implicit and explicit cast:
  <pre><code>
public class BinaryImage
{
private bool[] _pixels;
public static implicit operator ColorImage(BinaryImage im)
{
  return new ColorImage(im);
}
public static explicit operator bool[](BinaryImage im)
{
  return im._pixels;
}
}
</code></pre>
  Allowing the following cast syntax:
  <pre><code>
var binaryImage = new BinaryImage();
ColorImage colorImage = binaryImage; // implicit cast, note the lack of type
bool[] pixels = (bool[])binaryImage; // explicit cast, defining the type
</code></pre>
  The cast operators can work both ways, going from your type and going to your type:
  <pre><code>
public class BinaryImage
{
public static explicit operator ColorImage(BinaryImage im)
{
 return new ColorImage(im);
}
GoalKicker.com – C# Notes for Professionals 25
public static explicit operator BinaryImage(ColorImage cm)
{
  return new BinaryImage(cm);
}
}
</code></pre>
  Finally, the as keyword, which can be involved in casting within a type hierarchy, is not valid in this situation.
  Even
  after defining either an explicit or implicit cast, you cannot do:
  <cl>ColorImage cm = myBinaryImage as ColorImage;</cl>
  It will generate a compilation error.

  <b>Ternary Operator</b>
  Returns one of two values depending on the value of a Boolean expression.
  Syntax:
  <cl>condition ? expression_if_true : expression_if_false;</cl>
  Example:
  <pre><code>
string name = "Frank";
Console.WriteLine(name == "Frank" ? "The name is Frank" : "The name is not Frank");  
//=====================================
//Example 2:
light.intensity = Clamp(light.intensity, minLight, maxLight);
public static float Clamp(float val, float min, float max)
{
return (val < min) ? min : (val > max) ? max : val;
}
</code></pre>
  Ternary operators can also be nested, such as:
  <pre><code>a ? b ? "a is true, b is true" : "a is true, b is false" : "a is false"
// This is evaluated from left to right and can be more easily seen with parenthesis:
a ? (b ? x : y) : z
// Where the result is x if a && b, y if a && !b, and z if !a
</code></pre>

  <b>var vs dynamic</b>
  <pre><code>
// var says, “let the compiler figure out the type”.
// dynamic says, “let the runtime figure out the type”.

dynamic x = "hello";  // Static type is dynamic, runtime type is string
var y = "hello";      // Static type is string, runtime type is string
int i = x;            // Run-time error
int j = y;            // Compile-time error
</code></pre>

  <b>Overloadable Operators</b>
  <b>Operator Overloading </b>
  An operator is overloaded by declaring an operator function:
  <code><pre>
//Example1 :
Note B = new Note (2);
Note CSharp = B + 2;
CSharp.SemitonesFromA.Dump();

CSharp += 2;
CSharp.SemitonesFromA.Dump();

public struct Note
{
int value;
public int SemitonesFromA => value;

public Note (int semitonesFromA) { value = semitonesFromA; }

public static Note operator + (Note x, int semitones)
{
  return new Note (x.value + semitones);
}
}

//Example 2:
public struct Complex
{
  public double Real { get; set; }
  public double Imaginary { get; set; }
}
public static Complex operator +(Complex c1, Complex c2)
{
  return new Complex
  {
    Real = c1.Real + c2.Real,
    Imaginary = c1.Imaginary + c2.Imaginary
  };
}
///=============================
//Example 3:
public static class Polar
{
  public static bool operator is(Cartesian c, out double R, out double Theta)
  {
    R = Math.Sqrt(c.X*c.X + c.Y*c.Y);
    Theta = Math.Atan2(c.Y, c.X);
    return c.X != 0 || c.Y != 0;
  }
}
//================================
//Example 4:
class Student : IEquatable< Student>
{
  public string Name { get; set; } = "";
  public bool Equals(Student other)
  {
    if (ReferenceEquals(other, null)) return false;
    if (ReferenceEquals(other, this)) return true;
    return string.Equals(Name, other.Name);
  }
  public override bool Equals(object obj)
  {
    if (ReferenceEquals(null, obj)) return false;
    if (ReferenceEquals(this, obj)) return true;
    return Equals(obj as Student);
  }
  public override int GetHashCode()
  {
    return Name?.GetHashCode() ?? 0;
  }
  public static bool operator ==(Student left, Student right)
  {
    return Equals(left, right);
  }
  public static bool operator !=(Student left, Student right)
  {
    return !Equals(left, right);
  }
}
</code></pre>
  <b>explicit operator</b>
  <pre><code>
internal class Explicit
{
  public static explicit operator int (Explicit a)
  {
      return 5;
  }
}

internal class Implicit
{
  public static implicit operator int(Implicit a)
  {
      return 5;
  }
}
//and two objects:

var obj1 = new Explicit();
var obj2 = new Implicit();

//you can now write:

int integer = obj2; // implicit conversion - you don't have to use (int)
//or:
int integer = (int)obj1; // explicit conversion
//but:
int integer = obj1; // WON'T WORK - explicit cast required
</code></pre>
  <b>Short-circuiting Operators</b>
  The short-circuiting boolean operators will only evaluate the second operand if
  the first operand can not determine the overall result of the expression.

  It means that, if you are using && operator as firstCondition && secondCondition
  it will evaluate secondCondition only when firstCondition is true
  and ofcource the overall result will be true only if both of firstOperand
  and secondOperand are evaluated to true.
  This is useful in many scenarios, for example imagine that you want to check whereas your
  list has more than three elements but you also have to check if list has been initialized to not run into
  NullReferenceException. You can achieve this as below:
  <pre><code>
bool hasMoreThanThreeElements = myList != null && mList.Count > 3;
mList.Count > 3 will not be checked untill myList != null is met.
</code></pre>
  <strong>Logical AND</strong>
  && is the short-circuiting counterpart of the standard boolean AND (&) operator.
  <pre><code>
var x = true;
var y = false;
x && x // Returns true.
x && y // Returns false (y is evaluated).
y && x // Returns false (x is not evaluated).
y && y // Returns false (right y is not evaluated).
</code></pre>
  <strong>Logical OR</strong>
  || is the short-circuiting counterpart of the standard boolean OR (|) operator.
  <pre><code>
var x = true;
var y = false;
x || x // Returns true (right x is not evaluated).
x || y // Returns true (y is not evaluated).
y || x // Returns true (x and y are evaluated).
y || y // Returns false (y and y are evaluated).
</code></pre>
  Example usage
  <pre><code>
if(object != null && object.Property)
// object.Property is never accessed if object is null, because of the short circuit.
GoalKicker.com – C# Notes for Professionals 26
Action1();
else
Action2();
</code></pre>
  <b>Indexers</b>
  is a special type of property that to be accessed like an array for its internal collection
  Example:
  <pre><code>
class StringDataStore
{
  private string[] strArr = new string[10]; // internal data storage

  public string this[int index]
  {
      get
      {
          if (index < 0 || index >= strArr.Length)
              throw new IndexOutOfRangeException("Index out of range");

              return strArr[index];
      }

      set
      {
          if (index < 0 ||  index >= strArr.Length)
              throw new IndexOutOfRangeException("Index out of range");

          strArr[index] = value;
      }
  }
}
</code></pre>
  <b>default Operator</b>
  <cl>Value Type (where T : struct)</cl>
  The built-in primitive data types, such as char, int, and float, as well as user-defined types declared with struct,
  or enum. Their default value is new T() :
  <pre><code>
default(int) // 0
default(DateTime) // 0001-01-01 12:00:00 AM
default(char) // '\0' This is the "null character", not a zero or a line break.
default(Guid) // 00000000-0000-0000-0000-000000000000
default(MyStruct) // new MyStruct()
// Note: default of an enum is 0, and not the first *key* in that enum
// so it could potentially fail the Enum.IsDefined test
default(MyEnum) // (MyEnum)0
Reference Type (where T : class)
Any class, interface, array or delegate type. Their default value is null :
default(object) // null
default(string) // null
default(MyClass) // null
default(IDisposable) // null
default(dynamic) // null 
</code></pre>
  <b>sizeof</b>
  Returns an int holding the size of a type* in bytes.
  <pre><code>
sizeof(bool) // Returns 1.
sizeof(byte) // Returns 1.
sizeof(sbyte) // Returns 1.
sizeof(char) // Returns 2.
sizeof(short) // Returns 2.
sizeof(ushort) // Returns 2.
sizeof(int) // Returns 4.
sizeof(uint) // Returns 4.
sizeof(float) // Returns 4.
sizeof(long) // Returns 8.
sizeof(ulong) // Returns 8.
sizeof(double) // Returns 8.
sizeof(decimal) // Returns 16.  
</code></pre>
  <b>Null-Conditional Operator</b>
  Introduced in C# 6.0, the Null Conditional Operator <b>?.</b> will immediately return null
  if the expression on its lefthand side evaluates to null, instead of throwing a NullReferenceException.
  If its left-hand side evaluates to a nonnull value, it is treated just like a normal . operator.
  Note that because it might return null, its return type is always a nullable type.
  That means that for a struct or primitive type, it is wrapped into a <b>Nullable<T>.</b>
  <pre><code>
var bar = Foo.GetBar()?.Value; // will return null if GetBar() returns null
var baz = Foo.GetBar()?.IntegerValue; // baz will be of type Nullable<int>, i.e. int?  
</code></pre>
  This comes handy when firing events.
  Normally you would have to wrap the event call in an if statement checking for null and raise the event afterwards,
  which introduces the possibility of a race condition.
  Using the Null conditional operator this can be fixed in the following way:
  <pre><code> 
event EventHandler<string> RaiseMe;
RaiseMe?.Invoke("Event raised"); 
</code></pre>

  Nullable types also work well with the null-conditional operator
  <pre><code>    
System.Text.StringBuilder sb = null;
int? length = sb?.ToString().Length;
length.Dump();

// We can combine this with the null coalescing operator to evaluate to zero instead of null:

int length2 = sb?.ToString().Length ?? 0;  // Evaluates to 0 if sb is null
length2.Dump();
</code></pre>
  <b>Null-Coalescing Operator</b>
  The Null-Coalescing operator ?? will return the left-hand side when not null.
  If it is null, it will return the right-hand side.

  Parameter Details
  possibleNullObject The value to test for null value. If non null, this value is returned. Must be a nullable type.
  defaultValue The value returned if possibleNullObject is null. Must be the same type as possibleNullObject.
  <pre><code>
object foo = null;
object bar = new object();
var c = foo ?? bar;
//c will be bar since foo was null
The ?? operator can be chained which allows the removal of if checks.
//config will be the first non-null returned.
var config = RetrieveConfigOnMachine() ??
RetrieveConfigFromService() ??
new DefaultConfiguration();
</code></pre>
  <b>Basic usage</b>
  Using the null-coalescing operator (??) allows you to specify a default value for a nullable type if the left-hand
  operand is null.
  <pre><code>
string testString = null;
Console.WriteLine("The specified string is - " + (testString ?? "not provided"));  
</code></pre>
  This is logically equivalent to:
  <pre><code>
string testString = null;
if (testString == null)
{
Console.WriteLine("The specified string is - not provided");
}
else
{
Console.WriteLine("The specified string is - " + testString);
} 
</code></pre>
  or using the ternary operator (?:) operator:
  <pre><code>
string testString = null;
Console.WriteLine("The specified string is - " + (testString == null ? "not provided" :testString));  
</code></pre>
  <b>Null fall-through and chaining</b>
  left-hand operand must be nullable, while the right-hand operand may or may not be.
  The result will be typed accordingly.
  Non-nullable:
  <pre><code>
int? a = null;
int b = 3;
var output = a ?? b;
var type = output.GetType();
Console.WriteLine($"Output Type :{type}");
Console.WriteLine($"Output value :{output}");
//Output:
//Type :System.Int32
//value :3
</code></pre>
  Nullable:
  <pre><code>
int? a = null;
int? b = null;
var output = a ?? b;
//output will be of type int? and equal to b, or null.
</code></pre>
  Multiple Coalescing:
  Coalescing can also be done in chains:
  <pre><code>
int? a = null;
int? b = null;
int c = 3;
var output = a ?? b ?? c;
var type = output.GetType();
Console.WriteLine($"Type :{type}");
Console.WriteLine($"value :{output}");
//Output:
//Type :System.Int32
//value :3
</code></pre>
  <b>Lambda operator</b>
  The => operator has the same precedence as the assignment operator = and is right-associative.
  It is used to declare lambda expressions and also it is widely used with LINQ Queries:
  <pre><code>
string[] words = { "cherry", "apple", "blueberry" };
int shortestWordLength = words.Min((string w) => w.Length); //5
</code></pre>

  When used in LINQ extensions or queries the type of the objects can usually be skipped as it is inferred by the
  compiler:
  <pre><code>
int shortestWordLength = words.Min(w => w.Length); //also compiles with the same result  
</code></pre>
  The general form of lambda operator is the following:
  <cl>(input parameters) => expression</cl>
  The parameters of the lambda expression are specified before => operator,
  and the actual expression/statement/block to be executed is to the right of the operator:
  <pre><code>
// expression
(int x, string s) => s.Length > x
// expression
(int x, int y) => x + y
// statement
(string x) => Console.WriteLine(x)
// block
(string x) => {
x += " says Hello!";
Console.WriteLine(x);
}</code></pre>
  This operator can be used to easily define delegates, without writing an explicit method:
  <pre><code>
delegate void TestDelegate(string s);
TestDelegate myDelegate = s => Console.WriteLine(s + " World");
myDelegate("Hello");
instead of
void MyMethod(string s)
{
Console.WriteLine(s + " World");
}
delegate void TestDelegate(string s);
TestDelegate myDelegate = MyMethod;
myDelegate("Hello");
</code></pre>
  <b>Null coalescing operator with method calls</b>
  The null coalescing operator makes it easy to ensure that a method that may return null will fall back to a default
  value.
  Without the null coalescing operator:
  <pre><code>
string name = GetName();
if (name == null)
name = "Unknown!";
</code></pre>
  With the null coalescing operator:
  <cl>string name = GetName() ?? "Unknown!";</cl>

  <b>Class Member Operators: Null Conditional Member Access</b>
  <pre><code>
var zipcode = myEmployee?.Address?.ZipCode;
//returns null if the left operand is null.
//the above is the equivalent of:
var zipcode = (string)null;
if (myEmployee != null && myEmployee.Address != null)
zipcode = myEmployee.Address.ZipCode;
</code></pre>
  <b> Use existing or create new</b>
  A common usage scenario that this feature really helps with is when you are looking for an object in a collection
  and need to create a new one if it does not already exist.
  <pre><code>
IEnumerable<MyClass> myList = GetMyList();
var item = myList.SingleOrDefault(x => x.Id == 2) ?? new MyClass { Id = 2 }; 
</code></pre>
  <b>Lazy properties initialization with null coalescing operator</b>
  <pre><code>
private List<FooBar> _fooBars;
  public List<FooBar> FooBars
  {
  get { return _fooBars ?? (_fooBars = new List<FooBar>()); }
  }
</code></pre>
  The first time the property .FooBars is accessed the _fooBars variable will evaluate as null,
  thus falling through to the assignment statement assigns and evaluates to the resulting value.
  <strong>Thread safety</strong>
  This is not thread-safe way of implementing lazy properties.
  For thread-safe laziness, use the Lazy<T> class built into the .NET Framework.
    <strong>C# 6 Syntactic Sugar using expression bodies</strong>
    Note that since C# 6, this syntax can be simplified using expression body for the property:
    <pre><code>
private List<FooBar> _fooBars;
public List<FooBar> FooBars => _fooBars ?? ( _fooBars = new List<FooBar>() );
// Subsequent accesses to the property will yield the value stored in the _fooBars variable.
</code></pre>
    <b>Example in the MVVM pattern</b>
    This is often used when implementing commands in the MVVM pattern. Instead of initializing the commands
    eagerly with the construction of a viewmodel, commands are lazily initialized using this pattern as follows:
    <pre><code>
private ICommand _actionCommand = null;
public ICommand ActionCommand =>
_actionCommand ?? ( _actionCommand = new DelegateCommand( DoAction ) ); 
</code></pre>

    <b>Class Member Operators: Null Conditional Indexing</b>
    The ?. operator is syntactic sugar to avoid verbose null checks. It's also known as the Safe navigation operator.
    <pre><code>
//Example 1:
public class Person
{
public int Age { get; set; }
public string Name { get; set; }
public Person Spouse { get; set; }
}
//If an object is potentially null (such as a function that returns a reference type) 
//the object must first be checked for null to prevent a possible NullReferenceException. 
//Without the null-conditional operator, this would look like:
Person person = GetPerson();
int? age = null;
if (person != null)
age = person.Age;

//The same example using the null-conditional operator:
Person person = GetPerson();
var age = person?.Age; // 'age' will be of type 'int?', even if 'person' is not null

//Example 2:

var letters = null;
char? letter = letters?[1];
Console.WriteLine("Second Letter is {0}",letter);
//in the above example rather than throwing an error because letters is null
//letter is assigned the value null  

//Chaining the Operator:
//The null-conditional operator can be combined on the members and sub-members of an object.
// Will be null if either `person` or `person.Spouse` are null
int? spouseAge = person?.Spouse?.Age;

// Combining with the Null-Coalescing Operator
// The null-conditional operator can be combined with the null-coalescing operator to provide a default value:
// spouseDisplayName will be "N/A" if person, Spouse, or Name is null
var spouseDisplayName = person?.Spouse?.Name ?? "N/A";
</code></pre>
    <b>The Null-Conditional Index</b>
    <pre><code>
// Similarly to the ?. operator, the null-conditional index operator checks for null values
// when indexing into a collection that may be null.
string item = collection?[index];
is syntactic sugar for
string item = null;
if(collection != null)
{
item = collection[index];
}
</code></pre>
    <b>Avoiding NullReferenceExceptions</b>
    <pre><code>
var person = new Person
{
Address = null;
};
var city = person.Address.City; //throws a NullReferenceException
var nullableCity = person.Address?.City; //returns the value of null
This effect can be chained together:
var person = new Person
{
  Address = new Address
  {
    State = new State
      {
        Country = null
    }
  }
};
// this will always return a value of at least "null" to be stored instead
// of throwing a NullReferenceException
var countryName = person?.Address?.State?.Country?.Name;
</code></pre>
    <b>Null-conditional Operator can be used with Extension Method</b>
    Extension Method can work on null references, but you can use ?. to null-check anyway.
    <pre><code>
public class Person
{
  public string Name {get; set;}
}
public static class PersonExtensions
{
  public static int GetNameLength(this Person person)
  {
    return person == null ? -1 : person.Name.Length;
  }
}
//Normally, the method will be triggered for null references, and return -1:
Person person = null;
int nameLength = person.GetNameLength(); // returns -1
</code></pre>
    Using ?. the method will not be triggered for null references, and the type is int?:


    <b>typeof</b>
    Gets System.Type object for a type.
    <pre><code class="csharp">
System.Type type = typeof(Point); //System.Drawing.Point
System.Type type = typeof(IDisposable); //System.IDisposable
System.Type type = typeof(Colors); //System.Drawing.Color
System.Type type = typeof(List<>); //System.Collections.Generic.List`1[T]
</code></pre>
    To get the run-time type, use GetType method to obtain the System.Type of the current instance.
    Operator typeof takes a type name as parameter, which is specified at compile time.
    <pre><code>
public class Animal {}
public class Dog : Animal {}
var animal = new Dog();
Assert.IsTrue(animal.GetType() == typeof(Animal)); // fail, animal is typeof(Dog)
Assert.IsTrue(animal.GetType() == typeof(Dog)); // pass, animal is typeof(Dog)
Assert.IsTrue(animal is Animal); // pass, animal implements Animal
</code></pre>
    <b>nameof Operator</b>
    Returns a string that represents the unqualified name of a variable, type, or member.
    <pre><code>
int counter = 10;
nameof(counter); // Returns "counter"
Client client = new Client();  
nameof(client.Address.PostalCode)); // Returns "PostalCode"
The nameof operator was introduced in C# 6.0. 
It is evaluated at compile-time and the returned string value is inserted inline by the compiler,
so it can be used in most cases where the constant string can be used 
(e.g., the case labels in a switch statement, attributes, etc...). 
It can be useful in cases like raising & logging exceptions, attributes, MVC Action links, etc...
//=================================
// Raising PropertyChanged event

<pre><code>
public class Person : INotifyPropertyChanged
{
  private string _address;
  public event PropertyChangedEventHandler PropertyChanged;
  private void OnPropertyChanged(string propertyName)
  {
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
  }
  public string Address
  {
    get { return _address; }
    set
    {
      if (_address == value)
      {
        return;
      }
      _address = value;
      OnPropertyChanged(nameof(Address));
    }
  }
}
...
var person = new Person();
person.PropertyChanged += (s,e) => Console.WriteLine(e.PropertyName);
person.Address = "123 Fake Street";
//Console Output
//Address

//===============================================
//Argument Checking and Guard Clauses

//Prefer
if (orderLine == null) throw new ArgumentNullException(nameof(orderLine));

//Over
if (orderLine == null) throw new ArgumentNullException("orderLine");
//================================================
//Applied to a generic type parameter

public class SomeClass<TItem>
{
  public void PrintTypeName()
  {
    Console.WriteLine(nameof(TItem));
  }
}
</code></pre>

    </code></pre>
    <b>Class Member Operators: Aggregate Object Indexing</b>
    <pre><code>
var letters = "letters".ToCharArray();
char letter = letters[1];
Console.WriteLine("Second Letter is {0}",letter);
//in the above example we take the second character from the array
//by calling letters[1]
//NB: Array Indexing starts at 0; i.e. the first letter would be given by letters[0].
</code></pre>
</div>
<h2>GetHashCode</h2>
<div>
  <b>Writing a good GetHashCode override</b>
  GetHashCode has major performance effects on Dictionary<> and HashTable.
    Good GetHashCode Methods
    should have an even distribution
    every integer should have a roughly equal chance of returning for a random instance
    if your method returns the same integer (e.g. the constant '999') for each instance, you'll have bad
    performance
    should be quick
    These are NOT cryptographic hashes, where slowness is a feature
    the slower your hash function, the slower your dictionary
    must return the same HashCode on two instances that Equals evaluates to true
    if they do not (e.g. because GetHashCode returns a random number),
    items may not be found in a List,Dictionary, or similar.
    A good method to implement GetHashCode is to use one prime number as a starting value, and add the hashcodes
    of the fields of the type multiplied by other prime numbers to that:
    <pre><code>
public override int GetHashCode()
{
unchecked // Overflow is fine, just wrap
{
int hash = 3049; // Start value (prime number).
// Suitable nullity checks etc, of course :)
hash = hash * 5039 + field1.GetHashCode();
hash = hash * 883 + field2.GetHashCode();
hash = hash * 9719 + field3.GetHashCode();
return hash;
}
}</code></pre>
Only the fields which are used in the Equals-method should be used for the hash function.
If you have a need to treat the same type in different ways for Dictionary/HashTables, you can use
IEqualityComparer.

<b>Override Equals and GetHashCode on custom types</b>
For a class Person like:
<pre><code>
public class Person
{
public string Name { get; set; }
public int Age { get; set; }
public string Clothes { get; set; }
}
var person1 = new Person { Name = "Jon", Age = 20, Clothes = "some clothes" };
var person2 = new Person { Name = "Jon", Age = 20, Clothes = "some other clothes" };
bool result = person1.Equals(person2); //false because it's reference Equals
But defining Equals and GetHashCode as follows:
public class Person
{
public string Name { get; set; }
GoalKicker.com – C# Notes for Professionals 39
public int Age { get; set; }
public string Clothes { get; set; }
public override bool Equals(object obj)
{
  var person = obj as Person;
  if(person == null) return false;
  return Name == person.Name && Age == person.Age; //the clothes are not important when comparing two persons
  }
  public override int GetHashCode()
  {
    return Name.GetHashCode()*Age;
  }
}
var person1 = new Person { Name = "Jon", Age = 20, Clothes = "some clothes" };
var person2 = new Person { Name = "Jon", Age = 20, Clothes = "some other clothes" };
bool result = person1.Equals(person2); // result is true
Also using LINQ to make different queries on persons will check both Equals and GetHashCode:
var persons = new List<Person>
{
  new Person{ Name = "Jon", Age = 20, Clothes = "some clothes"},
  new Person{ Name = "Dave", Age = 20, Clothes = "some other clothes"},
  new Person{ Name = "Jon", Age = 20, Clothes = ""}
};
var distinctPersons = persons.Distinct().ToList();//distinctPersons has Count = 2

</code></pre>

    <b>Equals and GetHashCode in IEqualityComparator</b>
    For given type Person:
    <pre><code>
public class Person
{
  public string Name { get; set; }
  public int Age { get; set; }
  public string Clothes { get; set; }
}
List<Person> persons = new List<Person>
{
  new Person{ Name = "Jon", Age = 20, Clothes = "some clothes"},
  new Person{ Name = "Dave", Age = 20, Clothes = "some other clothes"},
  new Person{ Name = "Jon", Age = 20, Clothes = ""}
};
var distinctPersons = persons.Distinct().ToList();// distinctPersons has Count = 3
But defining Equals and GetHashCode into an IEqualityComparator :
public class PersonComparator : IEqualityComparer<Person>
{
public bool Equals(Person x, Person y)
{
  return x.Name == y.Name && x.Age == y.Age; //the clothes are not important when comparing
  two persons;
}
public int GetHashCode(Person obj) { return obj.Name.GetHashCode() * obj.Age; }
}
var distinctPersons = persons.Distinct(new PersonComparator()).ToList();// distinctPersons has Count = 2
</code></pre>
    Note that for this query, two objects have been considered equal if both the Equals returned true and the
    GetHashCode have returned the same hash code for the two persons.


</div>
<h2>Generics</h2>
<div>
  means not specific to a particular data type.
  Example :
  The DataStore is a generic class:
  <pre><code>
  class DataStore< T>
  {
    public T Data { get; set; } //generic field of the generic class
    public T GetData(int index) { ...} //generic method (which returns generic class).
                       //(generic methods can also be defined in a none-generic class)
  }
  </code></pre>
  T is called type parameter, which can be used as
  a type of fields, properties, method parameters, return types,and delegates in <strong> the DataStore class</strong>.
  <b> Instanciation:</b>
     You can create an instance of generic classes by specifying an actual type in angle brackets:
  <cl> DataStore<string> store = new DataStore<string>();</cl>
<b> C# Generic Constraints</b>
  You can use constraints to restrict the type to certain types while instantiating generic types.
  It will give a compile - time error if you try to instantiate a generic type using a type that is not allowed by
    the specified constraints.
  
  There are six types of constraints:

  where T: struct -Type argument must be a value type
  where T: class -Type argument must be a reference type
  where T: new() - Type argument must have a public parameterless constructor.
  where T :
  < base class> -Type argument must inherit from
  < base class> class.
  where T: < interface> -Type argument must implement from< interface> interface.
  where T: U - There are two type arguments T and U.T must be inherit from U.


  <a href='https://www.tutorialsteacher.com/csharp/constraints-in-generic-csharp'>more..</a>
  <b>multicast delegates</b>
  multicasting is the ability to create an invocation list, or chain, of methods that
  will be automatically called when a delegate is invoked.
  A delegate instance can reference not just a single target method, but also a list of target methods.
  As a result, one delegate instance can call many methods.It is called multicast.
  All delegate instances have multicast capability.

  Example:
  <pre><code>
  // All delegate instances have multicast capability:

  SomeDelegate d = SomeMethod1;
  d += SomeMethod2;

  d();
  " -- SomeMethod1 and SomeMethod2 both fired\r\n".Dump();

  d -= SomeMethod1;
  d();
  " -- Only SomeMethod2 fired".Dump();

  void SomeMethod1() => "SomeMethod1".Dump();
  void SomeMethod2() => "SomeMethod2".Dump();

  delegate void SomeDelegate();
  </code></pre>
</div>
<h2>Access modifiers</h2>
<div>
 <pre><code>
class Class1 {}         // Class1 is <b>internal</b> (default) - visible to other types in same assembly
public class Class2 {}  // Class2 is visible to everything, including types in other assemblies

class ClassA
{
  int x;               // x is private <b>(default)</b> - cannot be accessed from other types
}

class ClassB
{
  internal int x;    // x can be accessed from other types in same assembly
}

class BaseClass
{
  void Foo()           {}    // Foo is private (default)
  protected void Bar() {}    // <b>protected</b> is accessible to subclasses
}

class Subclass : BaseClass
{
   void Test1() { Foo(); }     // Error - cannot access Foo
   void Test2() { Bar(); }     // OK
}
Friend Assemblies

// Unsigned friend:
//    [assembly: InternalsVisibleTo ("Friend")]

// Signed friend:
//    [assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]

// To obtain an assembly's public key, hit F5 to run the following code:

using (var dialog = new OpenFileDialog())
{
  dialog.Title = "Locate assembly";
  dialog.Filter = "Assembly files|*.dll;*.exe";
  dialog.DefaultExt = ".dll";
  
  if (dialog.ShowDialog() != DialogResult.OK) return;
  if (!File.Exists (dialog.FileName)) return;
  
  var aName = Assembly.LoadFile (dialog.FileName).GetName();

  string key = string.Join ("", 
    aName.GetPublicKey().Select (b => b.ToString ("x2")).ToArray());
    
  string assemAttrib = "[assembly: InternalsVisibleTo (\"" 
    + aName.Name
    + ", PublicKey=" + key.Dump ("Full Key")
    + "\")]";
    
  assemAttrib.Dump ("Assembly Attribute");
  
  Clipboard.SetText (assemAttrib);
}
</code></pre> 
</div>
<h2>yield return</h2>
<div>
  if you want a collection that you can use "foreach" on, but gathering the items into the collection is
    expensive for some reason
    (like querying them out of a database), AND you will often not need the entire collection,
    then you create a function that builds the collection one item at a time and yields it back to the consumer
    (who can then terminate the collection effort early).

    t first sight, yield return is a .NET sugar to return an IEnumerable.

    Without yield, all the items of the collection are created at once:
    <pre><code>
  class SomeData
  {
      public SomeData() { }

      static public IEnumerable<SomeData> CreateSomeDatas()
      {
          return new List<SomeData> {
              new SomeData(), 
              new SomeData(), 
              new SomeData()
          };
      }
  }
  </code></pre>
 Same code using yield, it returns item by item:
  <pre><code>
    class SomeData
    {
        public SomeData() { }

        static public IEnumerable<SomeData> CreateSomeDatas()
        {
            yield return new SomeData();
            yield return new SomeData();
            yield return new SomeData();
        }
    }
  </code></pre>
  The advantage of using yield is that if the function consuming your data simply needs the first item of the
  collection,
  the rest of the items won't be created.
  The yield operator allows the creation of items as it is demanded. That's a good reason to use it.
  <b>yield break</b>
  <pre><code>
    // The yield break statement indicates that the iterator block should exit early,
    // without returning more elements:

    foreach (string s in Foo (true))
    Console.WriteLine (s);

    static IEnumerable<string> Foo (bool breakEarly)
    {
        yield return "One";
        yield return "Two";

        if (breakEarly)
            yield break;

        yield return "Three";
    }
  </code></pre>
</div>
<h2>yield break</h2>
<div>
  The yield break statement indicates that the iterator block should exit early,
                without returning more elements:
                <pre><code>
  foreach (string s in Foo (true))
    Console.WriteLine (s);

  static IEnumerable<string> Foo (bool breakEarly)
  {
    yield return "One";
    yield return "Two";

    if (breakEarly)
      yield break;

    yield return "Three";
  }
  </code></pre>
<b>Multiple yield Statements</b>
Multiple yield statements are permitted:
<pre><code>
   foreach (string s in Foo())
    Console.WriteLine (s);         // Prints "One","Two","Three"

  IEnumerable<string> Foo()
  {
    yield return "One";
    yield return "Two";
    yield return "Three";
  }
  </code></pre>
Example 2
<pre><code>
      IEnumerable<string> Foo()
      {
          try
          {
          yield return "One";
          yield return "Two";
          yield return "Three";
          }
  </code></pre>
<b>Null</b>
<pre><code>
      int? x = null;
      int y = x ?? 5;
      Console.WriteLine (y);  // 5    
  </code></pre>
<b>Extension Methods</b>
Extension methods allow an existing type to be extended with new methods without altering
the definition of the original type:
<pre><code>
  Console.WriteLine ("Perth".IsCapitalized());
  // Equivalent to:
  Console.WriteLine (StringHelper.IsCapitalized ("Perth"));

  // Interfaces can be extended, too:
  Console.WriteLine ("Seattle".First());   // S

  public static class StringHelper
  {
    public static bool IsCapitalized (this string s)
    {
      if (string.IsNullOrEmpty (s)) return false;
      return char.IsUpper (s [0]);
    }

    public static T First<T> (this IEnumerable<T> sequence)
    {
      foreach (T element in sequence)
        return element;

      throw new InvalidOperationException ("No elements!");
    }
  }
  </code></pre>
</div>
<h2>object oriented </h2>
<div>
  <h3>Inheritence</h3>
  <strong>What is difference between virtual and override in C#?</stong>

    The virtual keyword is used to modify a method, property, indexer, or event declared in the base class
    and allow it to be overridden in the derived class.
    The override keyword is used to extend or modify a virtual/abstract method, property, indexer, or event of
    base class into a derived class.
  
    <b>Polymorphism</b>:
    <pre><code>
    // A variable of type x can refer to an object that subclasses x.
  
      // The Display method below accepts an Asset. This means means we can pass it any subtype:
      Display (new Stock { Name="MSFT", SharesOwned=1000 });
      Display (new House { Name="Mansion", Mortgage=100000 });
  
      void Display (Asset asset)
      {
        Console.WriteLine (asset.Name);
      }
  
      public class Asset
      {
        public string Name;
      }
  
      public class Stock : Asset   // inherits from Asset
      {
       public long SharesOwned;
      }
  
      public class House : Asset   // inherits from Asset
      {
        public decimal Mortgage;
      }
    </code></pre>
                  <b>Reference Conversions - Upcasting</b>
                  <pre><code>
    // An upcast creates a base class reference from a subclass reference:
  
    Stock msft = new Stock();
    Asset a = msft;               // Upcast
  
    // After the upcast, the two variables still references the same Stock object:
  
    Console.WriteLine (a == msft);  // True
  
    public class Asset
    {
      public string Name;
    }
  
    public class Stock : Asset   // inherits from Asset
    {
      public long SharesOwned;
    }
  
    public class House : Asset   // inherits from Asset
    {
      public decimal Mortgage;
    }
    </code></pre>
                  <b>Virtual Function Members</b>
                  <pre><code>
    // A function marked as virtual can be overridden by subclasses wanting to provide a
    // specialized implementation:
  
    House mansion = new House { Name="McMansion", Mortgage=250000 };
    Console.WriteLine (mansion.Liability);      // 250000
  
    public class Asset
    {
      public string Name;
      public virtual decimal Liability => 0;    // Virtual
    }
  
    public class House : Asset
    {
      public decimal Mortgage;
      public override decimal Liability => Mortgage;   // Overridden
    }
  
    public class Stock : Asset
    {
      public long SharesOwned;
      // We won't override Liability here, because the default implementation will do.
    }
    </code></pre>
    <b>Covariant returns</b>

    From C# 9, we can override a method such that it returns a more derived (subclased) type:
    <pre><code>
    House mansion1 = new House { Name = "McMansion", Mortgage = 250000 };
    House mansion2 = mansion1.Clone();

    public class Asset
    {
      public string Name;
      public virtual Asset Clone() => new Asset { Name = Name };
    }

    public class House : Asset
    {
      public decimal Mortgage;
  
      // We can return House when overriding:
      public override House Clone() => new House { Name = Name, Mortgage = Mortgage };
    }
    </code></pre>
    <b>Abstract Classes & Members</b>

    A class declared as abstract can never be instantiated. Instead, only its concrete subclasses
    can be instantiated. Abstract classes are able to define abstract members.
    <pre><code>
    new Stock { SharesOwned = 200, CurrentPrice = 123.45M }.NetValue.Dump();

    public abstract class Asset    // Note abstract keyword
    {
      public abstract decimal NetValue { get; }  // Note empty implementation
    }

    public class Stock : Asset
    {
      public long SharesOwned;
      public decimal CurrentPrice;

      // Override like a virtual method.
      public override decimal NetValue => CurrentPrice * SharesOwned; 
    }
    </pre></code>
    <b>Sealing Functions & Classes</b>
    An overridden function member may seal its implementation with the sealed keyword to prevent it
    from being overridden by further subclasses:
    <pre><code>
    House mansion = new House { Name="McMansion", Mortgage=250000 };
    Console.WriteLine (mansion.Liability);      // 250000

    public class Asset
    {
      public string Name;
      public virtual decimal Liability => 0;    // Virtual
    }

    public class House : Asset
    {
      public decimal Mortgage;
      public sealed override decimal Liability => Mortgage;   // Overridden + sealed
    }

    // You can also seal the class itself, implicitly sealing all the virtual functions:

    public sealed class Stock : Asset { /* ... */ }
    </code></pre>

    <b>Overloading and Resolution</b>
    When calling an overload method, the method with the most specific
    parameter type match has precedence, based on the *compile-time* variable type:
    <pre><code>
    void Main()
    {
      Foo (new House());      // Calls Foo (House)
  
      Asset a = new House();
      Foo (a);                // Calls Foo (Asset)
    }

    static void Foo (Asset a) { "Foo Asset".Dump(); }
    static void Foo (House h) { "Foo House".Dump(); }

    public class Asset
    {
      public string Name;
    }

    public class Stock : Asset   // inherits from Asset
    {
      public long SharesOwned;
    }

    public class House : Asset   // inherits from Asset
    {
      public decimal Mortgage;
    }
    </code></pre>  
  </div>
<h2>Boxing & Unboxing</h2>
  <div>
   Boxing is the act of casting a value-type instance to a reference-type instance; unboxing is the reverse.
  <pre><code>
    int x = 9;
    object obj = x;           // Box the int
    int y = (int)obj;         // Unbox the int    
 </code></pre>  
  </div>
<h2>DateTime</h2>
  <div>
    <h3>Format DateTime</h3>
    <pre><code>
      //Create datetime
      DateTime dt = new DateTime(2016,08,01,18,50,23,230);
      var t = String.Format("{0:t}", dt); // "6:50 PM"                ShortTime
      var d = String.Format("{0:d}", dt); // "8/1/2016"               ShortDate
      var T = String.Format("{0:T}", dt); // "6:50:23 PM"             LongTime
      var D = String.Format("{0:D}", dt); // "Monday, August 1, 2016" LongDate
      var f = String.Format("{0:f}", dt); // "Monday, August 1, 2016 6:50 PM" LongDate+ShortTime
      var F = String.Format("{0:F}", dt); // "Monday, August 1, 2016 6:50:23 PM" FullDateTime
      var g = String.Format("{0:g}", dt); // "8/1/2016 6:50 PM"       ShortDate+ShortTime
      var G = String.Format("{0:G}", dt); // "8/1/2016 6:50:23 PM"    ShortDate+LongTime
      var m = String.Format("{0:m}", dt); // "August 1"               MonthDay
      var y = String.Format("{0:y}", dt); // "August 2016"            YearMonth
      var r = String.Format("{0:r}", dt); // "SMon, 01 Aug 2016 18:50:23 GMT" RFC1123
      var s = String.Format("{0:s}", dt); // "2016-08-01T18:50:23"    SortableDateTime
      var u = String.Format("{0:u}", dt); // "2016-08-01 18:50:23Z"   UniversalSortableDateTime
    </code></pre>
    <h3>Custom DateTime Formatting </h3>
    There are following custom format specifiers:
    y (year)
    M (month)
    d (day)
    h (hour 12)
    H (hour 24)
    m (minute)
    s (second)
    f (second fraction)
    F (second fraction, trailing zeroes are trimmed)
    t (P.M or A.M)
    z (time zone).
    <pre><code>
  var year = String.Format("{0:y yy yyy yyyy}", dt); // "16 16 2016 2016" year
  var month = String.Format("{0:M MM MMM MMMM}", dt); // "8 08 Aug August" month
  var day = String.Format("{0:d dd ddd dddd}", dt); // "1 01 Mon Monday" day
  var hour = String.Format("{0:h hh H HH}", dt); // "6 06 18 18" hour 12/24
  var minute = String.Format("{0:m mm}", dt); // "50 50" minute
  var secound = String.Format("{0:s ss}", dt); // "23 23" second
  var fraction = String.Format("{0:f ff fff ffff}", dt); // "2 23 230 2300" sec.fraction
  var fraction2 = String.Format("{0:F FF FFF FFFF}", dt); // "2 23 23 23" without zeroes
  var period = String.Format("{0:t tt}", dt); // "P PM" A.M. or P.M.
  var zone = String.Format("{0:z zz zzz}", dt); // "+0 +00 +00:00" time zone
 // You can use also date separator / (slash) and time sepatator : (colon)
</code></pre>
    <h3>AddDays(Double)</h3>
    <pre><code>
DateTime.AddDays(Double)
Add days into a dateTime object.
DateTime today = DateTime.Now;
DateTime answer = today.AddDays(36);
Console.WriteLine("Today: {0:dddd}", today);
Console.WriteLine("36 days from today: {0:dddd}", answer);

//You also can subtract days passing a negative value:
DateTime today = DateTime.Now;
DateTime answer = today.AddDays(-3);
Console.WriteLine("Today: {0:dddd}", today);
Console.WriteLine("-3 days from today: {0:dddd}", answer);
</code></pre>
    <h3>AddHours(Double)</h3>
    <pre><code>
// DateTime.AddHours(Double)
double[] hours = {.08333, .16667, .25, .33333, .5, .66667, 1, 2,
29, 30, 31, 90, 365};
DateTime dateValue = new DateTime(2009, 3, 1, 12, 0, 0);
foreach (double hour in hours)
  Console.WriteLine("{0} + {1} hour(s) = {2}", dateValue, hour,dateValue.AddHours(hour));
</code></pre>
    <h3>Parse(String)</h3>
    <pre><code>
// Converts the string representation of a date and time to its DateTime equivalent
var dateTime = DateTime.Parse("14:23 22 Jul 2016");
Console.WriteLine(dateTime.ToString());
</code>
</pre>
    <h3>TryParse(String, DateTime)</h3>
    <pre><code>
  // Converts the specified string representation of a date and time to its DateTime equivalent and
  returns a value that indicates whether the conversion succeeded
  string[] dateTimeStrings = new []{
    "14:23 22 Jul 2016",
    "99:23 2x Jul 2016",
    "22/7/2016 14:23:00"
  };
  foreach(var dateTimeString in dateTimeStrings){
    DateTime dateTime;
    bool wasParsed = DateTime.TryParse(dateTimeString, out dateTime);
    string result = dateTimeString +
    (wasParsed ? $"was parsed to {dateTime}"  : "can't be parsed to DateTime");
    Console.WriteLine(result);
  }
</code></pre>
    <h3>AddMilliseconds(Double)</h3>
    <pre><code>
    string dateFormat = "MM/dd/yyyy hh:mm:ss.fffffff";
    DateTime date1 = new DateTime(2010, 9, 8, 16, 0, 0);
    Console.WriteLine("Original date: {0} ({1:N0} ticks)\n",
    date1.ToString(dateFormat), date1.Ticks);

    DateTime date2 = date1.AddMilliseconds(1);
    Console.WriteLine("Second date: {0} ({1:N0} ticks)",
    date2.ToString(dateFormat), date2.Ticks);
    Console.WriteLine("Difference between dates: {0} ({1:N0} ticks)\n",
    date2 - date1, date2.Ticks - date1.Ticks);

    DateTime date3 = date1.AddMilliseconds(1.5);
    Console.WriteLine("Third date: {0} ({1:N0} ticks)",
    date3.ToString(dateFormat), date3.Ticks);
    Console.WriteLine("Difference between dates: {0} ({1:N0} ticks)",
    date3 - date1, date3.Ticks - date1.Ticks);
   </code></pre>
    <h3>Compare(DateTime t1, DateTime t2 )</h3>
    <pre><code>  
    DateTime date1 = new DateTime(2009, 8, 1, 0, 0, 0);
    DateTime date2 = new DateTime(2009, 8, 1, 12, 0, 0);
    int result = DateTime.Compare(date1, date2);
    string relationship;
    if (result < 0) 
      relationship="is earlier than" ; 
    else if (result==0) 
      relationship="is the same time as" ;
    else
      relationship="is later than" ;
    Console.WriteLine("{0} {1} {2}", date1, relationship, date2); 
    </code></pre>
    <h3>DaysInMonth(Int32, Int32)</h3>
    <pre><code>      
   const int July=7; 
   const int Feb=2; 

   int  daysInJuly=System.DateTime.DaysInMonth(2001, July); 
   Console.WriteLine(daysInJuly); 
   // daysInFeb gets 28 because the year 1998 was not a leap year. 
   
   int daysInFeb=System.DateTime.DaysInMonth(1998, Feb);
  Console.WriteLine(daysInFeb); 
  // daysInFebLeap gets 29 because the year 1996 was a leap year. 
  int daysInFebLeap=System.DateTime.DaysInMonth(1996, Feb); 
  Console.WriteLine(daysInFebLeap); 
    </code></pre>
    <h3>AddYears(Int32)</h3>
    Add years on the dateTime object
    <pre><code class="csharp">   
    baseDate = new DateTime(2000, 2, 29); 
    Console.WriteLine("Base Date: {0:d}\n", baseDate); 
    // Show dates of previous fifteen years. 
    for (int ctr=-1; ctr>= -15; ctr--)
        Console.WriteLine("{0,2} year(s) ago:{1:d}",Math.Abs(ctr), baseDate.AddYears(ctr));
    Console.WriteLine();    
    
    // Show dates of next fifteen years.
    for (int ctr = 1; ctr <= 15; ctr++) 
      Console.WriteLine("{0,2} year(s) from now: {1:d}", ctr, baseDate.AddYears(ctr));
    </code></pre>
    <h3>Pure functions warning when dealing with DateTime</h3>
    pure function is:
    1. The function always evaluates the same result value given the same argument value(s).
    The function result value cannot depend on any hidden information
    or state that may change while program execution proceeds or between different executions of the program,
    nor can it depend on any external input from I/O devices .

    2.Evaluation of the result does not cause any semantically observable side effect or output,
    such as mutation of mutable objects or output to I/O devices

    As a developer you need to be aware of pure methods and you will stumble upon these a lot in many areas.
    One I have seen that bites many junior developers is working with DateTime class methods.
    A lot of these are pure and if you are unaware of these you can be in for a suprise.
    An example:
    <pre><code>
     DateTime sample=new DateTime(2016, 12, 25); 
     sample.AddDays(1); 
     Console.WriteLine(sample.ToShortDateString()); 
     </code></pre>
    Given the example above one may expect the result printed to console to be '26/12/2016'
    but in reality you end up with the same date.
    This is because AddDays is a pure method and does not affect the original date.
    To get the expected output you would have to modify the AddDays call to the following:
    <cl>sample=sample.AddDays(1);</cl>

    <h3>TryParseExact(String, String, IFormatProvider, D ateTimeStyles, DateTime) </h3>
    - DateTime.Converts the specified string representation of a date and time
    to its DateTime equivalent using the specified format,culture-specific format information, and style.
    - The format of the string representation must match the specified format exactly.
    - The method returns a value that indicates whether the conversion succeeded.
    For Example
    <pre><code>
    CultureInfo enUS=new CultureInfo("en-US"); 
    string dateString; System.DateTime dateValue;
  
    //Parse date with no style flags.

    dateString=" 5/01/2009 8:30 AM" ;
    if (DateTime.TryParseExact(dateString, "g" ,enUS, DateTimeStyles.None, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    } else {
      Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    // Allow a leading space in the date string.
    if(DateTime.TryParseExact(dateString, "g" , enUS,DateTimeStyles.AllowLeadingWhite, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    //Use custom formats with M and MM.
    dateString="5/01/2009 09:00" ;
    if(DateTime.TryParseExact(dateString, "M/dd/yyyy hh:mm" , enUS, DateTimeStyles.None, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
      Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    // Allow a leading space in the date
    string. if(DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm" , enUS, DateTimeStyles.None, out dateValue)) {
    Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind); } else {
    Console.WriteLine("'{0}' is not in an acceptable format.", dateString); }

    //Parse a string with time zone information.
    dateString="05/01/2009 01:30:42 PM -05:00" ;
    if(DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm:ss tt zzz" ,
    enUS, DateTimeStyles.None, out dateValue)) {
    Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
    Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    // Allow a leading space in the date string.
    if (DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm:ss tt zzz" ,
    enUS, DateTimeStyles.AdjustToUniversal, out dateValue)) {
       Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    Parse a string represengting UTC.
    dateString="2008-06-11T16:11:20.0904778Z" ;
    if(DateTime.TryParseExact(dateString, "o" ,
    CultureInfo.InvariantCulture, DateTimeStyles.None, out dateValue)) {
        Console.WriteLine("Converted '{0}' to {1}({2}).", dateString, dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    if (DateTime.TryParseExact(dateString, "o" , CultureInfo.InvariantCulture,
    DateTimeStyles.RoundtripKind, out dateValue)) {
        Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    //Outputs ' 5/01/2009 8:30 AM' is not in an acceptable format.
    Converted ' 5/01/2009 8:30 AM' to 5/1/2009 8:30:00 AM(Unspecified).
    Converted '5/01/2009 09:00' to 5/1/2009 9:00:00 AM (Unspecified).
    '5/01/2009 09:00' is not in an acceptable format.
    Converted '05/01/2009 01:30:42 PM -05:00' to 5/1/2009 11:30:42 AM (Local).
    Converted '05/01/2009 01:30:42 PM -05:00' to 5/1/2009 6:30:42 PM (Utc).
    Converted '2008-06-11T16:11:20.0904778Z' to 6/11/2008 9:11:20 AM (Local).
    Converted '2008-06-11T16:11:20.0904778Z' to 6/11/2008 4:11:20 PM (Utc).
</code></pre>
    <h3>Add(TimeSpan)</h3>
    <pre><code>
    DateTime.Add(TimeSpan)
    // Calculate what day of the week is 36 days from this instant. 
    System.DateTime today=System.DateTime.Now; 
    System.TimeSpan duration=new System.TimeSpan(36, 0, 0, 0);
     System.DateTime answer=today.Add(duration); 
     System.Console.WriteLine("{0:dddd}", answer); 
     </code></pre>
    <h3>Parse and TryParse with culture info</h3>
    You might want to use it when parsing DateTimes from different cultures (languages),
    following example parses Dutch date.
    <pre><code>
  DateTime dateResult; 
    var dutchDateString="31 oktober 1999 04:20" ;
    var dutchCulture=CultureInfo.CreateSpecificCulture("nl-NL");
    DateTime.TryParse(dutchDateString, dutchCulture, styles, out dateResult); // output {31/10/1999 04:20:00} 
      //Example of Parse: 
    DateTime.Parse(dutchDateString, dutchCulture) // output {31/10/1999 04:20:00}  
    </code></pre>
    <h3> DateTime as initializer in for-loop</h3>
    <pre><code>
    // This iterates through a range between two DateTimes 
    // with the given iterator (any of the Add methods)
    
    DateTime start=new DateTime(2016, 01, 01); 
    DateTime until=new DateTime(2016, 02, 01); 
    // NOTICE: As the add methods return a new DateTime you have 
    // to overwrite dt in the iterator like dt=dt.Add() 
    for(DateTime dt=start; dt < until; dt=dt.AddDays(1)) { 
      Console.WriteLine("Added {0} days. Resulting DateTime: {1}", (dt
      - start).Days, dt.ToString()); 
    } 
    //Iterating on a TimeSpan works the same way. 
      
</code></pre>

    <h3> DateTime.ParseExact(String, String, IFormatProvider)</h3>
    Converts the specified string representation of a date and time to its DateTime equivalent using the specified
    format
    and culture-specific format information.
    The format of the string representation must match the specified format exactly.

    <b>Convert a specific format string to equivalent DateTime </b>
    Let's say we have a culture-specific DateTime string
    08-07-2016 11:30:12 PM as MM-dd-yyyy hh:mm:ss tt format and we want it to convert to equivalent DateTime object
    <pre><code>
 string str="08-07-2016 11:30:12 PM" ; 
 DateTime date=DateTime.ParseExact(str, "MM-dd-yyyy hh:mm:ss tt" , CultureInfo.CurrentCulture);
</code></pre>
    <b>Convert a date time string to equivalent DateTime object without any specific culture format</b>
    Let's say we have a DateTime string in dd-MM-yy hh:mm:ss tt format
    and we want it to convert to equivalent DateTime object, without any specific culture information
    <code>
string str="17-06-16 11:30:12 PM" ; 
DateTime date=DateTime.ParseExact(str, "dd-MM-yy hh:mm:ss tt" ,CultureInfo.InvariantCulture);   
</code>
    <b>Convert a date time string to equivalent DateTime object
      without any specific culture format with different format </b>

    Let's say we have a Date string , example like '23-12-2016' or '12/23/2016'
    and we want it to convert to equivalent DateTime object,
    without any specific culture information

    string date='23-12-2016' or date=12/23/2016';
    string[] formats=new string[] {"dd-MM-yyyy","MM/dd/yyyy"}; // even can add more possible formats.
    DateTime date=DateTime.ParseExact(date,formats, CultureInfo.InvariantCulture,DateTimeStyles.None);
    //NOTE : System.Globalization needs to be added for CultureInfo Class

    <h3>DateTime ToString, ToShortDateString,ToLongDateString and ToString formatted</h3>
    <pre><code>
 using System; public class Program { 
    public static void Main() {
      var date=new DateTime(2016,12,31); 
      Console.WriteLine(date.ToString()); 
      //Outputs: 12/31/2016 12:00:00 AM
      Console.WriteLine(date.ToShortDateString()); //Outputs: 12/31/2016 
      Console.WriteLine(date.ToLongDateString());//Outputs: Saturday, December 31, 2016 
      Console.WriteLine(date.ToString("dd/MM/yyyy")); //Outputs: 31/12/2016
    }
   }
  </code></pre>
    <h3>Current Date</h3>
    To get the current date you use the DateTime.Today property.
    This returns a DateTime object with today's date.
    When this is then converted .ToString() it is done so in your system's locality by default.
    For example:

    Console.WriteLine(DateTime.Today);

    Writes today's date, in your local format to the console.
  </div>
<h2>Arrays</h2>
  <div>
  <pre><code>
// Array Defenition :

int[] arr = new int[10];

// initializing using collection initialization syntax:
int[] arr = new int[] { 24, 2, 13, 47, 45 };
int[] arr = new int[3] {7,9,4};
Console.WriteLine(arr[0]); //outputs 7
Console.WriteLine(arr[1]); //outputs 9

int[] arr = null; // OK, declares a null reference to an array.
int first = arr[0]; // Throws System.NullReferenceException because there is no actual array.

// The new int[] portion can be omitted 
int[] arr = { 24, 2, 13, 47, 45 }; // OK

// This is not a self-contained expression, so
// using it as part of a different call does not work (for that, use the version with new):
int[] arr1;
arr1 = { 24, 2, 13, 47, 45 }; // Won't compile

// Implicitly typed arrays :

// In combination with the var keyword, the specific type may be omitted so that the type of the array is inferred:

// same as int[]
var arr = new [] { 1, 2, 3 };

// same as string[]
var arr = new [] { "one", "two", "three" };

// same as double[]
var arr = new [] { 1.0, 2.0, 3.0 };

// To create an array initialized with a non-default value:

int[] arr = new int[10];
//1. To create a bool array of size 10 filled with "true"
bool[] booleanArray = Enumerable.Repeat(true, 10).ToArray();

//2. To create an int array of size 5 filled with "100"
int[] intArray = Enumerable.Repeat(100, 5).ToArray();

//3. To create a string array of size 5 filled with "C#"
string[] strArray = Enumerable.Repeat("C#", 5).ToArray();

</code></pre>
<h3>Multidimensional Arrays</h3>
<pre><code>
int[, , , ,] arr5d; // five-dimensional array

int[,] arr2d = new int[3,2]{    {1, 2},  {3, 4}, {5, 6}   };
// or 
int[,] arr2d = {     {1, 2},   {3, 4},  {5, 6}    };
</code></pre>
<h3>Jagged Arrays: An Array of Array</h3>
<pre><code>
int[][] jArray = new int[2][]; 
jArray[0] = new int[3]{1, 2, 3};
jArray[1] = new int[4]{4, 5, 6, 7 };
</code></pre>
<h3>Copying arrays</h3>
<b>Array.Copy() </b>:
<pre><code>
var sourceArray = new int[] { 11, 12, 3, 5, 2, 9, 28, 17 };
var destinationArray= new int[3];
Array.Copy(sourceArray, destinationArray, 3);// destinationArray will have 11,12 and 3
</code></pre>
CopyTo() 
<pre><code>
//beginning at index 0 of the source and the specified index in the destination:
var sourceArray = new int[] { 11, 12, 7 };
var destinationArray = new int[6];
sourceArray.CopyTo(destinationArray, 2);
// destinationArray will have 0, 0, 11, 12, 7 and 0

//Clone is used to create a copy of an array object:

var sourceArray = new int[] { 11, 12, 7 };
var destinationArray = (int)sourceArray.Clone();
//destinationArray will be created and will have 11,12,17.  
</code></pre>
Both CopyTo and Clone perform shallow copy.
<b>shallow copy</b> means the contents contains references to the same object as the elements in the original array.
<h3>Comparing arrays for equality</h3>
<pre><code>
//SequenceEqual() :
int[] arr1 = { 3, 5, 7 };
int[] arr2 = { 3, 5, 7 };
bool result = arr1.SequenceEqual(arr2);
Console.WriteLine("Arrays equal? {0}", result);//prints: Arrays equal? True
</code></pre>
<h3>Multi-dimensional arrays</h3>
<pre><code>
  int[,] arr = new int[10, 10];
  int[,,] arr = new int[10, 10, 10];

 // You can also initialize the array upon declaration:
  int[,] arr = new int[4, 2] { {1, 1}, {2, 2}, {3, 3}, {4, 4} };
  Console.Out.WriteLine(arr[3, 1]); // 4  
</code></pre>
  <h3>Getting and setting array values</h3>
  <pre><code>
  int[] arr = new int[] { 0, 10, 20, 30};
  // Get
  Console.WriteLine(arr[2]); // 20

  // Set
  arr[2] = 100;
  Console.WriteLine(arr[2]); // 100
</code></pre>
<h3>Iterate over an array</h3>
<pre><code>
int[] arr = new int[] {1, 6, 3, 3, 9};
for (int i = 0; i < arr.Length; i++)
{
  Console.WriteLine(arr[i]);
}
// using foreach:
foreach (int element in arr)
{
  Console.WriteLine(element);
}

// using unsafe access with pointers 
unsafe
{
  int length = arr.Length;
  fixed (int* p = arr)
  {
    int* pInt = p;
    while (length-- > 0)
    {
      Console.WriteLine(*pInt);
      pInt++;// move pointer to next element
    }
  }
}
/*
Output:
1
6
3
3
9 */
</code></pre>
<h3>Enumerable.Range : Creating an array of sequential numbers</h3>
<pre><code>
int[] sequence = Enumerable.Range(1, 100).ToArray();
int[] squares = Enumerable.Range(2, 10).Select(  x => x * x ).ToArray();// 4 9 16 25 36 49 64 81 100 121
</code></pre>
<h3>Arrays as IEnumerable<> instances</h3>
- All arrays implement the non-generic <strong>IList</strong> interface.
(and hence non-generic <strong>ICollection</strong> and <strong>IEnumerable</strong> base interfaces).
- one-dimensional arrays implement the <strong>IList<></strong> and <strong>IReadOnlyList<></strong> generic interfaces.
(and their base interfaces) for the type of data that they contain.
This means that they can be treated as generic enumerable types
and passed in to a variety of methods without needing to first convert them to a non-array form.
<pre><code>
int[] arr1 = { 3, 5, 7 };
IEnumerable<int> enumerableIntegers = arr1; //Allowed because arrays implement IEnumerable<T>
List<int> listOfIntegers = new List<int>();
listOfIntegers.AddRange(arr1); //You can pass in a reference to an array to populate a List.
// the listOfIntegers will contain a List<int> containing the values 3, 5, and 7.
</code></pre>
 The IEnumerable<> support means arrays can be queried with LINQ, for example:
 <pre><code>arr1.Select(i => 10 * i)</code></pre> 
</div>
<h2>O(n) Algorithm, for circular rotation of an array</h2>
<div>
<h3>Example of a generic method that rotates an array by a given shift</h3>
<pre><code>
  public static void Main() {
    int[] array = {1,2,3,4,5,6,7,8,9,10};
    int shiftCount = 1;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    array = new[] {1,2,3,4,5,6,7,8, 9,10 };
    shiftCount = 15;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]

    array = new[] { 1,2,3,4,5,6,7,8,9,10};
    shiftCount = -1;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [2, 3, 4, 5, 6, 7, 8, 9, 10, 1]

    array = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    shiftCount = -35;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]
  }
  private static void Rotate < T > (ref T[] array, int shiftCount) {
    T[] backupArray = new T[array.Length];
    for (int index = 0; index < array.Length; index++) {
      backupArray[(index + array.Length + shiftCount % array.Length) % array.Length] = array[index];
    }
    array = backupArray;
  }
</code></pre>
</div>
<h2>Enum</h2>
<div>
<h3>Enum basics</h3>
- A type to define a set of named integral constants that may be assigned to a variable.
- An enum is a type that only allows a set of finite options,and each option corresponds to a number.
  By default, those numbers are increasing in the order the values are declared, starting from <b>zero</b>.
  
  For example:
<pre><code>
public enum Day
{
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
  Sunday
}
// usage :
Day myFavoriteDay = Day.Friday;
Day myLeastFavoriteDay = Day.Monday;
// Get the int that corresponds to myFavoriteDay
int myFavoriteDayIndex = (int)myFavoriteDay; //// Friday is number 4
Day dayFive = (Day)5;  //// Get the day that represents number 5

/* By default the underlying type of each element in the enum is int, 
but byte, sbyte, short, ushort, uint, long and ulong can be used as well. 
If you use a type other than int, you must specify the type using a colon after the enum name: */

public enum Weekday : byte { Monday = 1, Tuesday = 2, Wednesday = 3, Thursday = 4, Friday = 5 }
// The numbers after the name are now bytes instead of integers. 
//You could get the underlying type of the enum as  follows:
Enum.GetUnderlyingType(typeof(Days)));//Output:System.Byte  
/*
This is useful when Invoking to native code, mapping to data sources, and similar circumstances.
In general, the default int should be used, because most developers expect an enum to be an int.
*/
</code></pre>
<h3>Enum as flags</h3>
The <b>Flags</b> Attribute can be applied to an enum 
changing the behaviour of the ToString() to match the nature of the enum:
<pre><code>
 [Flags]
  enum MyEnum
  {
    //None = 0, can be used but not combined in bitwise operations
    FlagA = 1,
    FlagB = 2,
    FlagC = 4,
    FlagD = 8
    //you must use powers of two or combinations of powers of two
    //for bitwise operations to work
  }
  var twoFlags = MyEnum.FlagA | MyEnum.FlagB; 
  Console.WriteLine(twoFlags);// output : "FlagA, FlagB".
</code></pre>
- Because Flags Attribute relies on the enumeration constants to be powers of two (or their combinations)
and enum values are ultimately numeric values, you are limited by the size of the underlying numeric type.

- The largest available numeric type that you can use is UInt64,
which allows you to specify 64 distinct (non-combined) flag enum constants.

- The enum keyword defaults to the underlying type int, which is Int32.
- The compiler will allow the declaration of values wider than 32 bit.
- Those will wrap around without a warning and result in two or more enum members of the same value.
  Therefore, if an enum is meant to accomodate a bitset of more than 32 flags,
  you need to specify a bigger type explicitely:
<pre><code>
  public enum BigEnum : ulong
  {
    BigValue = 1 << 63
  }
  //  Although flags are often only a single bit, they can be combined into named "sets" for easier use.
  [Flags]
  enum FlagsEnum
  {
    None = 0,
    Option1 = 1,
    Option2 = 2,
    Option3 = 4,
    Default = Option1 | Option3,
    All = Option1 | Option2 | Option3,
  }
  //To avoid spelling out the decimal values of powers of two, 
  the left-shift operator (<<) can also be used to declare the same enum
  [Flags]
  enum FlagsEnum
  {
    None = 0,
    Option1 = 1 << 0,
    Option2 = 1 << 1,
    Option3 = 1 << 2,
    Default = Option1 | Option3,
    All = Option1 | Option2 | Option3,
  }  
 </code></pre>
- Starting with C# 7.0, binary literals can be used too.
- To check if the value of enum variable has a certain flag set,the HasFlag method can be used:
<pre><code>
[Flags]
enum MyEnum
{
  One = 1,
  Two = 2,
  Three = 4
}
//  And a value
var value = MyEnum.One | MyEnum.Two;
//With HasFlag we can check if any of the flags is set
if(value.HasFlag(MyEnum.One))
    Console.WriteLine("Enum has One");
if(value.HasFlag(MyEnum.Two))
    Console.WriteLine("Enum has Two");
if(value.HasFlag(MyEnum.Three))
    Console.WriteLine("Enum has Three");
//Also we can iterate through all values of enum to get all flags that are set
var type = typeof(MyEnum);
var names = Enum.GetNames(type);
foreach (var name in names)
{
    var item = (MyEnum)Enum.Parse(type, name);
    if (value.HasFlag(item))
      Console.WriteLine("Enum has " + name);
}

// Or
foreach(MyEnum flagToCheck in Enum.GetValues(typeof(MyEnum)))
{
    if(value.HasFlag(flagToCheck))
    {
      Console.WriteLine("Enum has " + flagToCheck);
    }
}

/*All three examples will print:
  Enum has One
  Enum has Two*/   
</code></pre>
<h3>Using << notation for flags </h3>
The left-shift operator (<<) can be used in flag enum declarations 
to ensure that each flag has exactly one 1 in binary representation, as flags should. 
        
This also helps to improve readability of large enums with plenty of flags in them. 
<pre><code>
[Flags] 
public enum MyEnum {
  None=0, Flag1=1 << 0, Flag2=1 << 1, Flag3=1 << 2, Flag4=1 << 3,
  Flag5=1 << 4, ... Flag31=1 << 30 
} 
</code></pre>          
It is obvious now that MyEnum contains proper flags only 
and not any messy stuff like Flag30=1073741822 (or 111111111111111111111111111110 in binary) which is inappropriate. 
  
<h3>Test flags-style enum values with bitwise logic </h3>
 A flags-style enum value needs to be tested with bitwise logic because it may not match any single value. 
 <pre><code>
 [Flags] 
 enum FlagsEnum {
   Option1=1, Option2=2, Option3=4,Option2And3=Option2 | Option3; Default=Option1 | Option3, 
} 
 </code></pre>

The Default value is actually a combination of two others merged with a bitwise OR. 
Therefore to test for the presence of a flag we need to use a bitwise AND.
<pre><code>
var value=FlagsEnum.Default; 
bool isOption2And3Set=(value & FlagsEnum.Option2And3)==FlagsEnum.Option2And3; 
Assert.True(isOption2And3Set);  
</code></pre>
<h3> Add and remove values from flagged enum </h3>
This code is to add and remove a value from a flagged enum-instance: 
<pre><code>
[Flags] 
public  enum MyEnum { Flag1=1 << 0, Flag2=1 << 1, Flag3=1 << 2 } 
var value=MyEnum.Flag1; // set additional value value
          |=MyEnum.Flag2; //value is now Flag1, Flag2 value 
          |=MyEnum.Flag3; //value is now Flag1, Flag2, Flag3 // remove
          flag value &=~MyEnum.Flag2; //value is now Flag1, Flag3   
</code></pre>
 <h3>Enum to string and back public enum</h3>
 <pre><code>
  DayOfWeek { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } // Enum to string string
  thursday=DayOfWeek.Thursday.ToString(); // "Thursday" 
  string seventhDay=Enum.GetName(typeof(DayOfWeek), 6);
  // "Saturday" string monday=Enum.GetName(typeof(DayOfWeek), DayOfWeek.Monday); // "Monday" 
  // String to enum (.NET 4.0+ only - see below for alternative syntax for earlier .NET versions) 
  DayOfWeek tuesday;
  Enum.TryParse("Tuesday", out tuesday); // DayOfWeek.Tuesday 
  DayOfWeek sunday; 
  bool matchFound1=Enum.TryParse("SUNDAY", out sunday); // Returns false (case-sensitive match) 
  DayOfWeek wednesday;
  bool matchFound2=Enum.TryParse("WEDNESDAY", true, out wednesday); 
  // Returns true; DayOfWeek.Wednesday (case-insensitive match) // String to enum (all .NET versions) 
  DayOfWeek friday=(DayOfWeek)Enum.Parse(typeof(DayOfWeek), "Friday" ); // DayOfWeek.Friday DayOfWeek
  caturday=(DayOfWeek)Enum.Parse(typeof(DayOfWeek), "Caturady" ); // Thows ArgumentException // All names of an
  enum type as strings string[] weekdays=Enum.GetNames(typeof(DayOfWeek)); 
 </code></pre>
<h3>Enums can have unexpected values </h3>
 Since an enum can be cast to and from its underlying integral type,
  the value may fall outside the range of values given in the definition of the enum type. 
  
  Although the below enum type DaysOfWeek only has 7 defined values, it can still hold any int value. 
  <pre><code>
public enum DaysOfWeek {
   Monday=1, Tuesday=2,Wednesday=3, Thursday=4, Friday=5, Saturday=6, Sunday=7 
} 
DaysOfWeek d=(DaysOfWeek)31; Console.WriteLine(d);
// prints 31 DaysOFWeek
s=DaysOfWeek.Sunday; s++; 
// No error There is currently no way to define an enum which does not have this behavior. 
// However, undefined enum values can be detected by using the method Enum.IsDefined. 
// For example, DaysOfWeek d=(DaysOfWeek)31;
Console.WriteLine(Enum.IsDefined(typeof(DaysOfWeek),d)); 
// prints False 
</code></pre>  
<h3> Default value for enum==ZERO </h3>
The default value for an enum is zero. 
If an enum does not define an item with a value of zero, its default value will be zero. 
<pre><code>
public class Program { enum EnumExample { one=1, two=2 } 
public void Main() { 
  var e=default(EnumExample); 
  if (e==EnumExample.one) 
    Console.WriteLine("defaults to one");   
  else Console.WriteLine("Unknown"); } } 
  Example: https://dotnetfiddle.net/l5Rwie  
</code></pre>
<h3>Adding additional description information to an enum value </h3>
In some cases you might want to add an additional description to an enum value,
for instance when the enum value itself is less readable than what you might want to display to the user.

In such cases you can use the  <cle>System.ComponentModel.DescriptionAttribute class</cle> 

For example:
<pre><code>
public enum PossibleResults {
          [Description("Success")] 
          OK=1, 
          [Description("File not found")] 
          FileNotFound=2, 
          [Description("Access denied")]
          AccessDenied=3 
        } 
</code></pre>
Now, if you would like to return the description of a specific enum value you can do the following: 
<pre><code>
public static string GetDescriptionAttribute(PossibleResults result) {
   return
          ((DescriptionAttribute)Attribute.GetCustomAttribute((result.GetType().GetField(result.ToString())),
          typeof(DescriptionAttribute))).Description; 
}
static void Main(string[] args) { P
  ossibleResults  result=PossibleResults.FileNotFound; 
  Console.WriteLine(result); // Prints "FileNotFound"
  Console.WriteLine(GetDescriptionAttribute(result)); // Prints "File not found" 
}
</code></pre>
This can also be easily transformed to an extension method for all enums: 
<pre><code>
static class EnumExtensions { 
  public static string GetDescription(this Enum enumValue) { 
    return
          ((DescriptionAttribute)Attribute.GetCustomAttribute(
            (enumValue.GetType().GetField(enumValue.ToStrin g())),
          typeof(DescriptionAttribute))).Description; } 
}
</code></pre>

And then easily used like this:
 <pre><code>Console.WriteLine(result.GetDescription()); </code></pre>         
          
<h3>  Get all the members values of an enum</h3>  
<pre><code>
enum MyEnum { One, Two, Three } 
foreach(MyEnum e in Enum.GetValues(typeof(MyEnum))) 
  Console.WriteLine(e); //This will print: One Two Three   
</code></pre>   

<h3>Bitwise Manipulation using enums </h3>
- The FlagsAttribute should be used whenever the enumerable represents a collection of flags, rather than a single value. 
- The numeric value assigned to each enum value helps when manipulating enums using bitwise operators.
<pre><code>
 //Example 1 : With [Flags] 
 [Flags] 
 enum Colors { Red=1, Blue=2, Green=4, Yellow=8 } 
 var color=Colors.Red | Colors.Blue; 
 Console.WriteLine(color.ToString()); 
 prints Red,Blue 
 
 //Example 2 : Without [Flags] 
 enum Colors { Red=1, Blue=2, Green=4, Yellow=8 } 
 var color=Colors.Red | Colors.Blue;
  Console.WriteLine(color.ToString()); prints 3 
</code></pre>
</div>
<h2>Tuples</h2>
<div>
<h3>Accessing tuple elements</h3>
To access tuple elements use <b>Item1-Item8</b> properties. 

<pre><code>
var tuple = new Tuple<string, int, bool, MyClass>("foo", 123, true, new MyClass());
var item1 = tuple.Item1; // "foo"
var item2 = tuple.Item2; // 123
var item3 = tuple.Item3; // true
var item4 = tuple.Item4; // new My Class()   

// Only the properties with index number less or equal to tuple size are going to be available 
var item5 = tuple.Item5; // Invalid
</code></pre>

<h3>Creating tuples</h3>
Tuples are created using generic types Tuple< T1>-Tuple< T1,T2,T3,T4,T5,T6,T7,T8>. 
Each of the types represents a tuple containing 1 to 8 elements. 
Elements can be of different types.
<pre><code>
// tuple with 4 elements
var tuple = new Tuple<string, int, bool, MyClass>("foo", 123, true, new MyClass());
</code></pre>
Tuples can also be created using <strong>static Tuple.Create</strong> methods. 
In this case, the types of the elements are inferred by the C# Compiler.
<pre><code>
// tuple with 4 elements
var tuple = Tuple.Create("foo", 123, true, new MyClass());  
</code></pre>
Version ≥ 7.0
Since C# 7.0, Tuples can be easily created using ValueTuple.
<pre><code>
var tuple = ("foo", 123, true, new MyClass());  
</code></pre>
Elements can be named for easier decomposition.
<pre><code>
 (int number, bool flag, MyClass instance) tuple = (123, true, new MyClass()); 
</code></pre>
<h3>Comparing and sorting Tuples</h3>
Tuples can be compared based on their elements.
As an example, an enumerable whose elements are of type Tuple can be sorted 
based on comparisons operators defined on a specified element
<pre><code>
list.Add(new Tuple<int, string>(2, "foo"));
list.Add(new Tuple<int, string>(1, "bar"));
list.Add(new Tuple<int, string>(3, "qux"));
list.Sort((a, b) => a.Item2.CompareTo(b.Item2)); //sort based on the string element
foreach (var element in list) {
    Console.WriteLine(element);
}
//(1, bar)
// (2, foo)
// (3, qux)

// Or to reverse the sort use:
//  list.Sort((a, b) => b.Item2.CompareTo(a.Item2));
  </code></pre>
<h3>Return multiple values from a method</h3>
Tuples can be used to return multiple values from a method without using out parameters. 
In the following example AddMultiply is used to return two values (sum, product).
<pre><code>
  void Write()
  {
    var result = AddMultiply(25, 28);
    Console.WriteLine(result.Item1);
    Console.WriteLine(result.Item2);
  }
  Tuple<int, int> AddMultiply(int a, int b)
  {
  return new Tuple<int, int>(a + b, a * b);
  }
  Output:
  53
  700</code></pre>
Now C# 7.0 offers an alternative way to return multiple values from methods 
using value tuples More info about ValueTuple struct.
  </div>
  <h2>Tuple literals</h2>
  <div>
  <pre><code>
  var bob = ("Bob", 23);    // Allow compiler to infer the element types
  Console.WriteLine (bob.Item1);   // Bob
  Console.WriteLine (bob.Item2);   // 23
  </code></pre>  
  </div>
  <h2>Guid</h2>
  <div>
    GUID (or UUID) is an acronym for 'Globally Unique Identifier' (or 'Universally Unique Identifier').
    It is a 128-bit integer number used to identify resources.
    <h3>Getting the string representation of a Guid</h3>
    A string representation of a Guid can be obtained by using the built in ToString method
    <cl>string myGuidString = myGuid.ToString();</cl>
    Depending on your needs you can also format the Guid,
    by adding a format type argument to the ToString call.
    <pre><code>var guid = new Guid("7febf16f-651b-43b0-a5e3-0da8da49e90d");
    // None "7febf16f651b43b0a5e30da8da49e90d"
    Console.WriteLine(guid.ToString("N"));
    // Hyphens "7febf16f-651b-43b0-a5e3-0da8da49e90d"
    Console.WriteLine(guid.ToString("D"));
    // Braces "{7febf16f-651b-43b0-a5e3-0da8da49e90d}"
    Console.WriteLine(guid.ToString("B"));
    // Parentheses "(7febf16f-651b-43b0-a5e3-0da8da49e90d)"
    Console.WriteLine(guid.ToString("P"));
    // Hex "{0x7febf16f,0x651b,0x43b0{0xa5,0xe3,0x0d,0xa8,0xda,0x49,0xe9,0x0d}}"
    Console.WriteLine(guid.ToString("X"));</code></pre>
    <h3>Creating a Guid</h3>
    These are the most common ways to create an instance of Guid:
    <pre><code>
   //Creating an empty guid (00000000-0000-0000-0000-000000000000):
    Guid g = Guid.Empty;
    Guid g2 = new Guid();

    //Creating a new (pseudorandom) Guid:
    Guid g = Guid.NewGuid();

    //Creating Guids with a specific value:
    Guid g = new Guid("0b214de7-8958-4956-8eed-28f9ba2c47c6");
    Guid g2 = new Guid("0b214de7895849568eed28f9ba2c47c6");
    Guid g3 = Guid.Parse("0b214de7-8958-4956-8eed-28f9ba2c47c6");      
    </code></pre>
 
    <h3>Declaring a nullable GUID</h3>
    Like other value types, GUID also has a nullable type which can take null value.
    <cl>Guid? myGuidVar = null;</cl>
    This is particularly useful when retrieving data from the data base
    when there is a possibility that value from a table is NULL.
</div>
<h2>BigInteger</h2>
<div>
<h3>Calculate the First 1,000-Digit Fibonacci Number</h3>
<pre><code> 
  using System;
  using System.Numerics;
  namespace Euler_25 {
      class Program {
          static void Main(string[] args) {
              BigInteger l1 = 1;
              BigInteger l2 = 1;
              BigInteger current = l1 + l2;
              while (current.ToString().Length < 1000) {
                  l2 = l1;
                  l1 = current;
                  current = l1 + l2;
              }
              Console.WriteLine(current);
          }
      }
    </code></pre>
  </div>

  <h2>collections</h2>
  <div>
  <h3>Collection Initializers</h3>

  Initialize a collection type with values
  <pre><code>var stringList = new List< string>{ "foo", "bar", };

  //  Collection initializers are syntactic sugar for Add() calls.
  // Above code is equivalent to
  var temp = new List< string>();
  temp.Add("foo");
  temp.Add("bar");
  var stringList = temp;
  </code></pre>
  - Note that the intialization is done atomically using a temporary variable,to avoid race conditions.
  - For types that offer multiple parameters in their Add() method, enclose the comma-separated arguments in curly braces:
  <pre><code>
    var numberDictionary = new Dictionary < int,string > 
    {
      {
          1,
          "One"
      },
      {
          2,
          "Two"
      },
  };

  //This is equivalent to:
  var temp = new Dictionary<int, string>();
  temp.Add(1, "One");
  temp.Add(2, "Two");
  var numberDictionarynumberDictionary = temp;
  </code></pre>
  <h3>Index Initializers</h3>
  Starting with C# 6, 
  collections with indexers can be initialized by specifying the index to assign in square brackets,
  followed by an equals sign, followed by the value to assign.
  Dictionary Initialization
  An example of this syntax using a Dictionary:
  <pre><code>
  var dict = new Dictionary < string,int > {
        ["key1"] = 1,
        ["key2"] = 50
    };
  //This is equivalent to:
  var dict = new Dictionary < string, int > ();
  dict["key1"] = 1;
  dict["key2"] = 50

  //The collection initializer syntax to do this before C # 6 was:
  var dict = new Dictionary < string, int > {
              {
                  "key1",
                  1
              },
              {
                  "key2",
                  50
              }
          };
  //Which would correspond to:
  var dict = new Dictionary < string, int > ();
  dict.Add("key1", 1);
  dict.Add("key2", 50);
  </code></pre>
  example2:
  <pre><code>
  public class IndexableClass {
    public int this[int index] {
      set {
          Console.WriteLine("{0} was assigned to index {1}", value, index);
      }
    }
  }
  var foo = new IndexableClass {
      [0] = 10,
      [1] = 20
  }
  /*
  This would output:
  10 was assigned to index 0
  20 was assigned to index 1
  */
    </code></pre>
  <h3>Collection initializers in custom classes</h3>
  To make a class support collection initializers, 
  it must implement IEnumerable interface and have at least one Add method. 
  Since C# 6, any collection implementing IEnumerable can be extended with custom Add methods using extension methods.
  <pre><code>
  class Program
  {
    static void Main()
    {
    var col = new MyCollection {
      "foo",
      { "bar", 3 },  
      class Program {
        static void Main() {
            var col = new MyCollection {
                "foo",
                {
                    "bar",
                    3
                },
                "baz",
                123.45 d,
            };
        }
    }
  class MyCollection: IEnumerable {
      private IList list = new ArrayList();
      public void Add(string item) {
          list.Add(item)
      }
      public void Add(string item, int count) {
          for (int i = 0; i < count; i++) {
              list.Add(item);
          }
      }
      public IEnumerator GetEnumerator() {
          return list.GetEnumerator();
      }
  }
  static class MyCollectionExtensions {
      public static void Add(this MyCollection @this, double value) =>
          @this.Add(value.ToString());
  }
  </code></pre>
  <h3>Using collection initializer inside object initializer</h3>
  <pre><code>
    public class Tag {
      public IList < string > Synonyms {
          get;
          set;
      }
  }
  // Synonyms is a collection - type property.When the Tag object is created using object initializer syntax, 
  //Synonyms can also be initialized with collection initializer syntax:
Tag t = new Tag {
    Synonyms = new List < string > {
        "c#",
        "c-sharp"
    }
};
  // The collection property can be readonly and still support collection initializer syntax.Consider this modified
  example(Synonyms property now has a private setter):
  public class Tag {
      public Tag() {
          Synonyms = new List < string > ();
      } 
  public IList<string> Synonyms { get; private set; }
  }
  //    A new Tag object can be created like this:
      Tag t = new Tag
      {
      Synonyms = {"c#", "c-sharp"}
      };
  // This works because collection initializers are just syntatic sugar over calls to Add(). There's no new list being created
    // here, the compiler is just generating calls to Add() on the exiting object
  </code></pre>
  <h3>Collection Initializers with Parameter Arrays</h3>
  You can mix normal parameters and parameter arrays:
  <pre><code>
  public class LotteryTicket : IEnumerable{
      public int[] LuckyNumbers;
      public string UserName;
      public void Add(string userName, params int[] luckyNumbers){
        UserName = userName;
        Lottery = luckyNumbers;
      }
    }
  //This syntax is now possible:
  var Tickets = new List<LotteryTicket>{
      {"Mr Cool" , 35663, 35732, 12312, 75685},
      {"Bruce" , 26874, 66677, 24546, 36483, 46768, 24632, 24527},
      {"John Cena", 25446, 83356, 65536, 23783, 24567, 89337}
    }
  </code></pre>
    <h3>HashSet< T>
    </h3>
    This is a collection of unique items, with O(1) lookup.
    <pre><code>
    HashSet<int> validStoryPointValues = new HashSet<int>() { 1, 2, 3, 5, 8, 13, 21 };
    bool containsEight = validStoryPointValues.Contains(8); // O(1)
    
    // By way of comparison, doing a Contains on a List yields poorer performance:
    List<int> validStoryPointValues = new List<int>() { 1, 2, 3, 5, 8, 13, 21 };
    bool containsEight = validStoryPointValues.Contains(8); // O(n)

    //HashSet.Contains uses a hash table, so that lookups are extremely fast
   </code></pre>
    <h3>Dictionary< TKey, TValue>
    </h3>
    <b>Dictionary< TKey, TValue></TKey></b> is a map. 
    For a given key there can be one value in the dictionary
    <pre><code>
      using System.Collections.Generic;
      var people = new Dictionary < string, int > {
              {  "John",   30     },
              { "Mary",    35     },
              { "Jack",   40      }
          };
      // Reading data :
      Console.WriteLine(people["John"]); // 30
      Console.WriteLine(people["George"]); // throws KeyNotFoundException
      int age;
      if (people.TryGetValue("Mary", out age)) {
          Console.WriteLine(age); // 35
      }

      // Adding and changing data :
      people["John"] = 40;    // Overwriting values this way is ok
      people.Add("John", 40); // Throws ArgumentException since "John" already exists

      // Iterating through contents
      foreach(KeyValuePair < string, int > person in people) {
          Console.WriteLine("Name={0}, Age={1}", person.Key, person.Value);
      }
      foreach(string name in people.Keys) {
          Console.WriteLine("Name={0}", name);
      }
      foreach(int age in people.Values) {
          Console.WriteLine("Age={0}", age);
      }
      var people = new Dictionary < string, int > {
              { "John",   30              },
              {"Mary",    35              },
              {"Jack",    40              },
              {"Jack",    40              }
     }; // throws ArgumentException since "Jack" already exists 
    </code></pre>
      <h3>SortedSet< T>
      </h3>
      <pre><code>
      // create an empty set
      var mySet = new SortedSet<int>();

      // add something
      // note that we add 2 before we add 1
      mySet.Add(2);
      mySet.Add(1);

      // enumerate through the set
      foreach(var item in mySet)
      {
        Console.WriteLine(item);
      }
      // output:
      // 1
      // 2
    </code></pre>
      <h3>T[ ] (Array of T)</h3>
      <pre><code>
      var myArray = new [] {
        "one",
        "two"
    };
    // enumerate through the array
    foreach(var item in myArray) {
        Console.WriteLine(item);
    }
    // output:
    // one
    // two

    // exchange the element on the first position
    myArray[0] = "something else";

    // enumerate through the array again
    foreach(var item in myArray) {
        Console.WriteLine(item);
    }
    // output:
    // something else
    // two
    </code></pre>
      <h3>List< T>
      </h3>
      List< T> is a list of a given type. 
      Items can be added, inserted, removed and addressed by index.
    <pre><code>
    using System.Collections.Generic;
    var list = new List<int>() { 1, 2, 3, 4, 5 };
    list.Add(6);
    Console.WriteLine(list.Count); // 6
    list.RemoveAt(3);
    Console.WriteLine(list.Count); // 5
    Console.WriteLine(list[3]); // 5
    </code></pre>
- List< T> can be thought of as an array that you can resize.
- Enumerating over the collection in order is quick, as is access to individual elements via their index.
- To access elements based on some aspect of their value, 
  or some other key, a Dictionary< T> will provide faster lookup.
<h3>Stack < T> </h3>
elements are stored with "first in, last out" order.
<pre><code>
// Initialize a stack object of integers
var stack = new Stack<int>();

// add some data
stack.Push(3);
stack.Push(5);
stack.Push(8);

// stack from top to bottom is: 8, 5, 3
// We can use peek to see the top element of the stack.
Console.WriteLine(stack.Peek()); // prints 8

// Pop removes the top element of the stack and returns it.
Console.WriteLine(stack.Pop()); // prints 8
Console.WriteLine(stack.Pop()); // prints 5
Console.WriteLine(stack.Pop()); // prints 3 
</code></pre>
<h3>LinkedList< T></h3> 
Note that LinkedList< T> represents the doubly linked list.
So, it's simply collection of nodes and each node
contains an element of type T.
Each node is linked to the preceding node and the following node
<pre><code>
  // initialize a LinkedList of integers
  LinkedList list = new LinkedList<int>();
  // add some numbers to our list.
  list.AddLast(3);
  list.AddLast(5);
  list.AddLast(8);
  // the list currently is 3, 5, 8
  list.AddFirst(2);
  // the list now is 2, 3, 5, 8
  list.RemoveFirst();
  // the list is now 3, 5, 8
  list.RemoveLast();
  // the list is now 3, 5
</code></pre>
           
<h3>Queue</h3>
<pre><code>
// Initalize a new queue of integers
var queue = new Queue<int>();
// Add some data
queue.Enqueue(6);
queue.Enqueue(4);
queue.Enqueue(9);
// Elements in a queue are stored in "first in, first out" order.
// The queue from first to last is: 6, 4, 9
// View the next element in the queue, without removing it.
Console.WriteLine(queue.Peek()); // prints 6
// Removes the first element in the queue, and returns it.
Console.WriteLine(queue.Dequeue()); // prints 6
Console.WriteLine(queue.Dequeue()); // prints 4
Console.WriteLine(queue.Dequeue()); // prints 9
</code></pre>
</div>

  <h2>Looping</h2>
  <div>
    <h3>For Loop</h3>
    <pre><code>
      for (int i = 0; i < 5; i++)
      {
       Console.WriteLine(i);
      }// output: 01234
    </code></pre>
    <h3>Do - While Loop</h3>
    <pre><code>
      int[] numbers = new int[] { 6, 7, 8, 10 };
      // Sum values from the array until we get a total that's greater than 10,
      // or until we run out of values.
      int sum = 0;
      int i = 0;
      do
      {
        sum += numbers[i];
        i++;
      } while (sum <= 10 && i < numbers.Length);
      System.Console.WriteLine(sum); // 13
    </code></pre>
    <h3>Foreach Loop</h3>
    foreach will iterate over any object of a class that implements IEnumerable 
    (take note that IEnumerable<T> inherits from it). 
    Such objects include some built-in ones, but not limit to: 
    List< T >, T[] (arrays of any type), Dictionary< TKey, TSource>, 
      as well as interfaces like IQueryable and ICollection, etc.
    <pre><code>
  var list = new List<string>();
    list.Add("Ion");
    list.Add("Andrei");
    foreach(var name in list)
    {
      Console.WriteLine("Hello " + name);
    }
    
    //is equivalent to:
    
    var list = new List<string>();
    list.Add("Ion");
    list.Add("Andrei");
    IEnumerator enumerator;
    try
    {
      enumerator = list.GetEnumerator();
      while (enumerator.MoveNext())
      {
        string name = (string)enumerator.Current;
        Console.WriteLine("Hello " + name);
      }
    }
    finally
    {
      if (enumerator != null)
        enumerator.Dispose();
    }
    </code></pre>
    <h3>Foreach Method</h3>
    <pre><code>
      list.ForEach(item => item.DoSomething());
      // or
      list.ForEach(item => DoSomething(item));
      // or using a method group
      list.ForEach(Console.WriteLine);
      // using an array
      Array.ForEach(myArray, Console.WriteLine); 
    </code></pre>
    <h3>Linq Parallel Foreach</h3>
      Just like Linq Foreach, except this one does the job in a parallel manner. 
      Meaning that all the items in the collection
      will run the given action at the same time, simultaneously.    
    <pre><code>
      collection.AsParallel().ForAll(item => item.DoSomething());
      /// or
      collection.AsParallel().ForAll(item => DoSomething(item));
    </code></pre>
  <h3>continue</h3>
  In addition to break, there is also the keyword continue. 
  Instead of breaking completely the loop, it will simply skip the current iteration. 
  It could be useful if you don't want some code to be executed if a particular value is set.
  <pre><code>
    for (int i = 1; i <= 10; i++)
    {
      if (i < 9)
        continue;
      Console.Write(i);  
    }//output 910
  </code></pre>
  <h3>IEnumrator</h3>
  <pre><code>
    // Call a custom method that takes a count, and returns an IEnumerator for a list
    // of strings with the names of theh largest city metro areas.
    IEnumerator<string> largestMetroAreas = GetLargestMetroAreas(4);
    while (largestMetroAreas.MoveNext())
    {
      Console.WriteLine(largestMetroAreas.Current);
    }
 /* output:
    Tokyo / Yokohama
    New York Metro
    Sao Paulo
    Seoul / Incheon */
  </code></pre>
   
  </div>
 
  <h2>Iterators</h2>
    <div>
   Whereas a foreach statement is a consumer of an enumerator, an iterator is a producer of an enumerator:
  <pre><code>
  foreach (int fib in Fibs(6))
    Console.Write (fib + "  ");

  IEnumerable< int > Fibs (int fibCount)
  {
    for (int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)
    {
      yield return prevFib;
      int newFib = prevFib+curFib;
      prevFib = curFib;
      curFib = newFib;
    }
  }    
  </code></pre>   
    </div>
  <h2>Iterators</h2>
  <div>
  
    <h3>Creating Iterators Using Yield</h3>
    - Iterators produce enumerators. 
    - enumerators are produced by defining methods, properties or indexers that contain yield statements.
    - Most methods will return control to their caller through normal return statements,
      which disposes all state local to that method. 
    - In contrast, methods that use yield statements allow them to return multiple values 
      to the caller on request while preserving local state in-between returning those values. 
    - These returned values constitute a sequence. 
    - There are two types of yield statements used within iterators:
      - <b>yield return</b>, which returns control to the caller but preserves state. 
        The callee will continue execution from this line when control is passed back to it.
      - <b>yield break</b>, which functions similarly to a normal return statement - this signifies the end of the sequence.
    Normal return statements themselves are illegal within an iterator block.
    This example below demonstrates an iterator method that can be used to generate the Fibonacci sequence:
    <pre><code>
      IEnumerable<int> Fibonacci(int count)
        {
          int prev = 1;
          int curr = 1;
          for (int i = 0; i < count; i++)
          {
            yield return prev;
            int temp = prev + curr;
            prev = curr;
            curr = temp;
          }
        }
        // This iterator can then be used to produce an enumerator of the Fibonacci sequence 
        // that can be consumed by a calling method. 
        // The code below demonstrates how the first ten terms within the Fibonacci sequence can be enumerated:
        void Main()
        {
          foreach (int term in Fibonacci(10))
          {
            Console.Write(term);
            Console.Write(' ');
          }
        }
        // Output: 1 1 2 3 5 8 13 21
    </code></pre>
    <h3>Simple Numeric Iterator Example</h3>
    A common use-case for iterators is to perform some operation over a collection of numbers.
    The example below demonstrates how each element within an array of numbers can be individually printed out to the console.
    This is possible because arrays implement the IEnumerable interface, 
    allowing clients to obtain an iterator for the array using the GetEnumerator() method. 
    This method returns an enumerator, which is a read-only, forward-only cursor over each number in the array.
    <pre><code>
      int[] numbers = { 1, 2, 3, 4, 5 };
      IEnumerator iterator = numbers.GetEnumerator();
      while (iterator.MoveNext())
      {
        Console.Write(iterator.Current);
        Console.Write('\t')
      }
      // Output:   1    2     3     4     5

      //It's also possible to achieve the same results using a foreach statement:
      foreach (int number in numbers)
      {
        Console.WriteLine(number);
      }
    </code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

  <h2></h2>
  <div>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
    <h3></h3>
    <pre><code></code></pre>
  </div>

</body>

</html>
<!--script>
 //$('code').addClass('language-csharp hljs');
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((el) => {
    hljs.highlightElement(el);
  });
});
</script-->