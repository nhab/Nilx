<head<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/nhab/assets/css/blocks.css">
<script src='/nhab/assets/js/blocks.js'></script>
<link rel="stylesheet" href="/nhab/libs/highlight/androidstudio2.css">
<!--https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/androidstudio.min.css"-->
<!--github-dark.min.css-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"
  integrity="sha512-9ia7twbVj1OAzFDTFTzf/x2LrAc/Hf1KlzHTbyxfJZXA+YQP2eXOFWr7E3ZZ6SgtAZZza2PDXvcQjXQ5nZ9GAw=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>

<body onload="AddToggleButtons()">
  <button onclick="toggleAll(this);">-</button>
  <h2>Resources</h2>
  <div>
    <a href='https://learn.microsoft.com/en-us/dotnet/csharp/'>Microsoft C# Reference and other resources</a>
    <a href='https://www.tutorialsteacher.com/csharp/csharp-generics'>generics</a>
    <a href='https://www.albahari.com/nutshell/code.aspx'>in a nutshell</a>
  </div>
  <h2>Extension Method Chaining</h2>
  <div>
      Extension methods, like instance methods, provide a tidy way to chain functions:
  <pre><code>
string x = "sausage".Pluralize().Capitalize();
x.Dump();

// Equivalent to:
string y = StringHelper.Capitalize (StringHelper.Pluralize ("sausage"));
y.Dump();

// LINQPad's Dump method is an extension method:
"sausage".Pluralize().Capitalize().Dump();

public static class StringHelper
{
  public static string Pluralize (this string s) => s + "s";   // Very naiive implementation!

  public static string Capitalize (this string s) => s.ToUpper();
}
</code></pre>    
  </div>  
  <h2>Anonymous Types</h2>
  <div>
An anonymous type is a simple class created by the compiler on the fly to store a set of values
<code>
var dude = new { Name = "Bob", Age = 23 };

//Anonymous Types - with keyword

    var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
    var a2 = a1 with { E = 10 };
    a2.Dump();
</code>    
  </div>
 <h2>Record</h2>
 <div>
 new in C# 9.0
- defines a reference type that provides built-in functionality for encapsulating data.
Defining a record
<pre><code>
new Point (2, 3).Dump();

// Run the line below to look at Point in ILSpy.
// Util.OpenILSpy (typeof (Point));

record Point
{
  public Point (double x, double y) => (X, Y) = (x, y);

  public double X { get; init; }
  public double Y { get; init; }    
}
</code></pre>
- Record types have a compiler-generated ToString method 
that displays the names and values of public properties and fields.
- A record can inherit from another record.
  However, a record can't inherit from a class, and a class can't inherit from a record.
- For two record variables to be equal, the run-time type must be equal. 
The types of the containing variables might be different.
<b>Dynamic Type</b>
is to avoid compile-time type checking.
The dynamic type changes its type at the run time based on the value present on the right-hand side
<pre><code>
    dynamic value = 123;
</code></pre>
 </div>
<h2>Unsafe code (using pointers)</h2>
<div>
<pre><code>
//    Unsafe Code

// C# supports direct memory manipulation via pointers within blocks of code marked unsafe
// and compiled with the /unsafe compiler option. LINQPad implicitly compiles with this option.

// Here's how to use pointers to quickly process a bitmap:

int [,] bitmap = { { 0x101010, 0x808080, 0xFFFFFF }, { 0x101010, 0x808080, 0xFFFFFF } };
BlueFilter (bitmap);
bitmap.Dump();

unsafe static void BlueFilter (int [,] bitmap)
{
  int length = bitmap.Length;
  fixed (int* b = bitmap)
  {
    int* p = b;
    for (int i = 0; i < length; i++)
      *p++ &= 0xFF;
  }
}
</code></pre>
</div>
<h2>Regx Parsing</h2>
<div>
Pattern The string pattern that has to be used for the lookup. 
The common options in here are Singleline and Multiline. They are changing the
behaviour of pattern-elements like the dot (.) which won't cover a NewLine (\n) in
Multiline-Mode but in SingleLine-Mode. Default behaviour: msdn
Timeout [Optional] Where patterns are getting more complex the lookup can consume more time.
 This is the
passed timeout for the lookup just as known from network-programming.
<b>Single match</b>
<pre><code>
 using System.Text.RegularExpressions;
string pattern = ":(.*?):";
string lookup = "--:text in here:--";
// Instanciate your regex object and pass a pattern to it
Regex rgxLookup = new Regex(pattern, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
// Get the match from your regex-object
Match mLookup = rgxLookup.Match(lookup);
// The group-index 0 always covers the full pattern.
// Matches inside parentheses will be accessed through the index 1 and above.
string found = mLookup.Groups[1].Value;
Result:
found = "text in here" 
</code></pre>
    <b>Multiple matches</b>
    <pre><code>
  using System.Text.RegularExpressions;
  List<string> found = new List<string>();
  string pattern = ":(.*?):";
  string lookup = "--:text in here:--:another one:-:third one:---!123:fourth:";
  // Instanciate your regex object and pass a pattern to it
  Regex rgxLookup = new Regex(pattern, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
  MatchCollection mLookup = rgxLookup.Matches(lookup);
  foreach(Match match in mLookup)
  {
  found.Add(match.Groups[1].Value);
  }
  Result:
  found = new List<string>() { "text in here", "another one", "third one", "fourth" }  
</code></pre>

  </div>

<h2>ToString()</h2>
  <div>
    The ToString() method is present on all reference object types.
    This is due to all reference types being derived from Object which has the ToString() method on it.
    The ToString() method on the object base class returns the type name.
    The fragment below will print out "User" to the console.
    <pre><code>
public class User
{
public string Name { get; set; }
public int Id { get; set; }
}
...
var user = new User {Name = "User1", Id = 5};
Console.WriteLine(user.ToString());

//However, the class User can also override ToString() in order to alter the string it returns. 
//The code fragment below prints out "Id: 5, Name: User1" to the console.
public class User
  {
  public string Name { get; set; }
  public int Id { get; set; }
  public override ToString()
  {
    return string.Format("Id: {0}, Name: {1}", Id, Name);
  }
}
...
var user = new User {Name = "User1", Id = 5};
Console.WriteLine(user.ToString());

string outsidetext = "I am outside of bracket";
string.Format("{{I am in brackets!}} {0}", outsidetext);
//Outputs "{I am in brackets!} I am outside of bracket"
</code></pre>
</div>
<h2>Formatting</h2>
  <div>
    <b>Numeric formats</b>
    <pre><code>
  // Integral types as hex
  string.Format("Hexadecimal: byte2: {0:x2}; byte4: {0:X4}; char: {1:x2}", 123, (int)'A');
  // Integers with thousand separators
  string.Format("Integer, thousand sep.: {0:#,#}; fixed length: >{0,10:#,#}<", 1234567);
  // Integer with leading zeroes
  string.Format("Integer, leading zeroes: {0:00}; ", 1);
  // Decimals
  string.Format("Decimal, fixed precision: {0:0.000}; as percents: {0:0.00%}", 0.12);
  Output:
  Hexadecimal: byte2: 7b; byte4: 007B; char: 41
  Integer, thousand sep.: 1,234,567; fixed length: > 1,234,567<
  Integer, leading zeroes: 01;
  Decimal, fixed precision: 0.120; as percents: 12.00%
</code></pre>
    <b>custom number format</b>
    <pre><code>
  // invariantResult is "1,234,567.89"
  var invarianResult = string.Format(CultureInfo.InvariantCulture, "{0:#,###,##}", 1234567.89);
  // NumberFormatInfo is one of classes that implement IFormatProvider
  var customProvider = new NumberFormatInfo
  {
  NumberDecimalSeparator = "_NS_", // will be used instead of ','
  NumberGroupSeparator = "_GS_", // will be used instead of '.'
  };
  // customResult is "1_GS_234_GS_567_NS_89"
  var customResult = string.Format(customProvider, "{0:#,###.##}", 1234567.89);  
</code></pre>
    <b>String formatting</b>
    <pre><code class="csharp">
// float with two decimal places
String.Format("{0:0.00}", 123.4567);      // "123.46"
String.Format("{0:0.00}", 123.4);         // "123.40"
String.Format("{0:0.00}", 123.0);         // "123.00"

//Since C# 6.0 it is possible to use string interpolation in place of String.Format.
string name = "John";
string lastname = "Doe";
Console.WriteLine($"Hello {name} {lastname}!");//Hello John Doe!

</code></pre>
    <b>Formatting using ToString</b>
    <pre><code>
 // Integer to formatted string:
  int intValue = 10;
  string zeroPaddedInteger = intValue.ToString("000"); // Output will be "010"
  string customFormat = intValue.ToString("Input value is 0"); // output will be "Input value is 10"
 // double to formatted string:
  double doubleValue = 10.456;
  string roundedDouble = doubleValue.ToString("0.00"); // output 10.46
  string integerPart = doubleValue.ToString("00"); // output 10
  string customFormat = doubleValue.ToString("Input value is 0.0"); // Input value is 10.5
 // Formatting DateTime using ToString
  DateTime currentDate = DateTime.Now; // {7/21/2016 7:23:15 PM}
  string dateTimeString = currentDate.ToString("dd-MM-yyyy HH:mm:ss"); // "21-07-2016 19:23:15"
  string dateOnlyString = currentDate.ToString("dd-MM-yyyy"); // "21-07-2016"
  string dateWithMonthInWords = currentDate.ToString("dd-MMMM-yyyy HH:mm:ss"); // "21-July-2016 19:23:15"
</code></pre>
    <b>Create a custom format provider</b>
    <pre><code>
  public class CustomFormat : IFormatProvider, ICustomFormatter
  {
    public string Format(string format, object arg, IFormatProvider formatProvider)
    {
      if (!this.Equals(formatProvider))
      {
        return null;
      }
      if (format == "Reverse")
      {
        return String.Join("", arg.ToString().Reverse());
      }
      return arg.ToString();
    }
    public object GetFormat(Type formatType)
    {
        return formatType==typeof(ICustomFormatter) ? this:null;
    }
  }
  //Usage:
    String.Format(new CustomFormat(), "-> {0:Reverse} <-", "Hello World");//Output:    -> dlroW olleH <-
</code></pre>
    <b>Format dates in strings</b>
    <pre><code>
  var date = new DateTime(2015, 11, 11);
  var str = $"It's {date:MMMM d, yyyy}, make a wish!";
  System.Console.WriteLine(str);
  
 // You can also use the DateTime.ToString method to format the DateTime object. This will produce the same output
 // as the code above.

  var date = new DateTime(2015, 11, 11);
  var str = date.ToString("MMMM d, yyyy");
  str = "It's " + str + ", make a wish!";
  Console.WriteLine(str);// Output:  It's November 11, 2015, make a wish!
</code></pre>
    <b>Align left/ right, pad with spaces</b>
    <pre><code>
  string.Format("LEFT: string: ->{0,-5}<- int: ->{1,-5}<-", "abc", 123);
  string.Format("RIGHT: string: ->{0,5}<- int: ->{1,5}<-", "abc", 123);
  Output:
  LEFT: string: ->abc <- int: ->123 <-
  RIGHT: string: -> abc<- int: -> 123<-  
</code></pre>
    <b>Padding with Format Specifiers</b>
    You can also use existing formatting specifiers in conjunction with padding.
    <pre><code>
var number = 42;
var str = $"The answer to life, the universe and everything is ${number, 5:f1}";
//str is "The answer to life, the universe and everything is 42.1 ";
//                                                           ^^^^^  
</code></pre>
</div>

<h2>Strings</h2>
  <div>
    <b>Expressions</b>
    <pre><code>
  var StrWithMathExpression = $"1 + 2 = {1 + 2}"; // -> "1 + 2 = 3"
  string world = "world";
  var StrWithFunctionCall = $"Hello, {world.ToUpper()}!"; // -> "Hello, WORLD!"
</code></pre>
    <b>Splitting a String by another string</b>
    <pre><code>
  string str = "this--is--a--complete--sentence";
  string[] tokens = str.Split(new[] { "--" }, StringSplitOptions.None);
 // Result:
//  [ "this", "is", "a", "complete", "sentence" ] 
</code></pre>
    <b>Splitting a String by specific character</b>
    <pre><code>
  string helloWorld = "hello world, how is it going?";
  string[] parts1 = helloWorld.Split(',');
  //parts1: ["hello world", " how is it going?"]
  string[] parts2 = helloWorld.Split(' ');
  //parts2: ["hello", "world,", "how", "is", "it", "going?"]
</code></pre>
    other things:
    <pre><code>
  string helloWorld = "Hello World!";

  string world = helloWorld.Substring(6); //world = "World!"
  string hello = helloWorld.Substring(0,5); // hello = "Hello"

  HelloWorld.StartsWith("Hello"); // true
  HelloWorld.StartsWith("Foo"); // false

  bool stringExists = s.Contains("ello"); //stringExists =true as the string contains the substring

  char c = s[1]; //Returns 'e'
</code></pre>
    <b>Joining an array of strings into a new one</b>
    <pre><code>
  var parts = new[] { "Foo", "Bar", "Fizz", "Buzz"};
  var joined = string.Join(", ", parts);
  //joined = "Foo, Bar, Fizz, Buzz" 
</code></pre>
<b>Replacing a string within a string</b>
<pre><code>
string s = "Hello World";

s = s.Replace("World", "Universe"); // s = "Hello Universe"  

//This method can also be used to remove part of a string, using the String.Empty field:
s = s.Replace("ell", String.Empty); // s = "Ho World"
</code></pre>
<b>Changing the case of characters within a String</b>
System.String.ToLowerInvariant is used to return a String object converted to lowercase.
System.String.ToUpperInvariant is used to return a String object converted to uppercase
<pre><code>
string s = "My String";
s = s.ToLowerInvariant(); // "my string"
s = s.ToUpperInvariant(); // "MY STRING"
</code></pre>
    <b>Concatenating </b>
    <pre><code>
  //an array of strings into a single
  string[] words = {"One", "Two", "Three", "Four"};
  string singleString = String.Join(",", words); // singleString = "One,Two,Three,Four"

//String Concatenation
string first = "Hello ";
string second = "World";
string concat = first + second; // concat = "Hello World"
concat = String.Concat(first, second); // concat = "Hello World"
In C# 6 this can be done as follows:
string concat = $"{first},{second}";
//Concat string array elements using String.Join
string[] value = {"apple", "orange", "grape", "pear"};
string separator = ", ";
string result = String.Join(separator, value, 1, 2);
Console.WriteLine(result);//Produces the following output: "orange, grape"
//=========================
//using $
var str1 = "text1";
var str2 = " ";
var str3 = "text3";
string result2 = $"{str1}{str2}{str3}"; //"text1 text3"
//=====================
StringBuilder sb = new StringBuilder();
for (int i = 1; i <= 5; i++)
{
sb.Append(i);
sb.Append(" ");
}
Console.WriteLine(sb.ToString()); // "1 2 3 4 5 "
Calls to Append() can be daisy chained, because it returns a reference to the StringBuilder:
StringBuilder sb = new StringBuilder();
sb.Append("some string ")
.Append("another string");

StringBuilder sb = new StringBuilder(10000); // initializes the capacity to 10000

//If we know in advance how long our StringBuilder needs to be, we can specify its size ahead of time, which will
//prevent it from needing to resize the character array it has internally.
sb.Append('k', 2000);
//Though using StringBuilder for appending is much faster than a string, it can run even faster if you only need to
//add a single character many times.

</code></pre>
    <b>Interpolated Verbatim Strings</b>
    Verbatim strings can be combined with the new String interpolation features found in C#6.
    <pre><code>
Console.WriteLine($@"Testing \n 1 2 {5 - 2}
New line");
//Output:
//Testing \n 1 2 3
//New line
</code></pre>
  As expected from a verbatim string, the backslashes are ignored as escape characters.
  And as expected from an interpolated string, any expression inside curly braces is evaluated
  before being inserted into the string at that position
  <b>Escaping </b>
  <pre><code>
//Double Quotes:
//Double Quotes inside verbatim strings can be escaped by using 2 sequential double quotes "" to represent one
//double quote " in the resulting string.  
var str = @"""I don't think so,"" he said.";
Console.WriteLine(str);
//Output:
//"I don't think so," he said. 

Backslash
// The filename will be c:\myfile.txt in both cases
string filename = "c:\\myfile.txt";
string filename = @"c:\myfile.txt";

Quotes
string text = "\"Hello World!\", said the quick brown fox.";         //"Hello World!", said the quick brown fox.
string verbatimText = @"""Hello World!"", said the quick brown fox.";//"Hello World!", said the quick brown fox.

Newlines
Verbatim string literals can contain newlines:
string text = "Hello\r\nWorld!";
string verbatimText = @"Hello
World!";

//Unicode character escape sequences
string sqrt = "\\u221A"; // √
string emoji = "\\U0001F601"; // ?
string text = "\\u0022Hello World\\u0022"; // "Hello World"
string variableWidth = "\\x22Hello World\\x22"; // "Hello World"

//Escaping special symbols in character literals
//Apostrophes
char apostrophe = '\'';

//Backslash
char oneBackslash = '\\';

</code></pre>
    <b>Padding a string to a fixed length</b>
    <pre><code>
 string s = "Foo";
string paddedLeft = s.PadLeft(5); // paddedLeft = " Foo" (pads with spaces by default)
string paddedRight = s.PadRight(6, '+'); // paddedRight = "Foo+++" 
string noPadded = s.PadLeft(2); // noPadded = "Foo" (original string is never shortened)
</code></pre>
    <b>Getting x characters from the right side of a string</b>
    <pre><code>
  public static class StringExtensions
  {
    public static string Left( this string stringparam, int numchars )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (numchars > stringparam.Length)
        numchars = stringparam.Length;
      return stringparam.Substring( 0, numchars );
    }
    public static string Right( this string stringparam, int numchars )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (numchars > stringparam.Length)
        numchars = stringparam.Length;
      return stringparam.Substring( stringparam.Length - numchars );
    }
  
    public static string Mid( this string stringparam, int startindex )
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative startindex being passed
      startindex = Math.Abs( startindex );
      // Validate numchars parameter
      if (startindex > stringparam.Length)
        startindex = stringparam.Length;
      // C# strings are zero-based, convert passed startindex
      return stringparam.Substring( startindex - 1 );
    }
    
    public static string Mid( this string stringparam, int startindex, int numchars)
    {
      // Handle possible Null or numeric stringparam being passed
      stringparam += string.Empty;
      // Handle possible negative startindex being passed
      startindex = Math.Abs( startindex );
      // Handle possible negative numchars being passed
      numchars = Math.Abs( numchars );
      // Validate numchars parameter
      if (startindex > stringparam.Length)
        startindex = stringparam.Length;
      // C# strings are zero-based, convert passed startindex
      return stringparam.Substring( startindex - 1, numchars );
      }
  }
  //This extension method can be used as follows:
  //string myLongString = "Hello World!";
  //string myShortString = myLongString.Right(6); // "World!"
  //string myLeftString = myLongString.Left(5); // "Hello"
  //string myMidString1 = myLongString.Left(4); // "lo World"
  //string myMidString2 = myLongString.Left(2,3); // "ell"
</code></pre>
    <b>Checking for empty String using String.IsNullOrEmpty() and String.IsNullOrWhiteSpace()</b>
    <pre><code>
  string nullString = null;
  string emptyString = "";
  string whitespaceString = " ";
  string tabString = "\t";
  string newlineString = "\n";
  string nonEmptyString = "abc123";
  bool result;
result = String.IsNullOrEmpty(nullString); // true
result = String.IsNullOrEmpty(emptyString); // true
result = String.IsNullOrEmpty(whitespaceString); // false
result = String.IsNullOrEmpty(tabString); // false
result = String.IsNullOrEmpty(newlineString); // false
result = String.IsNullOrEmpty(nonEmptyString); // false
result = String.IsNullOrWhiteSpace(nullString); // true
result = String.IsNullOrWhiteSpace(emptyString); // true
result = String.IsNullOrWhiteSpace(tabString); // true
result = String.IsNullOrWhiteSpace(newlineString); // true
result = String.IsNullOrWhiteSpace(whitespaceString); // true
result = String.IsNullOrWhiteSpace(nonEmptyString); // false
</code></pre>
    <b>Trimming Unwanted Characters</b>
    <pre><code>
  String.Trim()
  string x = " Hello World! ";
  string y = x.Trim(); // "Hello World!"
  string q = "{(Hi!*";
  string r = q.Trim( '(', '*', '{' ); // "Hi!"
  String.TrimStart() and String.TrimEnd()
  string q = "{(Hi*";
  string r = q.TrimStart( '{' ); // "(Hi*"
  string s = q.TrimEnd( '*' ); // "{(Hi"
</code></pre>
    <b>Convert Decimal Number to Binary,Octal and Hexadecimal Format</b>
    <pre><code>
 // 1. To convert decimal number to binary format use base 2
  Int32 Number = 15;
  Console.WriteLine(Convert.ToString(Number, 2)); //OUTPUT : 1111
 // 2. To convert decimal number to octal format use base 8
  int Number = 15;
  Console.WriteLine(Convert.ToString(Number, 8)); //OUTPUT : 17
//  3. To convert decimal number to hexadecimal format use base 16
  var Number = 15;
  Console.WriteLine(Convert.ToString(Number, 16)); //OUTPUT : f 
</code></pre>
    <b>Construct a string from Array</b>
    <pre><code>
  string delimiter=",";
  char[] charArray = new[] { 'a', 'b', 'c' };
  string inputString = String.Join(delimiter, charArray);
 // Output : a,b,c if we change the delimiter as "" then the output will become abc.

String from List of char:
string delimiter = "|";
List<char> charList = new List<char>() { 'a', 'b', 'c' };
string inputString = String.Join(delimiter, charList);
//Output : a|b|c

String from List of Strings:
string delimiter = " ";
List<string> stringList = new List<string>() { "Ram", "is", "a","boy" };
string inputString = String.Join(delimiter, stringList);
//Output : Ram is a boy

String from array of strings:
string delimiter = "_";
string[] stringArray = new [] { "Ram", "is", "a","boy" };
string inputString = String.Join(delimiter, stringArray);
//Output : Ram_is_a_boy
</code></pre>
    <b>Finding a string within a string</b>
    <pre><code>
  string s = "Hello World";
  bool stringExists = s.Contains("ello"); //stringExists =true as the string contains the substring 
  int location = s.IndexOf("ello"); // location = 1
  int location = s.LastIndexOf("l"); // location = 9
</code></pre>
</div>

<h2>Operators</h2>
<div>

  <b>Implicit Cast and Explicit Cast Operators</b>
  C# allows user-defined types to control assignment and casting through the use of <strong>the explicit and
    implicit</strong> keywords.
  The signature of the method takes the form:
  <cl>public static < implicit/explicit> operator < ResultingType>(< SourceType> myType)</cl>
  The method cannot take any more arguments, nor can it be an instance method. It can, however, access any private
  members of type it is defined within.
  An example of both an implicit and explicit cast:
  <pre><code>
public class BinaryImage
{
private bool[] _pixels;
public static implicit operator ColorImage(BinaryImage im)
{
  return new ColorImage(im);
}
public static explicit operator bool[](BinaryImage im)
{
  return im._pixels;
}
}
</code></pre>
  Allowing the following cast syntax:
  <pre><code>
var binaryImage = new BinaryImage();
ColorImage colorImage = binaryImage; // implicit cast, note the lack of type
bool[] pixels = (bool[])binaryImage; // explicit cast, defining the type
</code></pre>
  The cast operators can work both ways, going from your type and going to your type:
  <pre><code>
public class BinaryImage
{
public static explicit operator ColorImage(BinaryImage im)
{
 return new ColorImage(im);
}
GoalKicker.com – C# Notes for Professionals 25
public static explicit operator BinaryImage(ColorImage cm)
{
  return new BinaryImage(cm);
}
}
</code></pre>
  Finally, the as keyword, which can be involved in casting within a type hierarchy, is not valid in this situation.
  Even
  after defining either an explicit or implicit cast, you cannot do:
  <cl>ColorImage cm = myBinaryImage as ColorImage;</cl>
  It will generate a compilation error.

  <b>Ternary Operator</b>
  Returns one of two values depending on the value of a Boolean expression.
  Syntax:
  <cl>condition ? expression_if_true : expression_if_false;</cl>
  Example:
  <pre><code>
string name = "Frank";
Console.WriteLine(name == "Frank" ? "The name is Frank" : "The name is not Frank");  
//=====================================
//Example 2:
light.intensity = Clamp(light.intensity, minLight, maxLight);
public static float Clamp(float val, float min, float max)
{
return (val < min) ? min : (val > max) ? max : val;
}
</code></pre>
  Ternary operators can also be nested, such as:
  <pre><code>a ? b ? "a is true, b is true" : "a is true, b is false" : "a is false"
// This is evaluated from left to right and can be more easily seen with parenthesis:
a ? (b ? x : y) : z
// Where the result is x if a && b, y if a && !b, and z if !a
</code></pre>

  <b>var vs dynamic</b>
  <pre><code>
// var says, “let the compiler figure out the type”.
// dynamic says, “let the runtime figure out the type”.

dynamic x = "hello";  // Static type is dynamic, runtime type is string
var y = "hello";      // Static type is string, runtime type is string
int i = x;            // Run-time error
int j = y;            // Compile-time error
</code></pre>

  <b>Overloadable Operators</b>
  <b>Operator Overloading </b>
  An operator is overloaded by declaring an operator function:
  <code><pre>
//Example1 :
Note B = new Note (2);
Note CSharp = B + 2;
CSharp.SemitonesFromA.Dump();

CSharp += 2;
CSharp.SemitonesFromA.Dump();

public struct Note
{
int value;
public int SemitonesFromA => value;

public Note (int semitonesFromA) { value = semitonesFromA; }

public static Note operator + (Note x, int semitones)
{
  return new Note (x.value + semitones);
}
}

//Example 2:
public struct Complex
{
  public double Real { get; set; }
  public double Imaginary { get; set; }
}
public static Complex operator +(Complex c1, Complex c2)
{
  return new Complex
  {
    Real = c1.Real + c2.Real,
    Imaginary = c1.Imaginary + c2.Imaginary
  };
}
///=============================
//Example 3:
public static class Polar
{
  public static bool operator is(Cartesian c, out double R, out double Theta)
  {
    R = Math.Sqrt(c.X*c.X + c.Y*c.Y);
    Theta = Math.Atan2(c.Y, c.X);
    return c.X != 0 || c.Y != 0;
  }
}
//================================
//Example 4:
class Student : IEquatable< Student>
{
  public string Name { get; set; } = "";
  public bool Equals(Student other)
  {
    if (ReferenceEquals(other, null)) return false;
    if (ReferenceEquals(other, this)) return true;
    return string.Equals(Name, other.Name);
  }
  public override bool Equals(object obj)
  {
    if (ReferenceEquals(null, obj)) return false;
    if (ReferenceEquals(this, obj)) return true;
    return Equals(obj as Student);
  }
  public override int GetHashCode()
  {
    return Name?.GetHashCode() ?? 0;
  }
  public static bool operator ==(Student left, Student right)
  {
    return Equals(left, right);
  }
  public static bool operator !=(Student left, Student right)
  {
    return !Equals(left, right);
  }
}
</code></pre>
  <b>explicit operator</b>
  <pre><code>
internal class Explicit
{
  public static explicit operator int (Explicit a)
  {
      return 5;
  }
}

internal class Implicit
{
  public static implicit operator int(Implicit a)
  {
      return 5;
  }
}
//and two objects:

var obj1 = new Explicit();
var obj2 = new Implicit();

//you can now write:

int integer = obj2; // implicit conversion - you don't have to use (int)
//or:
int integer = (int)obj1; // explicit conversion
//but:
int integer = obj1; // WON'T WORK - explicit cast required
</code></pre>
  <b>Short-circuiting Operators</b>
  The short-circuiting boolean operators will only evaluate the second operand if
  the first operand can not determine the overall result of the expression.

  It means that, if you are using && operator as firstCondition && secondCondition
  it will evaluate secondCondition only when firstCondition is true
  and ofcource the overall result will be true only if both of firstOperand
  and secondOperand are evaluated to true.
  This is useful in many scenarios, for example imagine that you want to check whereas your
  list has more than three elements but you also have to check if list has been initialized to not run into
  NullReferenceException. You can achieve this as below:
  <pre><code>
bool hasMoreThanThreeElements = myList != null && mList.Count > 3;
mList.Count > 3 will not be checked untill myList != null is met.
</code></pre>
  <strong>Logical AND</strong>
  && is the short-circuiting counterpart of the standard boolean AND (&) operator.
  <pre><code>
var x = true;
var y = false;
x && x // Returns true.
x && y // Returns false (y is evaluated).
y && x // Returns false (x is not evaluated).
y && y // Returns false (right y is not evaluated).
</code></pre>
  <strong>Logical OR</strong>
  || is the short-circuiting counterpart of the standard boolean OR (|) operator.
  <pre><code>
var x = true;
var y = false;
x || x // Returns true (right x is not evaluated).
x || y // Returns true (y is not evaluated).
y || x // Returns true (x and y are evaluated).
y || y // Returns false (y and y are evaluated).
</code></pre>
  Example usage
  <pre><code>
if(object != null && object.Property)
// object.Property is never accessed if object is null, because of the short circuit.
GoalKicker.com – C# Notes for Professionals 26
Action1();
else
Action2();
</code></pre>
  <b>Indexers</b>
  is a special type of property that to be accessed like an array for its internal collection
  Example:
  <pre><code>
class StringDataStore
{
  private string[] strArr = new string[10]; // internal data storage

  public string this[int index]
  {
      get
      {
          if (index < 0 || index >= strArr.Length)
              throw new IndexOutOfRangeException("Index out of range");

              return strArr[index];
      }

      set
      {
          if (index < 0 ||  index >= strArr.Length)
              throw new IndexOutOfRangeException("Index out of range");

          strArr[index] = value;
      }
  }
}
</code></pre>
  <b>default Operator</b>
  <cl>Value Type (where T : struct)</cl>
  The built-in primitive data types, such as char, int, and float, as well as user-defined types declared with struct,
  or enum. Their default value is new T() :
  <pre><code>
default(int) // 0
default(DateTime) // 0001-01-01 12:00:00 AM
default(char) // '\0' This is the "null character", not a zero or a line break.
default(Guid) // 00000000-0000-0000-0000-000000000000
default(MyStruct) // new MyStruct()
// Note: default of an enum is 0, and not the first *key* in that enum
// so it could potentially fail the Enum.IsDefined test
default(MyEnum) // (MyEnum)0
Reference Type (where T : class)
Any class, interface, array or delegate type. Their default value is null :
default(object) // null
default(string) // null
default(MyClass) // null
default(IDisposable) // null
default(dynamic) // null 
</code></pre>
  <b>sizeof</b>
  Returns an int holding the size of a type* in bytes.
  <pre><code>
sizeof(bool) // Returns 1.
sizeof(byte) // Returns 1.
sizeof(sbyte) // Returns 1.
sizeof(char) // Returns 2.
sizeof(short) // Returns 2.
sizeof(ushort) // Returns 2.
sizeof(int) // Returns 4.
sizeof(uint) // Returns 4.
sizeof(float) // Returns 4.
sizeof(long) // Returns 8.
sizeof(ulong) // Returns 8.
sizeof(double) // Returns 8.
sizeof(decimal) // Returns 16.  
</code></pre>
  <b>Null-Conditional Operator</b>
  Introduced in C# 6.0, the Null Conditional Operator <b>?.</b> will immediately return null
  if the expression on its lefthand side evaluates to null, instead of throwing a NullReferenceException.
  If its left-hand side evaluates to a nonnull value, it is treated just like a normal . operator.
  Note that because it might return null, its return type is always a nullable type.
  That means that for a struct or primitive type, it is wrapped into a <b>Nullable<T>.</b>
  <pre><code>
var bar = Foo.GetBar()?.Value; // will return null if GetBar() returns null
var baz = Foo.GetBar()?.IntegerValue; // baz will be of type Nullable<int>, i.e. int?  
</code></pre>
  This comes handy when firing events.
  Normally you would have to wrap the event call in an if statement checking for null and raise the event afterwards,
  which introduces the possibility of a race condition.
  Using the Null conditional operator this can be fixed in the following way:
  <pre><code> 
event EventHandler<string> RaiseMe;
RaiseMe?.Invoke("Event raised"); 
</code></pre>

  Nullable types also work well with the null-conditional operator
  <pre><code>    
System.Text.StringBuilder sb = null;
int? length = sb?.ToString().Length;
length.Dump();

// We can combine this with the null coalescing operator to evaluate to zero instead of null:

int length2 = sb?.ToString().Length ?? 0;  // Evaluates to 0 if sb is null
length2.Dump();
</code></pre>
  <b>Null-Coalescing Operator</b>
  The Null-Coalescing operator ?? will return the left-hand side when not null.
  If it is null, it will return the right-hand side.

  Parameter Details
  possibleNullObject The value to test for null value. If non null, this value is returned. Must be a nullable type.
  defaultValue The value returned if possibleNullObject is null. Must be the same type as possibleNullObject.
  <pre><code>
object foo = null;
object bar = new object();
var c = foo ?? bar;
//c will be bar since foo was null
The ?? operator can be chained which allows the removal of if checks.
//config will be the first non-null returned.
var config = RetrieveConfigOnMachine() ??
RetrieveConfigFromService() ??
new DefaultConfiguration();
</code></pre>
  <b>Basic usage</b>
  Using the null-coalescing operator (??) allows you to specify a default value for a nullable type if the left-hand
  operand is null.
  <pre><code>
string testString = null;
Console.WriteLine("The specified string is - " + (testString ?? "not provided"));  
</code></pre>
  This is logically equivalent to:
  <pre><code>
string testString = null;
if (testString == null)
{
Console.WriteLine("The specified string is - not provided");
}
else
{
Console.WriteLine("The specified string is - " + testString);
} 
</code></pre>
  or using the ternary operator (?:) operator:
  <pre><code>
string testString = null;
Console.WriteLine("The specified string is - " + (testString == null ? "not provided" :testString));  
</code></pre>
  <b>Null fall-through and chaining</b>
  left-hand operand must be nullable, while the right-hand operand may or may not be.
  The result will be typed accordingly.
  Non-nullable:
  <pre><code>
int? a = null;
int b = 3;
var output = a ?? b;
var type = output.GetType();
Console.WriteLine($"Output Type :{type}");
Console.WriteLine($"Output value :{output}");
//Output:
//Type :System.Int32
//value :3
</code></pre>
  Nullable:
  <pre><code>
int? a = null;
int? b = null;
var output = a ?? b;
//output will be of type int? and equal to b, or null.
</code></pre>
  Multiple Coalescing:
  Coalescing can also be done in chains:
  <pre><code>
int? a = null;
int? b = null;
int c = 3;
var output = a ?? b ?? c;
var type = output.GetType();
Console.WriteLine($"Type :{type}");
Console.WriteLine($"value :{output}");
//Output:
//Type :System.Int32
//value :3
</code></pre>
  <b>Lambda operator</b>
  The => operator has the same precedence as the assignment operator = and is right-associative.
  It is used to declare lambda expressions and also it is widely used with LINQ Queries:
  <pre><code>
string[] words = { "cherry", "apple", "blueberry" };
int shortestWordLength = words.Min((string w) => w.Length); //5
</code></pre>

  When used in LINQ extensions or queries the type of the objects can usually be skipped as it is inferred by the
  compiler:
  <pre><code>
int shortestWordLength = words.Min(w => w.Length); //also compiles with the same result  
</code></pre>
  The general form of lambda operator is the following:
  <cl>(input parameters) => expression</cl>
  The parameters of the lambda expression are specified before => operator,
  and the actual expression/statement/block to be executed is to the right of the operator:
  <pre><code>
// expression
(int x, string s) => s.Length > x
// expression
(int x, int y) => x + y
// statement
(string x) => Console.WriteLine(x)
// block
(string x) => {
x += " says Hello!";
Console.WriteLine(x);
}</code></pre>
  This operator can be used to easily define delegates, without writing an explicit method:
  <pre><code>
delegate void TestDelegate(string s);
TestDelegate myDelegate = s => Console.WriteLine(s + " World");
myDelegate("Hello");
instead of
void MyMethod(string s)
{
Console.WriteLine(s + " World");
}
delegate void TestDelegate(string s);
TestDelegate myDelegate = MyMethod;
myDelegate("Hello");
</code></pre>
  <b>Null coalescing operator with method calls</b>
  The null coalescing operator makes it easy to ensure that a method that may return null will fall back to a default
  value.
  Without the null coalescing operator:
  <pre><code>
string name = GetName();
if (name == null)
name = "Unknown!";
</code></pre>
  With the null coalescing operator:
  <cl>string name = GetName() ?? "Unknown!";</cl>

  <b>Class Member Operators: Null Conditional Member Access</b>
  <pre><code>
var zipcode = myEmployee?.Address?.ZipCode;
//returns null if the left operand is null.
//the above is the equivalent of:
var zipcode = (string)null;
if (myEmployee != null && myEmployee.Address != null)
zipcode = myEmployee.Address.ZipCode;
</code></pre>
  <b> Use existing or create new</b>
  A common usage scenario that this feature really helps with is when you are looking for an object in a collection
  and need to create a new one if it does not already exist.
  <pre><code>
IEnumerable<MyClass> myList = GetMyList();
var item = myList.SingleOrDefault(x => x.Id == 2) ?? new MyClass { Id = 2 }; 
</code></pre>
  <b>Lazy properties initialization with null coalescing operator</b>
  <pre><code>
private List<FooBar> _fooBars;
  public List<FooBar> FooBars
  {
  get { return _fooBars ?? (_fooBars = new List<FooBar>()); }
  }
</code></pre>
  The first time the property .FooBars is accessed the _fooBars variable will evaluate as null,
  thus falling through to the assignment statement assigns and evaluates to the resulting value.
  <strong>Thread safety</strong>
  This is not thread-safe way of implementing lazy properties.
  For thread-safe laziness, use the Lazy<T> class built into the .NET Framework.
    <strong>C# 6 Syntactic Sugar using expression bodies</strong>
    Note that since C# 6, this syntax can be simplified using expression body for the property:
    <pre><code>
private List<FooBar> _fooBars;
public List<FooBar> FooBars => _fooBars ?? ( _fooBars = new List<FooBar>() );
// Subsequent accesses to the property will yield the value stored in the _fooBars variable.
</code></pre>
    <b>Example in the MVVM pattern</b>
    This is often used when implementing commands in the MVVM pattern. Instead of initializing the commands
    eagerly with the construction of a viewmodel, commands are lazily initialized using this pattern as follows:
    <pre><code>
private ICommand _actionCommand = null;
public ICommand ActionCommand =>
_actionCommand ?? ( _actionCommand = new DelegateCommand( DoAction ) ); 
</code></pre>

    <b>Class Member Operators: Null Conditional Indexing</b>
    The ?. operator is syntactic sugar to avoid verbose null checks. It's also known as the Safe navigation operator.
    <pre><code>
//Example 1:
public class Person
{
public int Age { get; set; }
public string Name { get; set; }
public Person Spouse { get; set; }
}
//If an object is potentially null (such as a function that returns a reference type) 
//the object must first be checked for null to prevent a possible NullReferenceException. 
//Without the null-conditional operator, this would look like:
Person person = GetPerson();
int? age = null;
if (person != null)
age = person.Age;

//The same example using the null-conditional operator:
Person person = GetPerson();
var age = person?.Age; // 'age' will be of type 'int?', even if 'person' is not null

//Example 2:

var letters = null;
char? letter = letters?[1];
Console.WriteLine("Second Letter is {0}",letter);
//in the above example rather than throwing an error because letters is null
//letter is assigned the value null  

//Chaining the Operator:
//The null-conditional operator can be combined on the members and sub-members of an object.
// Will be null if either `person` or `person.Spouse` are null
int? spouseAge = person?.Spouse?.Age;

// Combining with the Null-Coalescing Operator
// The null-conditional operator can be combined with the null-coalescing operator to provide a default value:
// spouseDisplayName will be "N/A" if person, Spouse, or Name is null
var spouseDisplayName = person?.Spouse?.Name ?? "N/A";
</code></pre>
    <b>The Null-Conditional Index</b>
    <pre><code>
// Similarly to the ?. operator, the null-conditional index operator checks for null values
// when indexing into a collection that may be null.
string item = collection?[index];
is syntactic sugar for
string item = null;
if(collection != null)
{
item = collection[index];
}
</code></pre>
    <b>Avoiding NullReferenceExceptions</b>
    <pre><code>
var person = new Person
{
Address = null;
};
var city = person.Address.City; //throws a NullReferenceException
var nullableCity = person.Address?.City; //returns the value of null
This effect can be chained together:
var person = new Person
{
  Address = new Address
  {
    State = new State
      {
        Country = null
    }
  }
};
// this will always return a value of at least "null" to be stored instead
// of throwing a NullReferenceException
var countryName = person?.Address?.State?.Country?.Name;
</code></pre>
    <b>Null-conditional Operator can be used with Extension Method</b>
    Extension Method can work on null references, but you can use ?. to null-check anyway.
    <pre><code>
public class Person
{
  public string Name {get; set;}
}
public static class PersonExtensions
{
  public static int GetNameLength(this Person person)
  {
    return person == null ? -1 : person.Name.Length;
  }
}
//Normally, the method will be triggered for null references, and return -1:
Person person = null;
int nameLength = person.GetNameLength(); // returns -1
</code></pre>
    Using ?. the method will not be triggered for null references, and the type is int?:


    <b>typeof</b>
    Gets System.Type object for a type.
    <pre><code class="csharp">
System.Type type = typeof(Point); //System.Drawing.Point
System.Type type = typeof(IDisposable); //System.IDisposable
System.Type type = typeof(Colors); //System.Drawing.Color
System.Type type = typeof(List<>); //System.Collections.Generic.List`1[T]
</code></pre>
    To get the run-time type, use GetType method to obtain the System.Type of the current instance.
    Operator typeof takes a type name as parameter, which is specified at compile time.
    <pre><code>
public class Animal {}
public class Dog : Animal {}
var animal = new Dog();
Assert.IsTrue(animal.GetType() == typeof(Animal)); // fail, animal is typeof(Dog)
Assert.IsTrue(animal.GetType() == typeof(Dog)); // pass, animal is typeof(Dog)
Assert.IsTrue(animal is Animal); // pass, animal implements Animal
</code></pre>
    <b>nameof Operator</b>
    Returns a string that represents the unqualified name of a variable, type, or member.
    <pre><code>
int counter = 10;
nameof(counter); // Returns "counter"
Client client = new Client();  
nameof(client.Address.PostalCode)); // Returns "PostalCode"
The nameof operator was introduced in C# 6.0. 
It is evaluated at compile-time and the returned string value is inserted inline by the compiler,
so it can be used in most cases where the constant string can be used 
(e.g., the case labels in a switch statement, attributes, etc...). 
It can be useful in cases like raising & logging exceptions, attributes, MVC Action links, etc...
//=================================
// Raising PropertyChanged event

<pre><code>
public class Person : INotifyPropertyChanged
{
  private string _address;
  public event PropertyChangedEventHandler PropertyChanged;
  private void OnPropertyChanged(string propertyName)
  {
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
  }
  public string Address
  {
    get { return _address; }
    set
    {
      if (_address == value)
      {
        return;
      }
      _address = value;
      OnPropertyChanged(nameof(Address));
    }
  }
}
...
var person = new Person();
person.PropertyChanged += (s,e) => Console.WriteLine(e.PropertyName);
person.Address = "123 Fake Street";
//Console Output
//Address

//===============================================
//Argument Checking and Guard Clauses

//Prefer
if (orderLine == null) throw new ArgumentNullException(nameof(orderLine));

//Over
if (orderLine == null) throw new ArgumentNullException("orderLine");
//================================================
//Applied to a generic type parameter

public class SomeClass<TItem>
{
  public void PrintTypeName()
  {
    Console.WriteLine(nameof(TItem));
  }
}
</code></pre>

    </code></pre>
    <b>Class Member Operators: Aggregate Object Indexing</b>
    <pre><code>
var letters = "letters".ToCharArray();
char letter = letters[1];
Console.WriteLine("Second Letter is {0}",letter);
//in the above example we take the second character from the array
//by calling letters[1]
//NB: Array Indexing starts at 0; i.e. the first letter would be given by letters[0].
</code></pre>
</div>
<h2>GetHashCode</h2>
<div>
  <b>Writing a good GetHashCode override</b>
  GetHashCode has major performance effects on Dictionary<> and HashTable.
    Good GetHashCode Methods
    should have an even distribution
    every integer should have a roughly equal chance of returning for a random instance
    if your method returns the same integer (e.g. the constant '999') for each instance, you'll have bad
    performance
    should be quick
    These are NOT cryptographic hashes, where slowness is a feature
    the slower your hash function, the slower your dictionary
    must return the same HashCode on two instances that Equals evaluates to true
    if they do not (e.g. because GetHashCode returns a random number),
    items may not be found in a List,Dictionary, or similar.
    A good method to implement GetHashCode is to use one prime number as a starting value, and add the hashcodes
    of the fields of the type multiplied by other prime numbers to that:
    <pre><code>
public override int GetHashCode()
{
unchecked // Overflow is fine, just wrap
{
int hash = 3049; // Start value (prime number).
// Suitable nullity checks etc, of course :)
hash = hash * 5039 + field1.GetHashCode();
hash = hash * 883 + field2.GetHashCode();
hash = hash * 9719 + field3.GetHashCode();
return hash;
}
}</code></pre>
Only the fields which are used in the Equals-method should be used for the hash function.
If you have a need to treat the same type in different ways for Dictionary/HashTables, you can use
IEqualityComparer.

<b>Override Equals and GetHashCode on custom types</b>
For a class Person like:
<pre><code>
public class Person
{
public string Name { get; set; }
public int Age { get; set; }
public string Clothes { get; set; }
}
var person1 = new Person { Name = "Jon", Age = 20, Clothes = "some clothes" };
var person2 = new Person { Name = "Jon", Age = 20, Clothes = "some other clothes" };
bool result = person1.Equals(person2); //false because it's reference Equals
But defining Equals and GetHashCode as follows:
public class Person
{
public string Name { get; set; }
GoalKicker.com – C# Notes for Professionals 39
public int Age { get; set; }
public string Clothes { get; set; }
public override bool Equals(object obj)
{
  var person = obj as Person;
  if(person == null) return false;
  return Name == person.Name && Age == person.Age; //the clothes are not important when comparing two persons
  }
  public override int GetHashCode()
  {
    return Name.GetHashCode()*Age;
  }
}
var person1 = new Person { Name = "Jon", Age = 20, Clothes = "some clothes" };
var person2 = new Person { Name = "Jon", Age = 20, Clothes = "some other clothes" };
bool result = person1.Equals(person2); // result is true
Also using LINQ to make different queries on persons will check both Equals and GetHashCode:
var persons = new List<Person>
{
  new Person{ Name = "Jon", Age = 20, Clothes = "some clothes"},
  new Person{ Name = "Dave", Age = 20, Clothes = "some other clothes"},
  new Person{ Name = "Jon", Age = 20, Clothes = ""}
};
var distinctPersons = persons.Distinct().ToList();//distinctPersons has Count = 2

</code></pre>

    <b>Equals and GetHashCode in IEqualityComparator</b>
    For given type Person:
    <pre><code>
public class Person
{
  public string Name { get; set; }
  public int Age { get; set; }
  public string Clothes { get; set; }
}
List<Person> persons = new List<Person>
{
  new Person{ Name = "Jon", Age = 20, Clothes = "some clothes"},
  new Person{ Name = "Dave", Age = 20, Clothes = "some other clothes"},
  new Person{ Name = "Jon", Age = 20, Clothes = ""}
};
var distinctPersons = persons.Distinct().ToList();// distinctPersons has Count = 3
But defining Equals and GetHashCode into an IEqualityComparator :
public class PersonComparator : IEqualityComparer<Person>
{
public bool Equals(Person x, Person y)
{
  return x.Name == y.Name && x.Age == y.Age; //the clothes are not important when comparing
  two persons;
}
public int GetHashCode(Person obj) { return obj.Name.GetHashCode() * obj.Age; }
}
var distinctPersons = persons.Distinct(new PersonComparator()).ToList();// distinctPersons has Count = 2
</code></pre>
    Note that for this query, two objects have been considered equal if both the Equals returned true and the
    GetHashCode have returned the same hash code for the two persons.


</div>
<h2>Generics</h2>
<div>
  means not specific to a particular data type.
  Example :
  The DataStore is a generic class:
  <pre><code>
  class DataStore< T>
  {
    public T Data { get; set; } //generic field of the generic class
    public T GetData(int index) { ...} //generic method (which returns generic class).
                       //(generic methods can also be defined in a none-generic class)
  }
  </code></pre>
  T is called type parameter, which can be used as
  a type of fields, properties, method parameters, return types,and delegates in <strong> the DataStore class</strong>.
  <b> Instanciation:</b>
     You can create an instance of generic classes by specifying an actual type in angle brackets:
  <cl> DataStore<string> store = new DataStore<string>();</cl>
<b> C# Generic Constraints</b>
  You can use constraints to restrict the type to certain types while instantiating generic types.
  It will give a compile - time error if you try to instantiate a generic type using a type that is not allowed by
    the specified constraints.
  
  There are six types of constraints:

  where T: struct -Type argument must be a value type
  where T: class -Type argument must be a reference type
  where T: new() - Type argument must have a public parameterless constructor.
  where T :
  < base class> -Type argument must inherit from
  < base class> class.
  where T: < interface> -Type argument must implement from< interface> interface.
  where T: U - There are two type arguments T and U.T must be inherit from U.


  <a href='https://www.tutorialsteacher.com/csharp/constraints-in-generic-csharp'>more..</a>
  <b>multicast delegates</b>
  multicasting is the ability to create an invocation list, or chain, of methods that
  will be automatically called when a delegate is invoked.
  A delegate instance can reference not just a single target method, but also a list of target methods.
  As a result, one delegate instance can call many methods.It is called multicast.
  All delegate instances have multicast capability.

  Example:
  <pre><code>
  // All delegate instances have multicast capability:

  SomeDelegate d = SomeMethod1;
  d += SomeMethod2;

  d();
  " -- SomeMethod1 and SomeMethod2 both fired\r\n".Dump();

  d -= SomeMethod1;
  d();
  " -- Only SomeMethod2 fired".Dump();

  void SomeMethod1() => "SomeMethod1".Dump();
  void SomeMethod2() => "SomeMethod2".Dump();

  delegate void SomeDelegate();
  </code></pre>
</div>
<h2>Access modifiers</h2>
<div>
 <pre><code>
class Class1 {}         // Class1 is <b>internal</b> (default) - visible to other types in same assembly
public class Class2 {}  // Class2 is visible to everything, including types in other assemblies

class ClassA
{
  int x;               // x is private <b>(default)</b> - cannot be accessed from other types
}

class ClassB
{
  internal int x;    // x can be accessed from other types in same assembly
}

class BaseClass
{
  void Foo()           {}    // Foo is private (default)
  protected void Bar() {}    // <b>protected</b> is accessible to subclasses
}

class Subclass : BaseClass
{
   void Test1() { Foo(); }     // Error - cannot access Foo
   void Test2() { Bar(); }     // OK
}
Friend Assemblies

// Unsigned friend:
//    [assembly: InternalsVisibleTo ("Friend")]

// Signed friend:
//    [assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]

// To obtain an assembly's public key, hit F5 to run the following code:

using (var dialog = new OpenFileDialog())
{
  dialog.Title = "Locate assembly";
  dialog.Filter = "Assembly files|*.dll;*.exe";
  dialog.DefaultExt = ".dll";
  
  if (dialog.ShowDialog() != DialogResult.OK) return;
  if (!File.Exists (dialog.FileName)) return;
  
  var aName = Assembly.LoadFile (dialog.FileName).GetName();

  string key = string.Join ("", 
    aName.GetPublicKey().Select (b => b.ToString ("x2")).ToArray());
    
  string assemAttrib = "[assembly: InternalsVisibleTo (\"" 
    + aName.Name
    + ", PublicKey=" + key.Dump ("Full Key")
    + "\")]";
    
  assemAttrib.Dump ("Assembly Attribute");
  
  Clipboard.SetText (assemAttrib);
}
</code></pre> 
</div>
<h2>yield return</h2>
<div>
  if you want a collection that you can use "foreach" on, but gathering the items into the collection is
    expensive for some reason
    (like querying them out of a database), AND you will often not need the entire collection,
    then you create a function that builds the collection one item at a time and yields it back to the consumer
    (who can then terminate the collection effort early).

    t first sight, yield return is a .NET sugar to return an IEnumerable.

    Without yield, all the items of the collection are created at once:
    <pre><code>
  class SomeData
  {
      public SomeData() { }

      static public IEnumerable<SomeData> CreateSomeDatas()
      {
          return new List<SomeData> {
              new SomeData(), 
              new SomeData(), 
              new SomeData()
          };
      }
  }
  </code></pre>
 Same code using yield, it returns item by item:
  <pre><code>
    class SomeData
    {
        public SomeData() { }

        static public IEnumerable<SomeData> CreateSomeDatas()
        {
            yield return new SomeData();
            yield return new SomeData();
            yield return new SomeData();
        }
    }
  </code></pre>
  The advantage of using yield is that if the function consuming your data simply needs the first item of the
  collection,
  the rest of the items won't be created.
  The yield operator allows the creation of items as it is demanded. That's a good reason to use it.
  <b>yield break</b>
  <pre><code>
    // The yield break statement indicates that the iterator block should exit early,
    // without returning more elements:

    foreach (string s in Foo (true))
    Console.WriteLine (s);

    static IEnumerable<string> Foo (bool breakEarly)
    {
        yield return "One";
        yield return "Two";

        if (breakEarly)
            yield break;

        yield return "Three";
    }
  </code></pre>
</div>
<h2>yield break</h2>
<div>
  The yield break statement indicates that the iterator block should exit early,
                without returning more elements:
                <pre><code>
  foreach (string s in Foo (true))
    Console.WriteLine (s);

  static IEnumerable<string> Foo (bool breakEarly)
  {
    yield return "One";
    yield return "Two";

    if (breakEarly)
      yield break;

    yield return "Three";
  }
  </code></pre>
<b>Multiple yield Statements</b>
Multiple yield statements are permitted:
<pre><code>
   foreach (string s in Foo())
    Console.WriteLine (s);         // Prints "One","Two","Three"

  IEnumerable<string> Foo()
  {
    yield return "One";
    yield return "Two";
    yield return "Three";
  }
  </code></pre>
Example 2
<pre><code>
      IEnumerable<string> Foo()
      {
          try
          {
          yield return "One";
          yield return "Two";
          yield return "Three";
          }
  </code></pre>
<b>Null</b>
<pre><code>
      int? x = null;
      int y = x ?? 5;
      Console.WriteLine (y);  // 5    
  </code></pre>
<b>Extension Methods</b>
Extension methods allow an existing type to be extended with new methods without altering
the definition of the original type:
<pre><code>
  Console.WriteLine ("Perth".IsCapitalized());
  // Equivalent to:
  Console.WriteLine (StringHelper.IsCapitalized ("Perth"));

  // Interfaces can be extended, too:
  Console.WriteLine ("Seattle".First());   // S

  public static class StringHelper
  {
    public static bool IsCapitalized (this string s)
    {
      if (string.IsNullOrEmpty (s)) return false;
      return char.IsUpper (s [0]);
    }

    public static T First<T> (this IEnumerable<T> sequence)
    {
      foreach (T element in sequence)
        return element;

      throw new InvalidOperationException ("No elements!");
    }
  }
  </code></pre>
</div>
<h2>object oriented </h2>
<div>
  <h3>Inheritence</h3>
  <strong>What is difference between virtual and override in C#?</stong>

    The virtual keyword is used to modify a method, property, indexer, or event declared in the base class
    and allow it to be overridden in the derived class.
    The override keyword is used to extend or modify a virtual/abstract method, property, indexer, or event of
    base class into a derived class.
  
    <b>Polymorphism</b>:
    <pre><code>
    // A variable of type x can refer to an object that subclasses x.
  
      // The Display method below accepts an Asset. This means means we can pass it any subtype:
      Display (new Stock { Name="MSFT", SharesOwned=1000 });
      Display (new House { Name="Mansion", Mortgage=100000 });
  
      void Display (Asset asset)
      {
        Console.WriteLine (asset.Name);
      }
  
      public class Asset
      {
        public string Name;
      }
  
      public class Stock : Asset   // inherits from Asset
      {
       public long SharesOwned;
      }
  
      public class House : Asset   // inherits from Asset
      {
        public decimal Mortgage;
      }
    </code></pre>
                  <b>Reference Conversions - Upcasting</b>
                  <pre><code>
    // An upcast creates a base class reference from a subclass reference:
  
    Stock msft = new Stock();
    Asset a = msft;               // Upcast
  
    // After the upcast, the two variables still references the same Stock object:
  
    Console.WriteLine (a == msft);  // True
  
    public class Asset
    {
      public string Name;
    }
  
    public class Stock : Asset   // inherits from Asset
    {
      public long SharesOwned;
    }
  
    public class House : Asset   // inherits from Asset
    {
      public decimal Mortgage;
    }
    </code></pre>
                  <b>Virtual Function Members</b>
                  <pre><code>
    // A function marked as virtual can be overridden by subclasses wanting to provide a
    // specialized implementation:
  
    House mansion = new House { Name="McMansion", Mortgage=250000 };
    Console.WriteLine (mansion.Liability);      // 250000
  
    public class Asset
    {
      public string Name;
      public virtual decimal Liability => 0;    // Virtual
    }
  
    public class House : Asset
    {
      public decimal Mortgage;
      public override decimal Liability => Mortgage;   // Overridden
    }
  
    public class Stock : Asset
    {
      public long SharesOwned;
      // We won't override Liability here, because the default implementation will do.
    }
    </code></pre>
    <b>Covariant returns</b>

    From C# 9, we can override a method such that it returns a more derived (subclased) type:
    <pre><code>
    House mansion1 = new House { Name = "McMansion", Mortgage = 250000 };
    House mansion2 = mansion1.Clone();

    public class Asset
    {
      public string Name;
      public virtual Asset Clone() => new Asset { Name = Name };
    }

    public class House : Asset
    {
      public decimal Mortgage;
  
      // We can return House when overriding:
      public override House Clone() => new House { Name = Name, Mortgage = Mortgage };
    }
    </code></pre>
    <b>Abstract Classes & Members</b>

    A class declared as abstract can never be instantiated. Instead, only its concrete subclasses
    can be instantiated. Abstract classes are able to define abstract members.
    <pre><code>
    new Stock { SharesOwned = 200, CurrentPrice = 123.45M }.NetValue.Dump();

    public abstract class Asset    // Note abstract keyword
    {
      public abstract decimal NetValue { get; }  // Note empty implementation
    }

    public class Stock : Asset
    {
      public long SharesOwned;
      public decimal CurrentPrice;

      // Override like a virtual method.
      public override decimal NetValue => CurrentPrice * SharesOwned; 
    }
    </pre></code>
    <b>Sealing Functions & Classes</b>
    An overridden function member may seal its implementation with the sealed keyword to prevent it
    from being overridden by further subclasses:
    <pre><code>
    House mansion = new House { Name="McMansion", Mortgage=250000 };
    Console.WriteLine (mansion.Liability);      // 250000

    public class Asset
    {
      public string Name;
      public virtual decimal Liability => 0;    // Virtual
    }

    public class House : Asset
    {
      public decimal Mortgage;
      public sealed override decimal Liability => Mortgage;   // Overridden + sealed
    }

    // You can also seal the class itself, implicitly sealing all the virtual functions:

    public sealed class Stock : Asset { /* ... */ }
    </code></pre>

    <b>Overloading and Resolution</b>
    When calling an overload method, the method with the most specific
    parameter type match has precedence, based on the *compile-time* variable type:
    <pre><code>
    void Main()
    {
      Foo (new House());      // Calls Foo (House)
  
      Asset a = new House();
      Foo (a);                // Calls Foo (Asset)
    }

    static void Foo (Asset a) { "Foo Asset".Dump(); }
    static void Foo (House h) { "Foo House".Dump(); }

    public class Asset
    {
      public string Name;
    }

    public class Stock : Asset   // inherits from Asset
    {
      public long SharesOwned;
    }

    public class House : Asset   // inherits from Asset
    {
      public decimal Mortgage;
    }
    </code></pre>  
  </div>
<h2>Boxing & Unboxing</h2>
  <div>
   Boxing is the act of casting a value-type instance to a reference-type instance; unboxing is the reverse.
  <pre><code>
    int x = 9;
    object obj = x;           // Box the int
    int y = (int)obj;         // Unbox the int    
 </code></pre>  
  </div>
<h2>DateTime</h2>
  <div>
    <h3>Format DateTime</h3>
    <pre><code>
      //Create datetime
      DateTime dt = new DateTime(2016,08,01,18,50,23,230);
      var t = String.Format("{0:t}", dt); // "6:50 PM"                ShortTime
      var d = String.Format("{0:d}", dt); // "8/1/2016"               ShortDate
      var T = String.Format("{0:T}", dt); // "6:50:23 PM"             LongTime
      var D = String.Format("{0:D}", dt); // "Monday, August 1, 2016" LongDate
      var f = String.Format("{0:f}", dt); // "Monday, August 1, 2016 6:50 PM" LongDate+ShortTime
      var F = String.Format("{0:F}", dt); // "Monday, August 1, 2016 6:50:23 PM" FullDateTime
      var g = String.Format("{0:g}", dt); // "8/1/2016 6:50 PM"       ShortDate+ShortTime
      var G = String.Format("{0:G}", dt); // "8/1/2016 6:50:23 PM"    ShortDate+LongTime
      var m = String.Format("{0:m}", dt); // "August 1"               MonthDay
      var y = String.Format("{0:y}", dt); // "August 2016"            YearMonth
      var r = String.Format("{0:r}", dt); // "SMon, 01 Aug 2016 18:50:23 GMT" RFC1123
      var s = String.Format("{0:s}", dt); // "2016-08-01T18:50:23"    SortableDateTime
      var u = String.Format("{0:u}", dt); // "2016-08-01 18:50:23Z"   UniversalSortableDateTime
    </code></pre>
    <h3>Custom DateTime Formatting </h3>
    There are following custom format specifiers:
    y (year)
    M (month)
    d (day)
    h (hour 12)
    H (hour 24)
    m (minute)
    s (second)
    f (second fraction)
    F (second fraction, trailing zeroes are trimmed)
    t (P.M or A.M)
    z (time zone).
    <pre><code>
  var year = String.Format("{0:y yy yyy yyyy}", dt); // "16 16 2016 2016" year
  var month = String.Format("{0:M MM MMM MMMM}", dt); // "8 08 Aug August" month
  var day = String.Format("{0:d dd ddd dddd}", dt); // "1 01 Mon Monday" day
  var hour = String.Format("{0:h hh H HH}", dt); // "6 06 18 18" hour 12/24
  var minute = String.Format("{0:m mm}", dt); // "50 50" minute
  var secound = String.Format("{0:s ss}", dt); // "23 23" second
  var fraction = String.Format("{0:f ff fff ffff}", dt); // "2 23 230 2300" sec.fraction
  var fraction2 = String.Format("{0:F FF FFF FFFF}", dt); // "2 23 23 23" without zeroes
  var period = String.Format("{0:t tt}", dt); // "P PM" A.M. or P.M.
  var zone = String.Format("{0:z zz zzz}", dt); // "+0 +00 +00:00" time zone
 // You can use also date separator / (slash) and time sepatator : (colon)
</code></pre>
    <h3>AddDays(Double)</h3>
    <pre><code>
DateTime.AddDays(Double)
Add days into a dateTime object.
DateTime today = DateTime.Now;
DateTime answer = today.AddDays(36);
Console.WriteLine("Today: {0:dddd}", today);
Console.WriteLine("36 days from today: {0:dddd}", answer);

//You also can subtract days passing a negative value:
DateTime today = DateTime.Now;
DateTime answer = today.AddDays(-3);
Console.WriteLine("Today: {0:dddd}", today);
Console.WriteLine("-3 days from today: {0:dddd}", answer);
</code></pre>
    <h3>AddHours(Double)</h3>
    <pre><code>
// DateTime.AddHours(Double)
double[] hours = {.08333, .16667, .25, .33333, .5, .66667, 1, 2,
29, 30, 31, 90, 365};
DateTime dateValue = new DateTime(2009, 3, 1, 12, 0, 0);
foreach (double hour in hours)
  Console.WriteLine("{0} + {1} hour(s) = {2}", dateValue, hour,dateValue.AddHours(hour));
</code></pre>
    <h3>Parse(String)</h3>
    <pre><code>
// Converts the string representation of a date and time to its DateTime equivalent
var dateTime = DateTime.Parse("14:23 22 Jul 2016");
Console.WriteLine(dateTime.ToString());
</code>
</pre>
    <h3>TryParse(String, DateTime)</h3>
    <pre><code>
  // Converts the specified string representation of a date and time to its DateTime equivalent and
  returns a value that indicates whether the conversion succeeded
  string[] dateTimeStrings = new []{
    "14:23 22 Jul 2016",
    "99:23 2x Jul 2016",
    "22/7/2016 14:23:00"
  };
  foreach(var dateTimeString in dateTimeStrings){
    DateTime dateTime;
    bool wasParsed = DateTime.TryParse(dateTimeString, out dateTime);
    string result = dateTimeString +
    (wasParsed ? $"was parsed to {dateTime}"  : "can't be parsed to DateTime");
    Console.WriteLine(result);
  }
</code></pre>
    <h3>AddMilliseconds(Double)</h3>
    <pre><code>
    string dateFormat = "MM/dd/yyyy hh:mm:ss.fffffff";
    DateTime date1 = new DateTime(2010, 9, 8, 16, 0, 0);
    Console.WriteLine("Original date: {0} ({1:N0} ticks)\n",
    date1.ToString(dateFormat), date1.Ticks);

    DateTime date2 = date1.AddMilliseconds(1);
    Console.WriteLine("Second date: {0} ({1:N0} ticks)",
    date2.ToString(dateFormat), date2.Ticks);
    Console.WriteLine("Difference between dates: {0} ({1:N0} ticks)\n",
    date2 - date1, date2.Ticks - date1.Ticks);

    DateTime date3 = date1.AddMilliseconds(1.5);
    Console.WriteLine("Third date: {0} ({1:N0} ticks)",
    date3.ToString(dateFormat), date3.Ticks);
    Console.WriteLine("Difference between dates: {0} ({1:N0} ticks)",
    date3 - date1, date3.Ticks - date1.Ticks);
   </code></pre>
    <h3>Compare(DateTime t1, DateTime t2 )</h3>
    <pre><code>  
    DateTime date1 = new DateTime(2009, 8, 1, 0, 0, 0);
    DateTime date2 = new DateTime(2009, 8, 1, 12, 0, 0);
    int result = DateTime.Compare(date1, date2);
    string relationship;
    if (result < 0) 
      relationship="is earlier than" ; 
    else if (result==0) 
      relationship="is the same time as" ;
    else
      relationship="is later than" ;
    Console.WriteLine("{0} {1} {2}", date1, relationship, date2); 
    </code></pre>
    <h3>DaysInMonth(Int32, Int32)</h3>
    <pre><code>      
   const int July=7; 
   const int Feb=2; 

   int  daysInJuly=System.DateTime.DaysInMonth(2001, July); 
   Console.WriteLine(daysInJuly); 
   // daysInFeb gets 28 because the year 1998 was not a leap year. 
   
   int daysInFeb=System.DateTime.DaysInMonth(1998, Feb);
  Console.WriteLine(daysInFeb); 
  // daysInFebLeap gets 29 because the year 1996 was a leap year. 
  int daysInFebLeap=System.DateTime.DaysInMonth(1996, Feb); 
  Console.WriteLine(daysInFebLeap); 
    </code></pre>
    <h3>AddYears(Int32)</h3>
    Add years on the dateTime object
    <pre><code class="csharp">   
    baseDate = new DateTime(2000, 2, 29); 
    Console.WriteLine("Base Date: {0:d}\n", baseDate); 
    // Show dates of previous fifteen years. 
    for (int ctr=-1; ctr>= -15; ctr--)
        Console.WriteLine("{0,2} year(s) ago:{1:d}",Math.Abs(ctr), baseDate.AddYears(ctr));
    Console.WriteLine();    
    
    // Show dates of next fifteen years.
    for (int ctr = 1; ctr <= 15; ctr++) 
      Console.WriteLine("{0,2} year(s) from now: {1:d}", ctr, baseDate.AddYears(ctr));
    </code></pre>
    <h3>Pure functions warning when dealing with DateTime</h3>
    pure function is:
    1. The function always evaluates the same result value given the same argument value(s).
    The function result value cannot depend on any hidden information
    or state that may change while program execution proceeds or between different executions of the program,
    nor can it depend on any external input from I/O devices .

    2.Evaluation of the result does not cause any semantically observable side effect or output,
    such as mutation of mutable objects or output to I/O devices

    As a developer you need to be aware of pure methods and you will stumble upon these a lot in many areas.
    One I have seen that bites many junior developers is working with DateTime class methods.
    A lot of these are pure and if you are unaware of these you can be in for a suprise.
    An example:
    <pre><code>
     DateTime sample=new DateTime(2016, 12, 25); 
     sample.AddDays(1); 
     Console.WriteLine(sample.ToShortDateString()); 
     </code></pre>
    Given the example above one may expect the result printed to console to be '26/12/2016'
    but in reality you end up with the same date.
    This is because AddDays is a pure method and does not affect the original date.
    To get the expected output you would have to modify the AddDays call to the following:
    <cl>sample=sample.AddDays(1);</cl>

    <h3>TryParseExact(String, String, IFormatProvider, D ateTimeStyles, DateTime) </h3>
    - DateTime.Converts the specified string representation of a date and time
    to its DateTime equivalent using the specified format,culture-specific format information, and style.
    - The format of the string representation must match the specified format exactly.
    - The method returns a value that indicates whether the conversion succeeded.
    For Example
    <pre><code>
    CultureInfo enUS=new CultureInfo("en-US"); 
    string dateString; System.DateTime dateValue;
  
    //Parse date with no style flags.

    dateString=" 5/01/2009 8:30 AM" ;
    if (DateTime.TryParseExact(dateString, "g" ,enUS, DateTimeStyles.None, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    } else {
      Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    // Allow a leading space in the date string.
    if(DateTime.TryParseExact(dateString, "g" , enUS,DateTimeStyles.AllowLeadingWhite, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    //Use custom formats with M and MM.
    dateString="5/01/2009 09:00" ;
    if(DateTime.TryParseExact(dateString, "M/dd/yyyy hh:mm" , enUS, DateTimeStyles.None, out dateValue)) {
      Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
      Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    // Allow a leading space in the date
    string. if(DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm" , enUS, DateTimeStyles.None, out dateValue)) {
    Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind); } else {
    Console.WriteLine("'{0}' is not in an acceptable format.", dateString); }

    //Parse a string with time zone information.
    dateString="05/01/2009 01:30:42 PM -05:00" ;
    if(DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm:ss tt zzz" ,
    enUS, DateTimeStyles.None, out dateValue)) {
    Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
    Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    // Allow a leading space in the date string.
    if (DateTime.TryParseExact(dateString, "MM/dd/yyyy hh:mm:ss tt zzz" ,
    enUS, DateTimeStyles.AdjustToUniversal, out dateValue)) {
       Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString, dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }

    Parse a string represengting UTC.
    dateString="2008-06-11T16:11:20.0904778Z" ;
    if(DateTime.TryParseExact(dateString, "o" ,
    CultureInfo.InvariantCulture, DateTimeStyles.None, out dateValue)) {
        Console.WriteLine("Converted '{0}' to {1}({2}).", dateString, dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    if (DateTime.TryParseExact(dateString, "o" , CultureInfo.InvariantCulture,
    DateTimeStyles.RoundtripKind, out dateValue)) {
        Console.WriteLine("Converted '{0}' to {1} ({2}).", dateString,dateValue, dateValue.Kind);
    } else {
       Console.WriteLine("'{0}' is not in an acceptable format.", dateString);
    }
    //Outputs ' 5/01/2009 8:30 AM' is not in an acceptable format.
    Converted ' 5/01/2009 8:30 AM' to 5/1/2009 8:30:00 AM(Unspecified).
    Converted '5/01/2009 09:00' to 5/1/2009 9:00:00 AM (Unspecified).
    '5/01/2009 09:00' is not in an acceptable format.
    Converted '05/01/2009 01:30:42 PM -05:00' to 5/1/2009 11:30:42 AM (Local).
    Converted '05/01/2009 01:30:42 PM -05:00' to 5/1/2009 6:30:42 PM (Utc).
    Converted '2008-06-11T16:11:20.0904778Z' to 6/11/2008 9:11:20 AM (Local).
    Converted '2008-06-11T16:11:20.0904778Z' to 6/11/2008 4:11:20 PM (Utc).
</code></pre>
    <h3>Add(TimeSpan)</h3>
    <pre><code>
    DateTime.Add(TimeSpan)
    // Calculate what day of the week is 36 days from this instant. 
    System.DateTime today=System.DateTime.Now; 
    System.TimeSpan duration=new System.TimeSpan(36, 0, 0, 0);
     System.DateTime answer=today.Add(duration); 
     System.Console.WriteLine("{0:dddd}", answer); 
     </code></pre>
    <h3>Parse and TryParse with culture info</h3>
    You might want to use it when parsing DateTimes from different cultures (languages),
    following example parses Dutch date.
    <pre><code>
  DateTime dateResult; 
    var dutchDateString="31 oktober 1999 04:20" ;
    var dutchCulture=CultureInfo.CreateSpecificCulture("nl-NL");
    DateTime.TryParse(dutchDateString, dutchCulture, styles, out dateResult); // output {31/10/1999 04:20:00} 
      //Example of Parse: 
    DateTime.Parse(dutchDateString, dutchCulture) // output {31/10/1999 04:20:00}  
    </code></pre>
    <h3> DateTime as initializer in for-loop</h3>
    <pre><code>
    // This iterates through a range between two DateTimes 
    // with the given iterator (any of the Add methods)
    
    DateTime start=new DateTime(2016, 01, 01); 
    DateTime until=new DateTime(2016, 02, 01); 
    // NOTICE: As the add methods return a new DateTime you have 
    // to overwrite dt in the iterator like dt=dt.Add() 
    for(DateTime dt=start; dt < until; dt=dt.AddDays(1)) { 
      Console.WriteLine("Added {0} days. Resulting DateTime: {1}", (dt
      - start).Days, dt.ToString()); 
    } 
    //Iterating on a TimeSpan works the same way. 
      
</code></pre>

    <h3> DateTime.ParseExact(String, String, IFormatProvider)</h3>
    Converts the specified string representation of a date and time to its DateTime equivalent using the specified
    format
    and culture-specific format information.
    The format of the string representation must match the specified format exactly.

    <b>Convert a specific format string to equivalent DateTime </b>
    Let's say we have a culture-specific DateTime string
    08-07-2016 11:30:12 PM as MM-dd-yyyy hh:mm:ss tt format and we want it to convert to equivalent DateTime object
    <pre><code>
 string str="08-07-2016 11:30:12 PM" ; 
 DateTime date=DateTime.ParseExact(str, "MM-dd-yyyy hh:mm:ss tt" , CultureInfo.CurrentCulture);
</code></pre>
    <b>Convert a date time string to equivalent DateTime object without any specific culture format</b>
    Let's say we have a DateTime string in dd-MM-yy hh:mm:ss tt format
    and we want it to convert to equivalent DateTime object, without any specific culture information
    <code>
string str="17-06-16 11:30:12 PM" ; 
DateTime date=DateTime.ParseExact(str, "dd-MM-yy hh:mm:ss tt" ,CultureInfo.InvariantCulture);   
</code>
    <b>Convert a date time string to equivalent DateTime object
      without any specific culture format with different format </b>

    Let's say we have a Date string , example like '23-12-2016' or '12/23/2016'
    and we want it to convert to equivalent DateTime object,
    without any specific culture information

    string date='23-12-2016' or date=12/23/2016';
    string[] formats=new string[] {"dd-MM-yyyy","MM/dd/yyyy"}; // even can add more possible formats.
    DateTime date=DateTime.ParseExact(date,formats, CultureInfo.InvariantCulture,DateTimeStyles.None);
    //NOTE : System.Globalization needs to be added for CultureInfo Class

    <h3>DateTime ToString, ToShortDateString,ToLongDateString and ToString formatted</h3>
    <pre><code>
 using System; public class Program { 
    public static void Main() {
      var date=new DateTime(2016,12,31); 
      Console.WriteLine(date.ToString()); 
      //Outputs: 12/31/2016 12:00:00 AM
      Console.WriteLine(date.ToShortDateString()); //Outputs: 12/31/2016 
      Console.WriteLine(date.ToLongDateString());//Outputs: Saturday, December 31, 2016 
      Console.WriteLine(date.ToString("dd/MM/yyyy")); //Outputs: 31/12/2016
    }
   }
  </code></pre>
    <h3>Current Date</h3>
    To get the current date you use the DateTime.Today property.
    This returns a DateTime object with today's date.
    When this is then converted .ToString() it is done so in your system's locality by default.
    For example:

    Console.WriteLine(DateTime.Today);

    Writes today's date, in your local format to the console.
  </div>
<h2>Arrays</h2>
  <div>
  <pre><code>
// Array Defenition :

int[] arr = new int[10];

// initializing using collection initialization syntax:
int[] arr = new int[] { 24, 2, 13, 47, 45 };
int[] arr = new int[3] {7,9,4};
Console.WriteLine(arr[0]); //outputs 7
Console.WriteLine(arr[1]); //outputs 9

int[] arr = null; // OK, declares a null reference to an array.
int first = arr[0]; // Throws System.NullReferenceException because there is no actual array.

// The new int[] portion can be omitted 
int[] arr = { 24, 2, 13, 47, 45 }; // OK

// This is not a self-contained expression, so
// using it as part of a different call does not work (for that, use the version with new):
int[] arr1;
arr1 = { 24, 2, 13, 47, 45 }; // Won't compile

// Implicitly typed arrays :

// In combination with the var keyword, the specific type may be omitted so that the type of the array is inferred:

// same as int[]
var arr = new [] { 1, 2, 3 };

// same as string[]
var arr = new [] { "one", "two", "three" };

// same as double[]
var arr = new [] { 1.0, 2.0, 3.0 };

// To create an array initialized with a non-default value:

int[] arr = new int[10];
//1. To create a bool array of size 10 filled with "true"
bool[] booleanArray = Enumerable.Repeat(true, 10).ToArray();

//2. To create an int array of size 5 filled with "100"
int[] intArray = Enumerable.Repeat(100, 5).ToArray();

//3. To create a string array of size 5 filled with "C#"
string[] strArray = Enumerable.Repeat("C#", 5).ToArray();

</code></pre>
<h3>Multidimensional Arrays</h3>
<pre><code>
int[, , , ,] arr5d; // five-dimensional array

int[,] arr2d = new int[3,2]{    {1, 2},  {3, 4}, {5, 6}   };
// or 
int[,] arr2d = {     {1, 2},   {3, 4},  {5, 6}    };
</code></pre>
<h3>Jagged Arrays: An Array of Array</h3>
<pre><code>
int[][] jArray = new int[2][]; 
jArray[0] = new int[3]{1, 2, 3};
jArray[1] = new int[4]{4, 5, 6, 7 };
</code></pre>
<h3>Copying arrays</h3>
<b>Array.Copy() </b>:
<pre><code>
var sourceArray = new int[] { 11, 12, 3, 5, 2, 9, 28, 17 };
var destinationArray= new int[3];
Array.Copy(sourceArray, destinationArray, 3);// destinationArray will have 11,12 and 3
</code></pre>
CopyTo() 
<pre><code>
//beginning at index 0 of the source and the specified index in the destination:
var sourceArray = new int[] { 11, 12, 7 };
var destinationArray = new int[6];
sourceArray.CopyTo(destinationArray, 2);
// destinationArray will have 0, 0, 11, 12, 7 and 0

//Clone is used to create a copy of an array object:

var sourceArray = new int[] { 11, 12, 7 };
var destinationArray = (int)sourceArray.Clone();
//destinationArray will be created and will have 11,12,17.  
</code></pre>
Both CopyTo and Clone perform shallow copy.
<b>shallow copy</b> means the contents contains references to the same object as the elements in the original array.
<h3>Comparing arrays for equality</h3>
<pre><code>
//SequenceEqual() :
int[] arr1 = { 3, 5, 7 };
int[] arr2 = { 3, 5, 7 };
bool result = arr1.SequenceEqual(arr2);
Console.WriteLine("Arrays equal? {0}", result);//prints: Arrays equal? True
</code></pre>
<h3>Multi-dimensional arrays</h3>
<pre><code>
  int[,] arr = new int[10, 10];
  int[,,] arr = new int[10, 10, 10];

 // You can also initialize the array upon declaration:
  int[,] arr = new int[4, 2] { {1, 1}, {2, 2}, {3, 3}, {4, 4} };
  Console.Out.WriteLine(arr[3, 1]); // 4  
</code></pre>
  <h3>Getting and setting array values</h3>
  <pre><code>
  int[] arr = new int[] { 0, 10, 20, 30};
  // Get
  Console.WriteLine(arr[2]); // 20

  // Set
  arr[2] = 100;
  Console.WriteLine(arr[2]); // 100
</code></pre>
<h3>Iterate over an array</h3>
<pre><code>
int[] arr = new int[] {1, 6, 3, 3, 9};
for (int i = 0; i < arr.Length; i++)
{
  Console.WriteLine(arr[i]);
}
// using foreach:
foreach (int element in arr)
{
  Console.WriteLine(element);
}

// using unsafe access with pointers 
unsafe
{
  int length = arr.Length;
  fixed (int* p = arr)
  {
    int* pInt = p;
    while (length-- > 0)
    {
      Console.WriteLine(*pInt);
      pInt++;// move pointer to next element
    }
  }
}
/*
Output:
1
6
3
3
9 */
</code></pre>
<h3>Enumerable.Range : Creating an array of sequential numbers</h3>
<pre><code>
int[] sequence = Enumerable.Range(1, 100).ToArray();
int[] squares = Enumerable.Range(2, 10).Select(  x => x * x ).ToArray();// 4 9 16 25 36 49 64 81 100 121
</code></pre>
<h3>Arrays as IEnumerable<> instances</h3>
- All arrays implement the non-generic <strong>IList</strong> interface.
(and hence non-generic <strong>ICollection</strong> and <strong>IEnumerable</strong> base interfaces).
- one-dimensional arrays implement the <strong>IList<></strong> and <strong>IReadOnlyList<></strong> generic interfaces.
(and their base interfaces) for the type of data that they contain.
This means that they can be treated as generic enumerable types
and passed in to a variety of methods without needing to first convert them to a non-array form.
<pre><code>
int[] arr1 = { 3, 5, 7 };
IEnumerable<int> enumerableIntegers = arr1; //Allowed because arrays implement IEnumerable<T>
List<int> listOfIntegers = new List<int>();
listOfIntegers.AddRange(arr1); //You can pass in a reference to an array to populate a List.
// the listOfIntegers will contain a List<int> containing the values 3, 5, and 7.
</code></pre>
 The IEnumerable<> support means arrays can be queried with LINQ, for example:
 <pre><code>arr1.Select(i => 10 * i)</code></pre> 
</div>
<h2>O(n) Algorithm, for circular rotation of an array</h2>
<div>
<h3>Example of a generic method that rotates an array by a given shift</h3>
<pre><code>
  public static void Main() {
    int[] array = {1,2,3,4,5,6,7,8,9,10};
    int shiftCount = 1;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    array = new[] {1,2,3,4,5,6,7,8, 9,10 };
    shiftCount = 15;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]

    array = new[] { 1,2,3,4,5,6,7,8,9,10};
    shiftCount = -1;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [2, 3, 4, 5, 6, 7, 8, 9, 10, 1]

    array = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    shiftCount = -35;
    Rotate(ref array, shiftCount);
    Console.WriteLine(string.Join(", ", array));
    // Output: [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]
  }
  private static void Rotate < T > (ref T[] array, int shiftCount) {
    T[] backupArray = new T[array.Length];
    for (int index = 0; index < array.Length; index++) {
      backupArray[(index + array.Length + shiftCount % array.Length) % array.Length] = array[index];
    }
    array = backupArray;
  }
</code></pre>
</div>
<h2>Enum</h2>
<div>
<h3>Enum basics</h3>
- A type to define a set of named integral constants that may be assigned to a variable.
- An enum is a type that only allows a set of finite options,and each option corresponds to a number.
  By default, those numbers are increasing in the order the values are declared, starting from <b>zero</b>.
  
  For example:
<pre><code>
public enum Day
{
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
  Sunday
}
// usage :
Day myFavoriteDay = Day.Friday;
Day myLeastFavoriteDay = Day.Monday;
// Get the int that corresponds to myFavoriteDay
int myFavoriteDayIndex = (int)myFavoriteDay; //// Friday is number 4
Day dayFive = (Day)5;  //// Get the day that represents number 5

/* By default the underlying type of each element in the enum is int, 
but byte, sbyte, short, ushort, uint, long and ulong can be used as well. 
If you use a type other than int, you must specify the type using a colon after the enum name: */

public enum Weekday : byte { Monday = 1, Tuesday = 2, Wednesday = 3, Thursday = 4, Friday = 5 }
// The numbers after the name are now bytes instead of integers. 
//You could get the underlying type of the enum as  follows:
Enum.GetUnderlyingType(typeof(Days)));//Output:System.Byte  
/*
This is useful when Invoking to native code, mapping to data sources, and similar circumstances.
In general, the default int should be used, because most developers expect an enum to be an int.
*/
</code></pre>
<h3>Enum as flags</h3>
The <b>Flags</b> Attribute can be applied to an enum 
changing the behaviour of the ToString() to match the nature of the enum:
<pre><code>
 [Flags]
  enum MyEnum
  {
    //None = 0, can be used but not combined in bitwise operations
    FlagA = 1,
    FlagB = 2,
    FlagC = 4,
    FlagD = 8
    //you must use powers of two or combinations of powers of two
    //for bitwise operations to work
  }
  var twoFlags = MyEnum.FlagA | MyEnum.FlagB; 
  Console.WriteLine(twoFlags);// output : "FlagA, FlagB".
</code></pre>
- Because Flags Attribute relies on the enumeration constants to be powers of two (or their combinations)
and enum values are ultimately numeric values, you are limited by the size of the underlying numeric type.

- The largest available numeric type that you can use is UInt64,
which allows you to specify 64 distinct (non-combined) flag enum constants.

- The enum keyword defaults to the underlying type int, which is Int32.
- The compiler will allow the declaration of values wider than 32 bit.
- Those will wrap around without a warning and result in two or more enum members of the same value.
  Therefore, if an enum is meant to accomodate a bitset of more than 32 flags,
  you need to specify a bigger type explicitely:
<pre><code>
  public enum BigEnum : ulong
  {
    BigValue = 1 << 63
  }
  //  Although flags are often only a single bit, they can be combined into named "sets" for easier use.
  [Flags]
  enum FlagsEnum
  {
    None = 0,
    Option1 = 1,
    Option2 = 2,
    Option3 = 4,
    Default = Option1 | Option3,
    All = Option1 | Option2 | Option3,
  }
  //To avoid spelling out the decimal values of powers of two, 
  the left-shift operator (<<) can also be used to declare the same enum
  [Flags]
  enum FlagsEnum
  {
    None = 0,
    Option1 = 1 << 0,
    Option2 = 1 << 1,
    Option3 = 1 << 2,
    Default = Option1 | Option3,
    All = Option1 | Option2 | Option3,
  }  
 </code></pre>
- Starting with C# 7.0, binary literals can be used too.
- To check if the value of enum variable has a certain flag set,the HasFlag method can be used:
<pre><code>
[Flags]
enum MyEnum
{
  One = 1,
  Two = 2,
  Three = 4
}
//  And a value
var value = MyEnum.One | MyEnum.Two;
//With HasFlag we can check if any of the flags is set
if(value.HasFlag(MyEnum.One))
    Console.WriteLine("Enum has One");
if(value.HasFlag(MyEnum.Two))
    Console.WriteLine("Enum has Two");
if(value.HasFlag(MyEnum.Three))
    Console.WriteLine("Enum has Three");
//Also we can iterate through all values of enum to get all flags that are set
var type = typeof(MyEnum);
var names = Enum.GetNames(type);
foreach (var name in names)
{
    var item = (MyEnum)Enum.Parse(type, name);
    if (value.HasFlag(item))
      Console.WriteLine("Enum has " + name);
}

// Or
foreach(MyEnum flagToCheck in Enum.GetValues(typeof(MyEnum)))
{
    if(value.HasFlag(flagToCheck))
    {
      Console.WriteLine("Enum has " + flagToCheck);
    }
}

/*All three examples will print:
  Enum has One
  Enum has Two*/   
</code></pre>
<h3>Using << notation for flags </h3>
The left-shift operator (<<) can be used in flag enum declarations 
to ensure that each flag has exactly one 1 in binary representation, as flags should. 
        
This also helps to improve readability of large enums with plenty of flags in them. 
<pre><code>
[Flags] 
public enum MyEnum {
  None=0, Flag1=1 << 0, Flag2=1 << 1, Flag3=1 << 2, Flag4=1 << 3,
  Flag5=1 << 4, ... Flag31=1 << 30 
} 
</code></pre>          
It is obvious now that MyEnum contains proper flags only 
and not any messy stuff like Flag30=1073741822 (or 111111111111111111111111111110 in binary) which is inappropriate. 
  
<h3>Test flags-style enum values with bitwise logic </h3>
 A flags-style enum value needs to be tested with bitwise logic because it may not match any single value. 
 <pre><code>
 [Flags] 
 enum FlagsEnum {
   Option1=1, Option2=2, Option3=4,Option2And3=Option2 | Option3; Default=Option1 | Option3, 
} 
 </code></pre>

The Default value is actually a combination of two others merged with a bitwise OR. 
Therefore to test for the presence of a flag we need to use a bitwise AND.
<pre><code>
var value=FlagsEnum.Default; 
bool isOption2And3Set=(value & FlagsEnum.Option2And3)==FlagsEnum.Option2And3; 
Assert.True(isOption2And3Set);  
</code></pre>
<h3> Add and remove values from flagged enum </h3>
This code is to add and remove a value from a flagged enum-instance: 
<pre><code>
[Flags] 
public  enum MyEnum { Flag1=1 << 0, Flag2=1 << 1, Flag3=1 << 2 } 
var value=MyEnum.Flag1; // set additional value value
          |=MyEnum.Flag2; //value is now Flag1, Flag2 value 
          |=MyEnum.Flag3; //value is now Flag1, Flag2, Flag3 // remove
          flag value &=~MyEnum.Flag2; //value is now Flag1, Flag3   
</code></pre>
 <h3>Enum to string and back public enum</h3>
 <pre><code>
  DayOfWeek { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } // Enum to string string
  thursday=DayOfWeek.Thursday.ToString(); // "Thursday" 
  string seventhDay=Enum.GetName(typeof(DayOfWeek), 6);
  // "Saturday" string monday=Enum.GetName(typeof(DayOfWeek), DayOfWeek.Monday); // "Monday" 
  // String to enum (.NET 4.0+ only - see below for alternative syntax for earlier .NET versions) 
  DayOfWeek tuesday;
  Enum.TryParse("Tuesday", out tuesday); // DayOfWeek.Tuesday 
  DayOfWeek sunday; 
  bool matchFound1=Enum.TryParse("SUNDAY", out sunday); // Returns false (case-sensitive match) 
  DayOfWeek wednesday;
  bool matchFound2=Enum.TryParse("WEDNESDAY", true, out wednesday); 
  // Returns true; DayOfWeek.Wednesday (case-insensitive match) // String to enum (all .NET versions) 
  DayOfWeek friday=(DayOfWeek)Enum.Parse(typeof(DayOfWeek), "Friday" ); // DayOfWeek.Friday DayOfWeek
  caturday=(DayOfWeek)Enum.Parse(typeof(DayOfWeek), "Caturady" ); // Thows ArgumentException // All names of an
  enum type as strings string[] weekdays=Enum.GetNames(typeof(DayOfWeek)); 
 </code></pre>
<h3>Enums can have unexpected values </h3>
 Since an enum can be cast to and from its underlying integral type,
  the value may fall outside the range of values given in the definition of the enum type. 
  
  Although the below enum type DaysOfWeek only has 7 defined values, it can still hold any int value. 
  <pre><code>
public enum DaysOfWeek {
   Monday=1, Tuesday=2,Wednesday=3, Thursday=4, Friday=5, Saturday=6, Sunday=7 
} 
DaysOfWeek d=(DaysOfWeek)31; Console.WriteLine(d);
// prints 31 DaysOFWeek
s=DaysOfWeek.Sunday; s++; 
// No error There is currently no way to define an enum which does not have this behavior. 
// However, undefined enum values can be detected by using the method Enum.IsDefined. 
// For example, DaysOfWeek d=(DaysOfWeek)31;
Console.WriteLine(Enum.IsDefined(typeof(DaysOfWeek),d)); 
// prints False 
</code></pre>  
<h3> Default value for enum==ZERO </h3>
The default value for an enum is zero. 
If an enum does not define an item with a value of zero, its default value will be zero. 
<pre><code>
public class Program { enum EnumExample { one=1, two=2 } 
public void Main() { 
  var e=default(EnumExample); 
  if (e==EnumExample.one) 
    Console.WriteLine("defaults to one");   
  else Console.WriteLine("Unknown"); } } 
  Example: https://dotnetfiddle.net/l5Rwie  
</code></pre>
<h3>Adding additional description information to an enum value </h3>
In some cases you might want to add an additional description to an enum value,
for instance when the enum value itself is less readable than what you might want to display to the user.

In such cases you can use the  <cle>System.ComponentModel.DescriptionAttribute class</cle> 

For example:
<pre><code>
public enum PossibleResults {
          [Description("Success")] 
          OK=1, 
          [Description("File not found")] 
          FileNotFound=2, 
          [Description("Access denied")]
          AccessDenied=3 
        } 
</code></pre>
Now, if you would like to return the description of a specific enum value you can do the following: 
<pre><code>
public static string GetDescriptionAttribute(PossibleResults result) {
   return
          ((DescriptionAttribute)Attribute.GetCustomAttribute((result.GetType().GetField(result.ToString())),
          typeof(DescriptionAttribute))).Description; 
}
static void Main(string[] args) { P
  ossibleResults  result=PossibleResults.FileNotFound; 
  Console.WriteLine(result); // Prints "FileNotFound"
  Console.WriteLine(GetDescriptionAttribute(result)); // Prints "File not found" 
}
</code></pre>
This can also be easily transformed to an extension method for all enums: 
<pre><code>
static class EnumExtensions { 
  public static string GetDescription(this Enum enumValue) { 
    return
          ((DescriptionAttribute)Attribute.GetCustomAttribute(
            (enumValue.GetType().GetField(enumValue.ToStrin g())),
          typeof(DescriptionAttribute))).Description; } 
}
</code></pre>

And then easily used like this:
 <pre><code>Console.WriteLine(result.GetDescription()); </code></pre>         
          
<h3>  Get all the members values of an enum</h3>  
<pre><code>
enum MyEnum { One, Two, Three } 
foreach(MyEnum e in Enum.GetValues(typeof(MyEnum))) 
  Console.WriteLine(e); //This will print: One Two Three   
</code></pre>   

<h3>Bitwise Manipulation using enums </h3>
- The FlagsAttribute should be used whenever the enumerable represents a collection of flags, rather than a single value. 
- The numeric value assigned to each enum value helps when manipulating enums using bitwise operators.
<pre><code>
 //Example 1 : With [Flags] 
 [Flags] 
 enum Colors { Red=1, Blue=2, Green=4, Yellow=8 } 
 var color=Colors.Red | Colors.Blue; 
 Console.WriteLine(color.ToString()); 
 prints Red,Blue 
 
 //Example 2 : Without [Flags] 
 enum Colors { Red=1, Blue=2, Green=4, Yellow=8 } 
 var color=Colors.Red | Colors.Blue;
  Console.WriteLine(color.ToString()); prints 3 
</code></pre>
</div>
<h2>Tuples</h2>
<div>
<h3>Accessing tuple elements</h3>
To access tuple elements use <b>Item1-Item8</b> properties. 

<pre><code>
var tuple = new Tuple<string, int, bool, MyClass>("foo", 123, true, new MyClass());
var item1 = tuple.Item1; // "foo"
var item2 = tuple.Item2; // 123
var item3 = tuple.Item3; // true
var item4 = tuple.Item4; // new My Class()   

// Only the properties with index number less or equal to tuple size are going to be available 
var item5 = tuple.Item5; // Invalid
</code></pre>

<h3>Creating tuples</h3>
Tuples are created using generic types Tuple< T1>-Tuple< T1,T2,T3,T4,T5,T6,T7,T8>. 
Each of the types represents a tuple containing 1 to 8 elements. 
Elements can be of different types.
<pre><code>
// tuple with 4 elements
var tuple = new Tuple<string, int, bool, MyClass>("foo", 123, true, new MyClass());
</code></pre>
Tuples can also be created using <strong>static Tuple.Create</strong> methods. 
In this case, the types of the elements are inferred by the C# Compiler.
<pre><code>
// tuple with 4 elements
var tuple = Tuple.Create("foo", 123, true, new MyClass());  
</code></pre>
Version ≥ 7.0
Since C# 7.0, Tuples can be easily created using ValueTuple.
<pre><code>
var tuple = ("foo", 123, true, new MyClass());  
</code></pre>
Elements can be named for easier decomposition.
<pre><code>
 (int number, bool flag, MyClass instance) tuple = (123, true, new MyClass()); 
</code></pre>
<h3>Comparing and sorting Tuples</h3>
Tuples can be compared based on their elements.
As an example, an enumerable whose elements are of type Tuple can be sorted 
based on comparisons operators defined on a specified element
<pre><code>
list.Add(new Tuple<int, string>(2, "foo"));
list.Add(new Tuple<int, string>(1, "bar"));
list.Add(new Tuple<int, string>(3, "qux"));
list.Sort((a, b) => a.Item2.CompareTo(b.Item2)); //sort based on the string element
foreach (var element in list) {
    Console.WriteLine(element);
}
//(1, bar)
// (2, foo)
// (3, qux)

// Or to reverse the sort use:
//  list.Sort((a, b) => b.Item2.CompareTo(a.Item2));
  </code></pre>
<h3>Return multiple values from a method</h3>
Tuples can be used to return multiple values from a method without using out parameters. 
In the following example AddMultiply is used to return two values (sum, product).
<pre><code>
  void Write()
  {
    var result = AddMultiply(25, 28);
    Console.WriteLine(result.Item1);
    Console.WriteLine(result.Item2);
  }
  Tuple<int, int> AddMultiply(int a, int b)
  {
  return new Tuple<int, int>(a + b, a * b);
  }
  Output:
  53
  700</code></pre>
Now C# 7.0 offers an alternative way to return multiple values from methods 
using value tuples More info about ValueTuple struct.
  </div>
  <h2>Tuple literals</h2>
  <div>
  <pre><code>
  var bob = ("Bob", 23);    // Allow compiler to infer the element types
  Console.WriteLine (bob.Item1);   // Bob
  Console.WriteLine (bob.Item2);   // 23
  </code></pre>  
  </div>
  <h2>Guid</h2>
  <div>
    GUID (or UUID) is an acronym for 'Globally Unique Identifier' (or 'Universally Unique Identifier').
    It is a 128-bit integer number used to identify resources.
    <h3>Getting the string representation of a Guid</h3>
    A string representation of a Guid can be obtained by using the built in ToString method
    <cl>string myGuidString = myGuid.ToString();</cl>
    Depending on your needs you can also format the Guid,
    by adding a format type argument to the ToString call.
    <pre><code>var guid = new Guid("7febf16f-651b-43b0-a5e3-0da8da49e90d");
    // None "7febf16f651b43b0a5e30da8da49e90d"
    Console.WriteLine(guid.ToString("N"));
    // Hyphens "7febf16f-651b-43b0-a5e3-0da8da49e90d"
    Console.WriteLine(guid.ToString("D"));
    // Braces "{7febf16f-651b-43b0-a5e3-0da8da49e90d}"
    Console.WriteLine(guid.ToString("B"));
    // Parentheses "(7febf16f-651b-43b0-a5e3-0da8da49e90d)"
    Console.WriteLine(guid.ToString("P"));
    // Hex "{0x7febf16f,0x651b,0x43b0{0xa5,0xe3,0x0d,0xa8,0xda,0x49,0xe9,0x0d}}"
    Console.WriteLine(guid.ToString("X"));</code></pre>
    <h3>Creating a Guid</h3>
    These are the most common ways to create an instance of Guid:
    <pre><code>
   //Creating an empty guid (00000000-0000-0000-0000-000000000000):
    Guid g = Guid.Empty;
    Guid g2 = new Guid();

    //Creating a new (pseudorandom) Guid:
    Guid g = Guid.NewGuid();

    //Creating Guids with a specific value:
    Guid g = new Guid("0b214de7-8958-4956-8eed-28f9ba2c47c6");
    Guid g2 = new Guid("0b214de7895849568eed28f9ba2c47c6");
    Guid g3 = Guid.Parse("0b214de7-8958-4956-8eed-28f9ba2c47c6");      
    </code></pre>
 
    <h3>Declaring a nullable GUID</h3>
    Like other value types, GUID also has a nullable type which can take null value.
    <cl>Guid? myGuidVar = null;</cl>
    This is particularly useful when retrieving data from the data base
    when there is a possibility that value from a table is NULL.
</div>
<h2>BigInteger</h2>
<div>
<h3>Calculate the First 1,000-Digit Fibonacci Number</h3>
<pre><code> 
  using System;
  using System.Numerics;
  namespace Euler_25 {
      class Program {
          static void Main(string[] args) {
              BigInteger l1 = 1;
              BigInteger l2 = 1;
              BigInteger current = l1 + l2;
              while (current.ToString().Length < 1000) {
                  l2 = l1;
                  l1 = current;
                  current = l1 + l2;
              }
              Console.WriteLine(current);
          }
      }
    </code></pre>
  </div>

<h2>collections</h2>
  <div>
  <h3>Collection Initializers</h3>

  Initialize a collection type with values
  <pre><code>var stringList = new List< string>{ "foo", "bar", };

  //  Collection initializers are syntactic sugar for Add() calls.
  // Above code is equivalent to
  var temp = new List< string>();
  temp.Add("foo");
  temp.Add("bar");
  var stringList = temp;
  </code></pre>
  - Note that the intialization is done atomically using a temporary variable,to avoid race conditions.
  - For types that offer multiple parameters in their Add() method, enclose the comma-separated arguments in curly braces:
  <pre><code>
    var numberDictionary = new Dictionary < int,string > 
    {
      {
          1,
          "One"
      },
      {
          2,
          "Two"
      },
  };

  //This is equivalent to:
  var temp = new Dictionary<int, string>();
  temp.Add(1, "One");
  temp.Add(2, "Two");
  var numberDictionarynumberDictionary = temp;
  </code></pre>
  <h3>Index Initializers</h3>
  Starting with C# 6, 
  collections with indexers can be initialized by specifying the index to assign in square brackets,
  followed by an equals sign, followed by the value to assign.
  Dictionary Initialization
  An example of this syntax using a Dictionary:
  <pre><code>
  var dict = new Dictionary < string,int > {
        ["key1"] = 1,
        ["key2"] = 50
    };
  //This is equivalent to:
  var dict = new Dictionary < string, int > ();
  dict["key1"] = 1;
  dict["key2"] = 50

  //The collection initializer syntax to do this before C # 6 was:
  var dict = new Dictionary < string, int > {
              {
                  "key1",
                  1
              },
              {
                  "key2",
                  50
              }
          };
  //Which would correspond to:
  var dict = new Dictionary < string, int > ();
  dict.Add("key1", 1);
  dict.Add("key2", 50);
  </code></pre>
  example2:
  <pre><code>
  public class IndexableClass {
    public int this[int index] {
      set {
          Console.WriteLine("{0} was assigned to index {1}", value, index);
      }
    }
  }
  var foo = new IndexableClass {
      [0] = 10,
      [1] = 20
  }
  /*
  This would output:
  10 was assigned to index 0
  20 was assigned to index 1
  */
    </code></pre>
  <h3>Collection initializers in custom classes</h3>
  To make a class support collection initializers, 
  it must implement IEnumerable interface and have at least one Add method. 
  Since C# 6, any collection implementing IEnumerable can be extended with custom Add methods using extension methods.
  <pre><code>
  class Program
  {
    static void Main()
    {
    var col = new MyCollection {
      "foo",
      { "bar", 3 },  
      class Program {
        static void Main() {
            var col = new MyCollection {
                "foo",
                {
                    "bar",
                    3
                },
                "baz",
                123.45 d,
            };
        }
    }
  class MyCollection: IEnumerable {
      private IList list = new ArrayList();
      public void Add(string item) {
          list.Add(item)
      }
      public void Add(string item, int count) {
          for (int i = 0; i < count; i++) {
              list.Add(item);
          }
      }
      public IEnumerator GetEnumerator() {
          return list.GetEnumerator();
      }
  }
  static class MyCollectionExtensions {
      public static void Add(this MyCollection @this, double value) =>
          @this.Add(value.ToString());
  }
  </code></pre>
  <h3>Using collection initializer inside object initializer</h3>
  <pre><code>
    public class Tag {
      public IList < string > Synonyms {
          get;
          set;
      }
  }
  // Synonyms is a collection - type property.When the Tag object is created using object initializer syntax, 
  //Synonyms can also be initialized with collection initializer syntax:
Tag t = new Tag {
    Synonyms = new List < string > {
        "c#",
        "c-sharp"
    }
};
  // The collection property can be readonly and still support collection initializer syntax.Consider this modified
  example(Synonyms property now has a private setter):
  public class Tag {
      public Tag() {
          Synonyms = new List < string > ();
      } 
  public IList<string> Synonyms { get; private set; }
  }
  //    A new Tag object can be created like this:
      Tag t = new Tag
      {
      Synonyms = {"c#", "c-sharp"}
      };
  // This works because collection initializers are just syntatic sugar over calls to Add(). There's no new list being created
    // here, the compiler is just generating calls to Add() on the exiting object
  </code></pre>
  <h3>Collection Initializers with Parameter Arrays</h3>
  You can mix normal parameters and parameter arrays:
  <pre><code>
  public class LotteryTicket : IEnumerable{
      public int[] LuckyNumbers;
      public string UserName;
      public void Add(string userName, params int[] luckyNumbers){
        UserName = userName;
        Lottery = luckyNumbers;
      }
    }
  //This syntax is now possible:
  var Tickets = new List<LotteryTicket>{
      {"Mr Cool" , 35663, 35732, 12312, 75685},
      {"Bruce" , 26874, 66677, 24546, 36483, 46768, 24632, 24527},
      {"John Cena", 25446, 83356, 65536, 23783, 24567, 89337}
    }
  </code></pre>
    <h3>HashSet< T>
    </h3>
    This is a collection of unique items, with O(1) lookup.
    <pre><code>
    HashSet<int> validStoryPointValues = new HashSet<int>() { 1, 2, 3, 5, 8, 13, 21 };
    bool containsEight = validStoryPointValues.Contains(8); // O(1)
    
    // By way of comparison, doing a Contains on a List yields poorer performance:
    List<int> validStoryPointValues = new List<int>() { 1, 2, 3, 5, 8, 13, 21 };
    bool containsEight = validStoryPointValues.Contains(8); // O(n)

    //HashSet.Contains uses a hash table, so that lookups are extremely fast
   </code></pre>
    <h3>Dictionary< TKey, TValue>
    </h3>
    <b>Dictionary< TKey, TValue></TKey></b> is a map. 
    For a given key there can be one value in the dictionary
    <pre><code>
      using System.Collections.Generic;
      var people = new Dictionary < string, int > {
              {  "John",   30     },
              { "Mary",    35     },
              { "Jack",   40      }
          };
      // Reading data :
      Console.WriteLine(people["John"]); // 30
      Console.WriteLine(people["George"]); // throws KeyNotFoundException
      int age;
      if (people.TryGetValue("Mary", out age)) {
          Console.WriteLine(age); // 35
      }

      // Adding and changing data :
      people["John"] = 40;    // Overwriting values this way is ok
      people.Add("John", 40); // Throws ArgumentException since "John" already exists

      // Iterating through contents
      foreach(KeyValuePair < string, int > person in people) {
          Console.WriteLine("Name={0}, Age={1}", person.Key, person.Value);
      }
      foreach(string name in people.Keys) {
          Console.WriteLine("Name={0}", name);
      }
      foreach(int age in people.Values) {
          Console.WriteLine("Age={0}", age);
      }
      var people = new Dictionary < string, int > {
              { "John",   30              },
              {"Mary",    35              },
              {"Jack",    40              },
              {"Jack",    40              }
     }; // throws ArgumentException since "Jack" already exists 
    </code></pre>
      <h3>SortedSet< T>
      </h3>
      <pre><code>
      // create an empty set
      var mySet = new SortedSet<int>();

      // add something
      // note that we add 2 before we add 1
      mySet.Add(2);
      mySet.Add(1);

      // enumerate through the set
      foreach(var item in mySet)
      {
        Console.WriteLine(item);
      }
      // output:
      // 1
      // 2
    </code></pre>
      <h3>T[ ] (Array of T)</h3>
      <pre><code>
      var myArray = new [] {
        "one",
        "two"
    };
    // enumerate through the array
    foreach(var item in myArray) {
        Console.WriteLine(item);
    }
    // output:
    // one
    // two

    // exchange the element on the first position
    myArray[0] = "something else";

    // enumerate through the array again
    foreach(var item in myArray) {
        Console.WriteLine(item);
    }
    // output:
    // something else
    // two
    </code></pre>
      <h3>List< T>
      </h3>
      List< T> is a list of a given type. 
      Items can be added, inserted, removed and addressed by index.
    <pre><code>
    using System.Collections.Generic;
    var list = new List<int>() { 1, 2, 3, 4, 5 };
    list.Add(6);
    Console.WriteLine(list.Count); // 6
    list.RemoveAt(3);
    Console.WriteLine(list.Count); // 5
    Console.WriteLine(list[3]); // 5
    </code></pre>
- List< T> can be thought of as an array that you can resize.
- Enumerating over the collection in order is quick, as is access to individual elements via their index.
- To access elements based on some aspect of their value, 
  or some other key, a Dictionary< T> will provide faster lookup.
<h3>Stack < T> </h3>
elements are stored with "first in, last out" order.
<pre><code>
// Initialize a stack object of integers
var stack = new Stack<int>();

// add some data
stack.Push(3);
stack.Push(5);
stack.Push(8);

// stack from top to bottom is: 8, 5, 3
// We can use peek to see the top element of the stack.
Console.WriteLine(stack.Peek()); // prints 8

// Pop removes the top element of the stack and returns it.
Console.WriteLine(stack.Pop()); // prints 8
Console.WriteLine(stack.Pop()); // prints 5
Console.WriteLine(stack.Pop()); // prints 3 
</code></pre>
<h3>LinkedList< T></h3> 
Note that LinkedList< T> represents the doubly linked list.
So, it's simply collection of nodes and each node
contains an element of type T.
Each node is linked to the preceding node and the following node
<pre><code>
  // initialize a LinkedList of integers
  LinkedList list = new LinkedList<int>();
  // add some numbers to our list.
  list.AddLast(3);
  list.AddLast(5);
  list.AddLast(8);
  // the list currently is 3, 5, 8
  list.AddFirst(2);
  // the list now is 2, 3, 5, 8
  list.RemoveFirst();
  // the list is now 3, 5, 8
  list.RemoveLast();
  // the list is now 3, 5
</code></pre>
           
<h3>Queue</h3>
<pre><code>
// Initalize a new queue of integers
var queue = new Queue<int>();
// Add some data
queue.Enqueue(6);
queue.Enqueue(4);
queue.Enqueue(9);
// Elements in a queue are stored in "first in, first out" order.
// The queue from first to last is: 6, 4, 9
// View the next element in the queue, without removing it.
Console.WriteLine(queue.Peek()); // prints 6
// Removes the first element in the queue, and returns it.
Console.WriteLine(queue.Dequeue()); // prints 6
Console.WriteLine(queue.Dequeue()); // prints 4
Console.WriteLine(queue.Dequeue()); // prints 9
</code></pre>
</div>

<h2>Looping</h2>
<div>
<h3>For Loop</h3>
<pre><code>
  for (int i = 0; i < 5; i++)
  {
    Console.WriteLine(i);
  }// output: 01234
</code></pre>
<h3>Do - While Loop</h3>
<pre><code>
  int[] numbers = new int[] { 6, 7, 8, 10 };
  int sum = 0;
  int i = 0;
  do
  {
    sum += numbers[i];
    i++;
  } while (sum <= 10 && i < numbers.Length);
  System.Console.WriteLine(sum); // 13
</code></pre>
<h3>Foreach Loop</h3>
- will iterate over any object of a class that implements <b>IEnumerable</b> 
- Such objects include some built-in ones, but not limit to: 
  <cl>List< T >, T[] (arrays of any type), Dictionary< TKey, TSource>, </cl>
  as well as interfaces like IQueryable and ICollection, etc.
<pre><code>
  var list = new List<string>();
  list.Add("Ion");
  list.Add("Andrei");
  foreach(var name in list)
  {
    Console.WriteLine("Hello " + name);
  }
    
  //is equivalent to:
  var list = new List<string>();
  list.Add("Ion");
  list.Add("Andrei");
  IEnumerator enumerator;
  try
  {
    enumerator = list.GetEnumerator();
    while (enumerator.MoveNext())
    {
      string name = (string)enumerator.Current;
      Console.WriteLine("Hello " + name);
    }
  }
  finally
  {
    if (enumerator != null)
      enumerator.Dispose();
  }
  </code></pre>
<h3>Foreach Method</h3>
<pre><code>
list.ForEach(item => item.DoSomething());
// or
list.ForEach(item => DoSomething(item));
// or using a method group
list.ForEach(Console.WriteLine);
// using an array
Array.ForEach(myArray, Console.WriteLine); 
</code></pre>
<h3>Linq Parallel Foreach</h3>
Just like Linq Foreach, except this one does the job in a parallel manner. 
Meaning that
all the items in the collection will run the given action <strog>at the same time</strog>, simultaneously.    
<pre><code>
collection.AsParallel().ForAll(item => item.DoSomething());
/// or
collection.AsParallel().ForAll(item => DoSomething(item));
</code></pre>
  <h3>continue</h3>
  Instead of breaking completely the loop, it will simply skip the current iteration. 
  
  <pre><code>
    for (int i = 1; i <= 10; i++)
    {
      if (i < 9)
        continue;
      Console.Write(i);  
    }//output 910
  </code></pre>
  <h3>IEnumrator</h3>
  <pre><code>
    // gets a list of strings with the names of the largest city metro areas:
    IEnumerator<string> largestMetroAreas = GetLargestMetroAreas(4);
    while (largestMetroAreas.MoveNext())
    {
      Console.WriteLine(largestMetroAreas.Current);
    }
 /* output:
    Tokyo / Yokohama
    New York Metro
    Sao Paulo
    Seoul / Incheon */
  </code></pre>
  </div>

<h2>Iterators</h2>
<div>
  
<h3>Creating Iterators Using Yield</h3>
- Iterators produce enumerators. 
- an iterator is a producer of an enumerator:
<pre><code>
foreach (int fib in Fibs(6))
  Console.Write (fib + "  ");

IEnumerable< int > Fibs (int fibCount)
{
  for (int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)
  {
    yield return prevFib;
    int newFib = prevFib+curFib;
    prevFib = curFib;
    curFib = newFib;
  }
}    
</code></pre>   
- enumerators are produced by defining methods, properties or indexers that contain yield statements.

- Most methods will return control to their caller through normal return statements,
which disposes all state local to that method. 
  In contrast, methods that use <b>yield</b> statements,
   allow them to return multiple values to the caller on request 
   while preserving local state in-between returning those values. 
- These returned values constitute a sequence. 

- There are two types of yield statements used within iterators:
  - <b>yield return</b>, which returns control to the caller but preserves state. 
    The callee will continue execution from this line when control is passed back to it.
  - <b>yield break</b>, which functions similarly to a normal return statement - this signifies the end of the sequence.
  Normal return statements themselves are illegal within an iterator block.
This example below demonstrates an iterator method that can be used to generate the Fibonacci sequence:
<pre><code>
IEnumerable<int> Fibonacci(int count)
  {
    int prev = 1;
    int curr = 1;
    for (int i = 0; i < count; i++)
    {
      yield return prev;
      int temp = prev + curr;
      prev = curr;
      curr = temp;
    }
  }
  // This iterator can then be used to produce an enumerator of the Fibonacci sequence 
  // that can be consumed by a calling method. 
  // The code below demonstrates how the first ten terms within the Fibonacci sequence can be enumerated:
  void Main()
  {
    foreach (int term in Fibonacci(10))
    {
      Console.Write(term);
      Console.Write(' ');
    }
  }
  // Output: 1 1 2 3 5 8 13 21
</code></pre>
<h3>Simple Numeric Iterator Example</h3>
    A common use-case for iterators is to perform some operation over a collection of numbers.
    The example below demonstrates how each element within an array of numbers can be individually printed out to the console.
    This is possible because arrays implement the IEnumerable interface, 
    allowing clients to obtain an iterator for the array using the GetEnumerator() method. 
    This method returns an enumerator, which is a read-only, forward-only cursor over each number in the array.
    <pre><code>
      int[] numbers = { 1, 2, 3, 4, 5 };
      IEnumerator iterator = numbers.GetEnumerator();
      while (iterator.MoveNext())
      {
        Console.Write(iterator.Current);
        Console.Write('\t')
      }
      // Output:   1    2     3     4     5

      //It's also possible to achieve the same results using a foreach statement:
      foreach (int number in numbers)
      {
        Console.WriteLine(number);
      }
    </code></pre>

  </div>

<h2>IEnumerable</h2>
 <div> 
  - IEnumerable is the base interface for all non-generic collections like ArrayList that can be enumerated.
  - IEnumerator< T> is the base interface for all generic enumerators like List< >.
  - IEnumerable is an interface which implements the method GetEnumerator.
  - The GetEnumerator method returns an IEnumerator 
    which provides options to iterate through the collection like foreach.      
    <h3>IEnumerable with custom Enumerator</h3>
    - Implementing the IEnumerable interface allows classes to be enumerated in the same way as BCL collections.
    - This requires extending the Enumerator class which tracks the state of the enumeration.
    - Other than iterating over a standard collection, examples include:
      . Using ranges of numbers based on a function rather than a collection of objects
      . Implementing different iteration algorithms over collections, like DFS or BFS on a graph collection

    <pre><code>    
public static void Main(string[] args)
  {
    foreach (var coffee in new CoffeeCollection())
    {
      Console.WriteLine(coffee);
    }
  }
  
  public class CoffeeCollection : IEnumerable
  {
    private CoffeeEnumerator enumerator;
    public CoffeeCollection()
    {
      enumerator = new CoffeeEnumerator();
    }
    public IEnumerator GetEnumerator()
    {
      return enumerator;
    }
    public class CoffeeEnumerator : IEnumerator
    {
      string[] beverages = new string[3] { "espresso", "macchiato", "latte" };
      int currentIndex = -1;
      public object Current
      {
        get
        {
          return beverages[currentIndex];
        }
      }
      public bool MoveNext()
      {
        currentIndex++;
        if (currentIndex < beverages.Length)
        {
          return true;
        }
        return false;
      }
      public void Reset()
      {
        currentIndex = 0;
      }</code></pre>
<h3>IEnumerable< int></int></h3>
- In its most basic form, an object that implements IEnumerable represents a series of objects.
- The objects in  question can be iterated using the c# foreach keyword.
- In the example below, the object sequenceOfNumbers implements IEnumerable. It represents a series of integers.
- The foreach loop iterates through each in turn.
<pre><code>
  int AddNumbers(IEnumerable<int> sequenceOfNumbers) {
    int returnValue = 0;
    foreach(int i in sequenceOfNumbers) {
    returnValue += i;
    }
    return returnValue;
  }
</code></pre>

</div>

<h2>Value type vs Reference type</h2>
<div>

<h3>Passing by reference using ref keyword</h3>
  - arguments can be passed to parameters either by value or by reference.
  - Passing by reference enables function to change the value of the parameters 
    and have that change persist in the calling environment.
  - To pass a parameter by reference, use the<b> ref or out</b> keyword.
  - The difference between ref and out is that :
     out means that the passed parameter has to be assigned before the function ends.
    in contrast parameters passed with ref can be changed or left unchanged
<pre><code>
  using System;
  class Program
  {
    static void Main(string[] args)
    {
      int a = 20;
      Console.WriteLine("Inside Main - Before Callee: a = {0}", a);
      Callee(a);
      Console.WriteLine("Inside Main - After Callee: a = {0}", a);
      Console.WriteLine("Inside Main - Before CalleeRef: a = {0}", a);
      CalleeRef(ref a);
      Console.WriteLine("Inside Main - After CalleeRef: a = {0}", a);
      Console.WriteLine("Inside Main - Before CalleeOut: a = {0}", a);
      CalleeOut(out a);
      Console.WriteLine("Inside Main - After CalleeOut: a = {0}", a);
      Console.ReadLine();
    }
    static void Callee(int a)
    {
      a = 5;
      Console.WriteLine("Inside Callee a : {0}", a);
    }
    static void CalleeRef(ref int a)
    {
      a = 6;
      Console.WriteLine("Inside CalleeRef a : {0}", a);
    }
    static void CalleeOut(out int a)
    {
      a = 7;
      Console.WriteLine("Inside CalleeOut a : {0}", a);
    }
  }
  /*Output:

  Inside Main - Before Callee: a = 20
  Inside Callee a: 5
  Inside Main -After Callee: a = 20
  Inside Main -Before CalleeRef: a = 20
  Inside CalleeRef a: 6
  Inside Main -After CalleeRef: a = 6
  Inside Main -Before CalleeOut: a = 6
  Inside CalleeOut a: 7
  Inside Main -After CalleeOut: a = 7 */
</code></pre>  
<h3>Changing values elsewhere</h3>
<pre><code>
  public static void Main(string[] args)
  {
    var studentList = new List<Student>();
    studentList.Add(new Student("Scott", "Nuke"));
    studentList.Add(new Student("Vincent", "King"));
    studentList.Add(new Student("Craig", "Bertt"));
    // make a separate list to print out later
    var printingList = studentList; // this is a new list object, but holding the same student
    objects inside it
    // oops, we've noticed typos in the names, so we fix those
    studentList[0].LastName = "Duke";
    studentList[1].LastName = "Kong";
    studentList[2].LastName = "Brett";
    // okay, we now print the list
    PrintPrintingList(printingList);
  }
  private static void PrintPrintingList(List<Student> students)
  {
    foreach (Student student in students)
    {
      Console.WriteLine(string.Format("{0} {1}", student.FirstName, student.LastName));
    }
  }
</code></pre>
You'll notice that even though the printingList list was made before the corrections to student names after the
typos, the PrintPrintingList method still prints out the corrected names:
Scott Duke
Vincent Kong
Craig Brett
This is because both lists hold a list of references to the same students. SO changing the underlying student object
propogates to usages by either list.
Here's what the student class would look like.
<pre><code>
  public class Student
  {
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public Student(string firstName, string lastName)
    {
      this.FirstName = firstName;
      this.LastName = lastName;
    }
  }
</code></pre>
<h3>ref vs out parameters</h3>
<pre><code>
  class Program
  {
    static void Main(string[] args)
    {
      int a = 20;
      Console.WriteLine("Inside Main - Before Callee: a = {0}", a);
      Callee(a);
      Console.WriteLine("Inside Main - After Callee: a = {0}", a);
      Console.WriteLine();
      Console.WriteLine("Inside Main - Before CalleeRef: a = {0}", a);
      CalleeRef(ref a);
      Console.WriteLine("Inside Main - After CalleeRef: a = {0}", a);
      Console.WriteLine();
      Console.WriteLine("Inside Main - Before CalleeOut: a = {0}", a);
      CalleeOut(out a);
      Console.WriteLine("Inside Main - After CalleeOut: a = {0}", a);
      Console.ReadLine();
    }
    static void Callee(int a)
    {
      a += 5;
      Console.WriteLine("Inside Callee a : {0}", a);
    }
    static void CalleeRef(ref int a)
    {
      a += 10;
      Console.WriteLine("Inside CalleeRef a : {0}", a);
    }
    static void CalleeOut(out int a)
    {
      // can't use a+=15 since for this method 'a' is not intialized only declared in the method
      declaration
      a = 25; //has to be initialized
      Console.WriteLine("Inside CalleeOut a : {0}", a);
    }
  }
  Output
  Inside Main - Before Callee: a = 20
  Inside Callee a: 25
  Inside Main -After Callee: a = 20
  Inside Main -Before CalleeRef: a = 20
  Inside CalleeRef a: 30
  Inside Main -After CalleeRef: a = 30
  Inside Main - Before CalleeOut: a = 30
  Inside CalleeOut a: 25
  Inside Main -After CalleeOut: a = 25
</code></pre>
<h3>Assignment</h3>
<pre><code>
  var a = new List<int>();
    var b = a;
    a.Add(5);
    Console.WriteLine(a.Count); // prints 1
    Console.WriteLine(b.Count); // prints 1 as well

    Assigning to a variable of a List<int> does not create a copy of the List<int>. Instead, it copies the reference to
    the List<int>. We call types that behave this way reference types.
</code></pre>
<h3>Difference with method parameters ref and out</h3>
There are two possible ways to pass a value type by reference: ref and out. The difference is that by passing it with
ref the value must be initialized but not when passing it with out. Using out ensures that the variable has a value
after the method call:
<pre><code>
  public void ByRef(ref int value)
  {
    Console.WriteLine(nameof(ByRef) + value);
    value += 4;
    Console.WriteLine(nameof(ByRef) + value);
  }
  public void ByOut(out int value)
  {
    value += 4 // CS0269: Use of unassigned out parameter `value'
  Console.WriteLine(nameof(ByOut) + value); // CS0269: Use of unassigned out parameter `value'
    value = 4;
    Console.WriteLine(nameof(ByOut) + value);
  }
  public void TestOut()
  {
    int outValue1;
    ByOut(out outValue1); // prints 4
    int outValue2 = 10; // does not make any sense for out
    ByOut(out outValue2); // prints 4
  }
  public void TestRef()
  {
    int refValue1;
    ByRef(ref refValue1); // S0165 Use of unassigned local variable 'refValue'
    int refValue2 = 0;
    ByRef(ref refValue2); // prints 0 and 4
    int refValue3 = 10;
    ByRef(ref refValue3); // prints 10 and 14
  }
  The catch is that by using out the parameter must be initialized before leaving the method, therefore the following
  GoalKicker.com – C# Notes for Professionals 133
  method is possible with ref but not with out:
  public void EmtyRef(bool condition, ref int value)
  {
    if (condition)
    {
      value += 10;
    }
  }
  public void EmtyOut(bool condition, out int value)
  {
    if (condition)
    {
      value = 10;
    }
  } //CS0177: The out parameter 'value' must be assigned before control leaves the current method
</code></pre>
This is because if condition does not hold, value goes unassigned.
<h3>Passing by reference</h3>
If you want the Value Types vs Reference Types in methods example to work properly, use the ref keyword in your
method signature for the parameter you want to pass by reference, as well as when you call the method.
<pre><code>
  public static void Main(string[] args)
  {
    ...
  DoubleNumber(ref number); // calling code
    Console.WriteLine(number); // outputs 8
    ...
  }
  public void DoubleNumber(ref int number)
  {
    number += number;
  }
</code></pre>
Making these changes would make the number update as expected, meaning the console output for number would
be 8.

</div> 
<h2>Built-in Types</h2>
<div>
<h3>Conversion of boxed value types</h3>
  Boxed value types can only be unboxed into their original Type, even if a conversion of the two Types is valid, e.g.:
<pre><code>
  object boxedInt = (int)1; // int boxed in an object
  long unboxedInt1 = (long)boxedInt; // invalid cast
  This can be avoided by first unboxing into the original Type, e.g.:
  long unboxedInt2 = (long)(int)boxedInt; // valid
</code></pre>  
<h3>Comparisons with boxed value types</h3>
<pre><code>
  If value types are assigned to variables of type object they are boxed - the value is stored in an instance of a
  System.Object. This can lead to unintended consequences when comparing values with ==, e.g.:
  object left = (int)1; // int in an object box
  object right = (int)1; // int in an object box
  var comparison1 = left == right; // false
  This can be avoided by using the overloaded Equals method, which will give the expected result.
  var comparison2 = left.Equals(right); // true
  Alternatively, the same could be done by unboxing the left and right variables so that the int values are
  compared:
  var comparison3 = (int)left == (int)right; // true
</code></pre>
<h3>Immutable reference type - string</h3>
<pre><code>
  // assign string from a string literal
  string s = "hello";
  // assign string from an array of characters
  char[] chars = new char[] { 'h', 'e', 'l', 'l', 'o' };
  string s = new string(chars, 0, chars.Length);
  // assign string from a char pointer, derived from a string
  string s;
  unsafe
  {
    fixed (char* charPointer = "hello")
    {
      s = new string(charPointer);
    }
  }
</code></pre>
<h3>Value type - char</h3>
<pre><code>// single character s
  char c = 's';
  // character s: casted from integer value
  char c = (char)115;
  // unicode character: single character s
  char c = '\u0073';
  // unicode character: smiley</code></pre>
<h3>Value type - short, int, long (signed 16 bit, 32 bit, 64 bit integers)</h3>
<pre><code>// assigning a signed short to its minimum value
  short s = -32768;
  // assigning a signed short to its maximum value
  short s = 32767;
  // assigning a signed int to its minimum value
  int i = -2147483648;
  // assigning a signed int to its maximum value
  int i = 2147483647;
  // assigning a signed long to its minimum value (note the long postfix)
  long l = -9223372036854775808L;
  // assigning a signed long to its maximum value (note the long postfix)
  long l = 9223372036854775807L;
  It is also possible to make these types nullable, meaning that additionally to the usual values, null can be assigned,
  too. If a variable of a nullable type is not initialized, it will be null instead of 0. Nullable types are marked by adding a
  question mark (?) after the type.
  int a; //This is now 0.
  int? b; //This is now null.</code></pre>
<h3>Value type - ushort, uint, ulong (unsigned 16 bit,
  32 bit, 64 bit integers)</h3>
<pre><code>
  // assigning an unsigned short to its minimum value
  ushort s = 0;
  // assigning an unsigned short to its maximum value
  ushort s = 65535;
  // assigning an unsigned int to its minimum value
  uint i = 0;
  // assigning an unsigned int to its maximum value
  uint i = 4294967295;

  // assigning an unsigned long to its minimum value (note the unsigned long postfix)
  ulong l = 0UL;
  // assigning an unsigned long to its maximum value (note the unsigned long postfix)
  ulong l = 18446744073709551615UL;
  It is also possible to make these types nullable, meaning that additionally to the usual values, null can be assigned,
  too. If a variable of a nullable type is not initialized, it will be null instead of 0. Nullable types are marked by adding a
  question mark (?) after the type.
  uint a; //This is now 0.
  uint? b; //This is now null.
</code></pre>
<h3>Value type - bool</h3>
<pre><code>// default value of boolean is false
  bool b;
  //default value of nullable boolean is null
  bool? z;
  b = true;
  if(b) {
  Console.WriteLine("Boolean has true value");
  }
  The bool keyword is an alias of System.Boolean. It is used to declare variables to store the Boolean values, true and
  false.</code></pre>

</div>

<h2>Aliases of built-in types</h2>
<div>
<h3>Built-In Types Table</h3>
The following table shows the keywords for built-in C# types, which are aliases of predefined types in the System
namespaces.
C# Type .NET Framework Type
bool System.Boolean
byte System.Byte
sbyte System.SByte
char System.Char
decimal System.Decimal
double System.Double
float System.Single
int System.Int32
uint System.UInt32
long System.Int64
ulong System.UInt64
object System.Object
short System.Int16
ushort System.UInt16
string System.String
The C# type keywords and their aliases are interchangeable. For example, you can declare an integer variable by
using either of the following declarations:

<pre><code>int number = 123;
System.Int32 number = 123;</code></pre>

</div>

<h2>Anonymous types</h2>
<div>
<h3>Anonymous vs dynamic</h3>
<pre><code>Anonymous types allow the creation of objects without having to explicitly define their types ahead of time, while
  maintaining static type checking.
  var anon = new { Value = 1 };
  Console.WriteLine(anon.Id); // compile time error
  Conversely, dynamic has dynamic type checking, opting for runtime errors, instead of compile-time errors.
  dynamic val = "foo";
  Console.WriteLine(val.Id); // compiles, but throws runtime error</code></pre>
<h3>Creating an anonymous type</h3>
<pre><code>Since anonymous types are not named, variables of those types must be implicitly typed (var).
  var anon = new { Foo = 1, Bar = 2 };
  // anon.Foo == 1
  // anon.Bar == 2
  If the member names are not specified, they are set to the name of the property/variable used to initialize the
  object.
  int foo = 1;
  int bar = 2;
  var anon2 = new { foo, bar };
  // anon2.foo == 1
  // anon2.bar == 2
  Note that names can only be omitted when the expression in the anonymous type declaration is a simple property
  access; for method calls or more complex expressions, a property name must be specified.
  string foo = "some string";
  var anon3 = new { foo.Length };
  // anon3.Length == 11
  var anon4 = new { foo.Length <= 10 ? "short string" : "long string" };
  // compiler error - Invalid anonymous type member declarator.
  var anon5 = new { Description = foo.Length <= 10 ? "short string" : "long string" };
  // OK</code></pre>
<h3>Anonymous type equality</h3>
<pre><code>Anonymous type equality is given by the Equals instance method. Two objects are equal if they have the same type
  and equal values (through a.Prop.Equals(b.Prop)) for every property.
  var anon = new { Foo = 1, Bar = 2 };
  var anon2 = new { Foo = 1, Bar = 2 };
  var anon3 = new { Foo = 5, Bar = 10 };
  var anon3 = new { Foo = 5, Bar = 10 };
  var anon4 = new { Bar = 2, Foo = 1 };
  // anon.Equals(anon2) == true
  // anon.Equals(anon3) == false
  // anon.Equals(anon4) == false (anon and anon4 have different types, see below)
  Two anonymous types are considered the same if and only if their properties have the same name and type and
  appear in the same order.
  var anon = new { Foo = 1, Bar = 2 };
  var anon2 = new { Foo = 7, Bar = 1 };
  var anon3 = new { Bar = 1, Foo = 3 };
  var anon4 = new { Fa = 1, Bar = 2 };
  // anon and anon2 have the same type
  // anon and anon3 have diferent types (Bar and Foo appear in different orders)
  // anon and anon4 have different types (property names are different)
</code></pre>
<h3>Generic methods with anonymous types</h3>
<pre><code>Generic methods allow the use of anonymous types through type inference.
  void Log<T>(T obj) {
  // ...
  }
  Log(new { Value = 10 });
  This means LINQ expressions can be used with anonymous types:
  var products = new[] {
  new { Amount = 10, Id = 0 },
  new { Amount = 20, Id = 1 },
  new { Amount = 15, Id = 2 }
  };
  var idsByAmount = products.OrderBy(x => x.Amount).Select(x => x.Id);
  // idsByAmount: 0, 2, 1</code></pre>
<h3>generic types with anonymous types</h3>
<pre><code>Using generic constructors would require the anonymous types to be named, which is not possible. Alternatively,
  generic methods may be used to allow type inference to occur.
  var anon = new { Foo = 1, Bar = 2 };
  var anon2 = new { Foo = 5, Bar = 10 };
  List<T> CreateList<T>(params T[] items) {
  return new List<T>(items);
  }
  var list1 = CreateList(anon, anon2);
  In the case of List<T>, implicitly typed arrays may be converted to a List<T> through the ToList LINQ method:
  var list2 = new[] {anon, anon2}.ToList();</code></pre>
<h3>Implicitly typed arrays</h3>
<pre><code>Arrays of anonymous types may be created with implicit typing.
  var arr = new[] {
    new { Id = 0 },
    new { Id = 1 }
  };
</code></pre>

</div>

<h2>Dynamic type</h2>
<div>
  <h3>Creating a dynamic object with properties</h3>
<pre><code>using System;
  using System.Dynamic;
  dynamic info = new ExpandoObject();
  info.Id = 123;
  info.Another = 456;
  Console.WriteLine(info.Another);
  // 456
  Console.WriteLine(info.DoesntExist);
  // Throws RuntimeBinderException</code></pre>

<h3>Creating a dynamic variable</h3>
<pre><code>dynamic foo = 123;
  Console.WriteLine(foo + 234);
  // 357 Console.WriteLine(foo.ToUpper())
  // RuntimeBinderException, since int doesn't have a ToUpper method
  foo = "123";
  Console.WriteLine(foo + 234);
  // 123234
  Console.WriteLine(foo.ToUpper()):
  // NOW A STRING</code></pre>
<h3>Returning dynamic</h3>
<pre><code>using System;
  public static void Main()
  {
    var value = GetValue();
    Console.WriteLine(value);
    // dynamics are useful!
  }
  private static dynamic GetValue()
  {
    return "dynamics are useful!";
  }</code></pre>

<h3>Handling Specific Types Unknown at Compile Time</h3>
 The following output equivalent results: 
<pre><code>class IfElseExample
{
public string DebugToString(object a)
{
if (a is StringBuilder)
{
  return DebugToStringInternal(a as StringBuilder);
  }
  else if (a is List<string>)
  {
  return DebugToStringInternal(a as List<string>);
  }
  else
  {
  return a.ToString();
  }
  }
  private string DebugToStringInternal(object a)
  {
  // Fall Back
  return a.ToString();
  }
  private string DebugToStringInternal(StringBuilder sb)
  {
    return $"StringBuilder - Capacity: {sb.Capacity}, MaxCapacity: {sb.MaxCapacity}, Value:
    {sb.ToString()}";
  }
  private string DebugToStringInternal(List<string> list)
  {
    return $"List<string> - Count: {list.Count}, Value: {Environment.NewLine + "\t" +
    string.Join(Environment.NewLine + "\t", list.ToArray())}";
  }
  }
  class DynamicExample
  {
  public string DebugToString(object a)
  {
  return DebugToStringInternal((dynamic)a);
  }
  private string DebugToStringInternal(object a)
  {
  // Fall Back
  return a.ToString();
  }
  private string DebugToStringInternal(StringBuilder sb)
  {
  return $"StringBuilder - Capacity: {sb.Capacity}, MaxCapacity: {sb.MaxCapacity}, Value:
  {sb.ToString()}";
  }
  private string DebugToStringInternal(List<string> list)
  {
  return $"List<string> - Count: {list.Count}, Value: {Environment.NewLine + "\t" +
  string.Join(Environment.NewLine + "\t", list.ToArray())}";
  }
  }</code></pre>


  The advantage to the dynamic, is adding a new Type to handle just requires adding an overload of
  DebugToStringInternal of the new type. Also eliminates the need to manually cast it to the type as well.


</div>

<h2>Type Conversion</h2>
<div>
<h3>Explicit Type Conversion</h3>
<pre><code>using System;
  namespace TypeConversionApplication
  {
    class ExplicitConversion
    {
      static void Main(string[] args)
      {
        double d = 5673.74;
        int i;
        // cast double to int.
        i = (int)d;
        Console.WriteLine(i);
        Console.ReadKey();
      }
    }
  }</code></pre>
<h3>MSDN implicit operator example</h3>
<pre><code>
  class Digit
  {
    public Digit(double d) { val = d; }
    public double val;
    // User-defined conversion from Digit to double
    public static implicit operator double(Digit d)
    {
      Console.WriteLine("Digit to double implict conversion called");
      return d.val;
    }
    // User-defined conversion from double to Digit
    public static implicit operator Digit(double d)
    {
      Console.WriteLine("double to Digit implict conversion called");
      return new Digit(d);
    }
  }
  class Program
  {
    static void Main(string[] args)
    {
      Digit dig = new Digit(7);
      //This call invokes the implicit "double" operator
      double num = dig;
      //This call invokes the implicit "Digit" operator
      Digit dig2 = 12;
      Console.WriteLine("num = {0} dig2 = {1}", num, dig2.val);
      Console.ReadLine();
    }
  }
 /* Output:
  Digit to double implict conversion called
  double to Digit implict conversion called
  num = 7 dig2 = 12*/
</code></pre>

</div>

<h2>Casting</h2>
<div>
<h3>Checking compatibility without casting</h3>
<pre><code>If you need to know whether a value's type extends or implements a given type, but you don't want to actually cast
  it as that type, you can use the is operator.
  if(value is int)
  {
  Console.WriteLine(value + "is an int");
  }</code></pre>
<h3>Cast an object to a base type</h3>
<pre><code>Given the following definitions :
  public interface IMyInterface1
  {
    string GetName();
  }
  public interface IMyInterface2
  {
    string GetName();
  }
  public class MyClass : IMyInterface1, IMyInterface2
  {
    string IMyInterface1.GetName()
    {
      return "IMyInterface1";
    }
    string IMyInterface2.GetName()
    {
      return "IMyInterface2";
    }
  }
  Casting an object to a base type example :
  MyClass obj = new MyClass();
  IMyInterface1 myClass1 = (IMyInterface1)obj;
  IMyInterface2 myClass2 = (IMyInterface2)obj;
  Console.WriteLine("I am : {0}", myClass1.GetName());
  Console.WriteLine("I am : {0}", myClass2.GetName());
  // Outputs :
  // I am : IMyInterface1
  // I am : IMyInterface2
  Section 37.3: Conversion Operators
  In C#, types can define custom Conversion Operators, which allow values to be converted to and from other types
  using either explicit or implicit casts.For example, consider a class that is meant to represent a JavaScript
  GoalKicker.com – C# Notes for Professionals 146
  expression:
  public class JsExpression
  {
    private readonly string expression;
    public JsExpression(string rawExpression)
    {
      this.expression = rawExpression;
    }
    public override string ToString()
    {
      return this.expression;
    }
    public JsExpression IsEqualTo(JsExpression other)
    {
      return new JsExpression("(" + this + " == " + other + ")");
    }
  }
  If we wanted to create a JsExpression representing a comparison of two JavaScript values, we could do something
  like this:
  JsExpression intExpression = new JsExpression("-1");
  JsExpression doubleExpression = new JsExpression("-1.0");
  Console.WriteLine(intExpression.IsEqualTo(doubleExpression)); // (-1 == -1.0)
  But we can add some explicit conversion operators to JsExpression, to allow a simple conversion when using explicit
  casting.
  public static explicit operator JsExpression(int value)
  {
    return new JsExpression(value.ToString());
  }
  public static explicit operator JsExpression(double value)
  {
    return new JsExpression(value.ToString());
  }
  // Usage:
  JsExpression intExpression = (JsExpression)(-1);
  JsExpression doubleExpression = (JsExpression)(-1.0);
  Console.WriteLine(intExpression.IsEqualTo(doubleExpression)); // (-1 == -1.0)
  Or, we could change these operators to implicit to make the syntax much simpler.
  public static implicit operator JsExpression(int value)
  {
    return new JsExpression(value.ToString());
  }
  public static implicit operator JsExpression(double value)
  {
    return new JsExpression(value.ToString());
  }
  // Usage:
  JsExpression intExpression = -1;
  Console.WriteLine(intExpression.IsEqualTo(-1.0)); // (-1 == -1.0)
</code></pre>
<h3>LINQ Casting operations</h3>
<pre><code>
  Suppose you have types like the following:
  interface IThing { }
  class Thing : IThing { }
  LINQ allows you to create a projection that changes the compile-time generic type of an IEnumerable<> via the
  Enumerable.Cast<>() and Enumerable.OfType<>() extension methods.
  IEnumerable<IThing> things = new IThing[] {new Thing()};
  IEnumerable<Thing> things2 = things.Cast<Thing>();
  IEnumerable<Thing> things3 = things.OfType<Thing>();
  When things2 is evaluated, the Cast<>() method will try to cast all of the values in things into Things. If it
  encounters a value that cannot be cast, an InvalidCastException will be thrown.
  When things3 is evaluated, the OfType<>() method will do the same, except that if it encounters a value that
  cannot be cast, it will simply omit that value rather than throw an exception.
  Due to the generic type of these methods, they cannot invoke Conversion Operators or perform numeric
  conversions.
  double[] doubles = new[]{1,2,3}.Cast<double>().ToArray(); // Throws InvalidCastException
  You can simply perform a cast inside a .Select() as a workaround:
  double[] doubles = new[]{1,2,3}.Select(i => (double)i).ToArray();
</code></pre>
<h3>Explicit Casting</h3>
<pre><code>If you know that a value is of a specific type, you can explicitly cast it to that type in order to use it in a context
  where that type is needed.
  object value = -1;
  int number = (int) value;
  Console.WriteLine(Math.Abs(number));
  If we tried passing value directly to Math.Abs(), we would get a compile-time exception because Math.Abs()
  doesn't have an overload that takes an object as a parameter.
  If value could not be cast to an int, then the second line in this example would throw an InvalidCastException</code></pre>
<h3>Safe Explicit Casting (`as` operator)</h3>
<pre><code>If you aren't sure whether a value is of the type you think it is, you can safely cast it using the as operator. If the
  value is not of that type, the resulting value will be null.
  object value = "-1";
  int? number = value as int?;
  if(number != null)
  {
  Console.WriteLine(Math.Abs(number.Value));
  }
</code></pre>
Note that null values have no type, so the as keyword will safely yield null when casting any null value.
<h3>Implicit Casting</h3>
A value will automatically be cast to the appropriate type if the compiler knows that it can always be converted to
that type.
<pre><code>int number = -1;
object value = number;
Console.WriteLine(value);
In this example, we didn't need to use the typical explicit casting syntax because the compiler knows all ints can be
cast to objects. In fact, we could avoid creating variables and pass -1 directly as the argument of
Console.WriteLine() that expects an object.
Console.WriteLine(-1);</code></pre>

<h3>Explicit Numeric Conversions</h3>
Explicit casting operators can be used to perform conversions of numeric types, even though they don't extend or
  implement one another.
<pre><code>
  double value = -1.1;
  int number = (int) value;
 // Note that in cases where the destination type has less precision than the original type, precision will be lost. For
//  example, -1.1 as a double value in the above example becomes -1 as an integer value.
//  Also, numeric conversions rely on compile-time types, so they won't work if the numeric types have been "boxed" into objects.
  object value = -1.1;
  int number = (int) value; // throws InvalidCastException
</code></pre>
</div>
<h2>Nullable types</h2>
<div>
<h3>Initialising a nullable</h3>
<pre><code>For null values:
  Nullable< int> i = null;
  Or:
  int? i = null;
  Or:
  var i = (int?)null;
  For non-null values:
  Nullable< int> i = 0;
  Or:
  int? i = 0;</code></pre>

<h3>Check if a Nullable has a value</h3>
<pre><code>int? i = null;
  if (i != null)
  {
    Console.WriteLine("i is not null");
  }
  else
  {
    Console.WriteLine("i is null");
  }
  
  //Which is the same as:
  if (i.HasValue)
  {
    Console.WriteLine("i is not null");
  }
  else
  {
    Console.WriteLine("i is null");
  }</code></pre>

<h3>Get the value of a nullable type</h3>
Given following nullable int
<pre><code>int? i = 10;</code></pre>
In case default value is needed, you can assign one using null coalescing operator, 
GetValueOrDefault method or check if nullable int HasValue before assignment.
<pre><code>int j = i ?? 0;
int j = i.GetValueOrDefault(0);
int j = i.HasValue ? i.Value : 0;</code></pre>

The following usage is always unsafe. 
If i is null at runtime, a System.InvalidOperationException will be thrown.
At design time, if a value is not set, you'll get a Use of unassigned local variable 'i' error.
int j = i.Value;
<h3>Getting a default value from a nullable</h3>
The .GetValueOrDefault() method returns a value even if the .HasValue property is false 
(unlike the Value property, which throws an exception).
<pre><code>
  class Program
  {
    static void Main()
    {
      int? nullableExample = null;
      int result = nullableExample.GetValueOrDefault();
      Console.WriteLine(result); // will output the default value for int - 0
      int secondResult = nullableExample.GetValueOrDefault(1);
      Console.WriteLine(secondResult) // will output our specified default - 1
      int thirdResult = nullableExample ?? 1;
      Console.WriteLine(secondResult) // same as the GetValueOrDefault but a bit shorter
    }
  }
  Output:
  0
  1</code></pre>

<h3>Default value of nullable types is null</h3>
<pre><code>
  public class NullableTypesExample
  {
    static int? _testValue;
    public static void Main()
    {
      if(_testValue == null)
        Console.WriteLine("null");
      else
        Console.WriteLine(_testValue.ToString());
    }
  }
  Output:
  null</code></pre>

<h3>Effective usage of underlying Nullable< T >argument</h3>
<pre><code>
  Any nullable type is a generic type.And any nullable type is a value type.
  There are some tricks which allow to effectively use the result of the Nullable.GetUnderlyingType method when
  creating code related to reflection/code-generation purposes:
  public static class TypesHelper
  {
    public static bool IsNullable(this Type type)
    {
      Type underlyingType;
      return IsNullable(type, out underlyingType);
    }
    public static bool IsNullable(this Type type, out Type underlyingType)
    {
      underlyingType = Nullable.GetUnderlyingType(type);
      return underlyingType != null;
    }
    public static Type GetNullable(Type type)
    {
      Type underlyingType;
      return IsNullable(type, out underlyingType) ? type : NullableTypesCache.Get(type);
    }
    public static bool IsExactOrNullable(this Type type, Func< Type, bool> predicate)
    {
      Type underlyingType;
      if (IsNullable(type, out underlyingType))
        return IsExactOrNullable(underlyingType, predicate);
      return predicate(type);
    }
    public static bool IsExactOrNullable< T>(this Type type)
    where T : struct
    {
      return IsExactOrNullable(type, t => Equals(t, typeof(T)));
    }
  }
  The usage:
  Type type = typeof(int).GetNullable();
  Console.WriteLine(type.ToString());
  if (type.IsNullable())
    Console.WriteLine("Type is nullable.");
  Type underlyingType;
  if (type.IsNullable(out underlyingType))
    Console.WriteLine("The underlying type is " + underlyingType.Name + ".");
  if (type.IsExactOrNullable< int>())
    Console.WriteLine("Type is either exact or nullable Int32.");
  if (!type.IsExactOrNullable(t => t.IsEnum))
    Console.WriteLine("Type is neither exact nor nullable enum.");
  Output:
  System.Nullable`1[System.Int32]
  Type is nullable.
  The underlying type is Int32.
  Type is either exact or nullable Int32.
  Type is neither exact nor nullable enum.
 
  PS.The NullableTypesCache is defined as follows:
 
  static class NullableTypesCache
  {
    readonly static ConcurrentDictionary< Type, Type> cache = new ConcurrentDictionary< Type,
    Type>();
    static NullableTypesCache()
    {
      cache.TryAdd(typeof(byte), typeof(Nullable< byte>));
      cache.TryAdd(typeof(short), typeof(Nullable< short>));
      cache.TryAdd(typeof(int), typeof(Nullable< int>));
      cache.TryAdd(typeof(long), typeof(Nullable< long>));
      cache.TryAdd(typeof(float), typeof(Nullable< float>));
      cache.TryAdd(typeof(double), typeof(Nullable< double>));
      cache.TryAdd(typeof(decimal), typeof(Nullable< decimal>));
      cache.TryAdd(typeof(sbyte), typeof(Nullable< sbyte>));
      cache.TryAdd(typeof(ushort), typeof(Nullable< ushort>));
      cache.TryAdd(typeof(uint), typeof(Nullable< uint>));
      cache.TryAdd(typeof(ulong), typeof(Nullable< ulong>));
      //...
    }
    readonly static Type NullableBase = typeof(Nullable<>);
    internal static Type Get(Type type)
    {
      // Try to avoid the expensive MakeGenericType method call
      return cache.GetOrAdd(type, t => NullableBase.MakeGenericType(t));
    }
  }
</code></pre>

<h3>Check if a generic type parameter is a nullable type</h3>
<pre><code>public bool IsTypeNullable<T>()
  {
  return Nullable.GetUnderlyingType( typeof(T) )!=null;
  }</code></pre>
</div>

<h2>Constructors and Finalizers</h2>
<div>
  Constructors are methods in a class that are invoked when an instance of that class is created. Their main
  responsibility is to leave the new object in a useful and consistent state.
  Destructors/Finalizers are methods in a class that are invoked when an instance of that is destroyed. In C# they are
  rarely explicitely written/used.
<h3>Static constructor</h3>
- A static constructor is called the first time any member of a type is initialized, 
  a static class member is called or a static method. 
- The static constructor is thread safe. 
- A static constructor is commonly used to:
  . Initialize static state, that is state which is shared across different instances of the same class.
  . Create a singleton
<pre><code>
  {
  // * A static constructor is executed only once,
  // when a class is first accessed.
  // * A static constructor cannot have any access modifiers
  // * A static constructor cannot have any parameters
  static Animal()
  {
    Console.WriteLine("Animal initialized");
  }
  // Instance constructor, this is executed every time the class is created
  public Animal()
  {
    Console.WriteLine("Animal created");
  }
  public static void Yawn()
  {
    Console.WriteLine("Yawn!");
  }
}
var turtle = new Animal();
var giraffe = new Animal();
Output:
Animal initialized
Animal created
Animal created</code></pre>
If the first call is to a static method, the static constructor is invoked without the instance constructor. This is OK,
because the static method can't access instance state anyways.
<pre><code>
  Animal.Yawn();
  This will output:
  Animal initialized
  Yawn!
  See also Exceptions in static constructors and Generic Static Constructors .
  Singleton example:
  public class SessionManager
  {
    public static SessionManager Instance;
    static SessionManager()
    {
      Instance = new SessionManager();
    }
  }</code></pre>
<h3>Singleton constructor pattern</h3>
<pre><code>public class SingletonClass
  {
    public static SingletonClass Instance { get; } = new SingletonClass();
    private SingletonClass()
    {
      // Put custom constructor code here
    }
  }</code></pre>
  Because the constructor is private, no new instances of SingletonClass can be made by consuming code. 
  The only way to access the single instance of SingletonClass is by using the static property SingletonClass.Instance.
  The Instance property is assigned by a static constructor that the C# compiler generates. 
  The .NET runtime guarantees that the static constructor is run at most once and is run before Instance is first read. 
  Therefore, all synchronization and initialization concerns are carried out by the runtime.
  Note, that if the static constructor fails the Singleton class becomes permanently unusable 
  for the life of the AppDomain.
  Also, the static constructor is not guaranteed to run at the time of the first access of Instance. 
  Rather, it will run at some point before that. 
  This makes the time at which initialization happens non-deterministic. 
  In practical cases the JIT often calls the static constructor during compilation (not execution) 
  of a method referencing Instance. 
  This is a performance optimization.
  See the Singleton Implementations page for other ways to implement the singleton pattern.
<h3>Default Constructor</h3>
When a type is defined without a constructor:
<pre><code>
  public class Animal
  {
  }
  then the compiler generates a default constructor equivalent to the following:
  public class Animal
  {
  public Animal() {}
  }
  The definition of any constructor for the type will suppress the default constructor generation. If the type were
  defined as follows:
  public class Animal
  {
  public Animal(string name) {}
  }
  then an Animal could only be created by calling the declared constructor.
  
  // This is valid
  var myAnimal = new Animal("Fluffy");
  // This fails to compile
  var unnamedAnimal = new Animal();
  
  For the second example, the compiler will display an error message:
  'Animal' does not contain a constructor that takes 0 arguments
  If you want a class to have both a parameterless constructor and a constructor that takes a parameter, you can do
  it by explicitly implementing both constructors.
  
  public class Animal
  {
    public Animal() {} //Equivalent to a default constructor.
    public Animal(string name) {}
  }
  
  The compiler will not be able to generate a default constructor if the class extends another class which doesn't have
  a parameterless constructor. For example, if we had a class Creature:
  
  public class Creature
  {
    public Creature(Genus genus) {}
  }
  then Animal defined as class Animal : Creature {} would not compile.
  Section 39.4: Forcing a static constructor to be called
  While static constructors are always called before the first usage of a type it's sometimes useful to be able to force
  them to be called and the RuntimeHelpers class provide an helper for it:
  
  using System.Runtime.CompilerServices;
  // ...
  RuntimeHelpers.RunClassConstructor(typeof(Foo).TypeHandle);
  Remark: All static initialization (fields initializers for example) will run, not only the constructor itself.
  Potential usages: Forcing initialization during the splash screen in an UI application or ensuring that a static
  constructor doesn't fail in an unit test.
</code></pre>

<h3>Calling a constructor from another constructor</h3>
<pre><code>public class Animal
  {
    public string Name { get; set; }
    public Animal() : this("Dog")
    {
    }
    public Animal(string name)
    {
      Name = name;
    }
  }
  var dog = new Animal(); // dog.Name will be set to "Dog" by default.
  var cat = new Animal("Cat"); // cat.Name is "Cat", the empty constructor is not called.</code></pre>

<h3>Calling the base class constructor</h3>
A constructor of a base class is called before a constructor of a derived class is executed. For example, if Mammal
extends Animal, then the code contained in the constructor of Animal is called first when creating an instance of a
Mammal.
If a derived class doesn't explicitly specify which constructor of the base class should be called, the compiler
assumes the parameterless constructor.
<pre><code>public class Animal
  {
    public Animal() { Console.WriteLine("An unknown animal gets born."); }
    public Animal(string name) { Console.WriteLine(name + " gets born"); }
  }
  public class Mammal : Animal
  {
    public Mammal(string name)
    {
      Console.WriteLine(name + " is a mammal.");
    }
  }
  In this case, instantiating a Mammal by calling new Mammal("George the Cat") will print
  An unknown animal gets born.
  George the Cat is a mammal.
  Calling a different constructor of the base class is done by placing : base(args) between the constructor's
  signature and its body:
  public class Mammal : Animal
  {
    public Mammal(string name) : base(name)
    {
      Console.WriteLine(name + " is a mammal.");
    }
  }
  Calling new Mammal("George the Cat") will now print:
  George the Cat gets born.
  George the Cat is a mammal
</code></pre>

<h3>Finalizers on derived classes</h3>
When an object graph is finalized, the order is the reverse of the construction.
 E.g. the super-type is finalized before
the base-type as the following code demonstrates
<pre><code>class TheBaseClass
  {
    ~TheBaseClass()
    {
      Console.WriteLine("Base class finalized!");
    }
  }
  class TheDerivedClass : TheBaseClass
  {
    ~TheDerivedClass()
    {
      Console.WriteLine("Derived class finalized!");
    }
  }
  //Don't assign to a variable
  //to make the object unreachable
  new TheDerivedClass();
  //Just to make the example work;
  //this is otherwise NOT recommended!
  GC.Collect();
  //Derived class finalized!
  //Base class finalized</code></pre>

<h3>Exceptions in static constructors</h3>
If a static constructor throws an exception, it is never retried.
 The type is unusable for the lifetime of the
AppDomain. Any further usages of the type will raise a TypeInitializationException wrapped around the original exception.
<pre><code>public class Animal
  {
    static Animal()
    {
      Console.WriteLine("Static ctor");
      throw new Exception();
    }
    public static void Yawn() { }
  }
  try
  {
    Animal.Yawn();
  }
  catch (Exception e)
  {
    Console.WriteLine(e.ToString());
  }
  try
  {
    Animal.Yawn();
  }
  catch (Exception e)
  {
    Console.WriteLine(e.ToString());
  }
  This will output:
  Static ctor
  System.TypeInitializationException: The type initializer for 'Animal' threw an exception. --->
  System.Exception: Exception of type 'System.Exception' was thrown.
  [...]
  System.TypeInitializationException: The type initializer for 'Animal' threw an exception. --->
  System.Exception: Exception of type 'System.Exception' was thrown.
  where you can see that the actual constructor is only executed once, and the exception is re - used.</code></pre>

<h3>Constructor and Property Initialization</h3>
Shall the property value's assignment be executed before or after the class' constructor?
<pre><code>
  public class TestClass
  {
    public int TestProperty { get; set; } = 2;
    public TestClass()
    {
      if (TestProperty == 1)
      {
        Console.WriteLine("Shall this be executed?");
      }
      if (TestProperty == 2)
      {
        Console.WriteLine("Or shall this be executed");
      }
    }
  }
  var testInstance = new TestClass() { TestProperty = 1 };
  In the example above, shall the TestProperty value be 1 in the class' constructor or after the class constructor?
  Assigning property values in the instance creation like this:
  var testInstance = new TestClass() {TestProperty = 1};
  Will be executed after the constructor is run. However, initializing the property value in the class' property in C# 6.0
  like this:
  public class TestClass
  {
  public int TestProperty { get; set; } = 2;
  public TestClass()
  {
  }
  }
  will be done before the constructor is run.
  Combining the two concepts above in a single example:
  public class TestClass
  {
  public int TestProperty { get; set; } = 2;
  public TestClass()
  {
  if (TestProperty == 1)
  {
  Console.WriteLine("Shall this be executed?");
  }
  if (TestProperty == 2)
  {
  Console.WriteLine("Or shall this be executed");
  }
  }
  }
  static void Main(string[] args)
  {
    var testInstance = new TestClass() { TestProperty = 1 };
    Console.WriteLine(testInstance.TestProperty); //resulting in 1
  }

  Final result:
  "Or shall this be executed"
  "1"
  Explanation:
  The TestProperty value will first be assigned as 2, then the TestClass constructor will be run, resulting in printing
  of
  "Or shall this be executed"
  And then the TestProperty will be assigned as 1 due to new TestClass() { TestProperty = 1 }, making the final
  value for the TestProperty printed by Console.WriteLine(testInstance.TestProperty) to be
  "1"
</code></pre>

<h3>Generic Static Constructors</h3>
If the type on which the static constructor is declared is generic, the static constructor will be called once for each
  unique combination of generic arguments.
<pre><code>
  class Animal<T>
  {
    static Animal()
    {
      Console.WriteLine(typeof(T).FullName);
    }
    public static void Yawn() { }
  }
  Animal< Object>.Yawn();
  Animal< String>.Yawn();
  This will output:
  System.Object
  System.String</code></pre>

<h3>Calling virtual methods in constructor</h3>
<pre><code>
  Unlike C++ in C# you can call a virtual method from class constructor (OK, you can also in C++ but behavior at first is
  surprising). For example:
  abstract class Base
  {
    protected Base()
    {
      _obj = CreateAnother();
    }
    protected virtual AnotherBase CreateAnother()
    {
      return new AnotherBase();
    }
    private readonly AnotherBase _obj;
  }
  sealed class Derived : Base
  {
    public Derived() { }
    protected override AnotherBase CreateAnother()
    {
      return new AnotherDerived();
    }
  }
  var test = new Derived();
  // test._obj is AnotherDerived
  If you come from a C++ background this is surprising, base class constructor already sees derived class virtual
  method table!
  Be careful: derived class may not been fully initialized yet (its constructor will be executed after base class
  constructor) and this technique is dangerous (there is also a StyleCop warning for this). Usually this is regarded as
  bad practice.
</code></pre>
</div>

<h2>Access Modifiers</h2>
<div>

<h3>public</h3>
<pre><code>The public keyword makes a class (including nested classes), property, method or field available to every
  consumer:
  public class Foo()
  {
  public string SomeProperty { get; set; }
  public class Baz
  {
    public int Value { get; set; }
  }
  }
  public class Bar()
  {
    public Bar()
    {
      var myInstance = new Foo();
      var someValue = foo.SomeProperty;
      var myNestedInstance = new Foo.Baz();
      var otherValue = myNestedInstance.Value;
    }
  }</code></pre>

<h3>private</h3>
<pre><code>The private keyword marks properties, methods, fields and nested classes for use inside the class only:
  public class Foo()
  {
  private string someProperty { get; set; }
  private class Baz
  {
  public string Value { get; set; }
  }
  public void Do()
  {
  var baz = new Baz { Value = 42 };
  }
  }
  public class Bar()
  {
  public Bar()
  {
  var myInstance = new Foo();
  // Compile Error - not accessible due to private modifier
  var someValue = foo.someProperty;
  // Compile Error - not accessible due to private modifier
  var baz = new Foo.Baz();
  }
  }
</code></pre>

<h3>protected internal</h3>
<pre><code>The protected internal keyword marks field, methods, properties and nested classes for use inside the same
  assembly or derived classes in another assembly:
  Assembly 1
  public class Foo
  {
    public string MyPublicProperty { get; set; }
    protected internal string MyProtectedInternalProperty { get; set; }
    protected internal class MyProtectedInternalNestedClass
    {
      private string blah;
      public int N { get; set; }
    }
  }
  public class Bar
  {
    void MyMethod1()
    {
      Foo foo = new Foo();
      var myPublicProperty = foo.MyPublicProperty;
      var myProtectedInternalProperty = foo.MyProtectedInternalProperty;
      var myProtectedInternalNestedInstance =
      new Foo.MyProtectedInternalNestedClass();
    }
  }
  Assembly 2
  public class Baz : Foo
  {
    void MyMethod1()
    {
      var myPublicProperty = MyPublicProperty;
      var myProtectedInternalProperty = MyProtectedInternalProperty;
      var thing = new MyProtectedInternalNestedClass();
    }
    void MyMethod2()
  GoalKicker.com – C# Notes for Professionals 165
  {
  Foo foo = new Foo();
    var myPublicProperty = foo.MyPublicProperty;
    // Compile Error
    var myProtectedInternalProperty = foo.MyProtectedInternalProperty;
    // Compile Error
    var myProtectedInternalNestedInstance =
    new Foo.MyProtectedInternalNestedClass();
  }
  }
  public class Qux
  {
    void MyMethod1()
    {
      Baz baz = new Baz();
      var myPublicProperty = baz.MyPublicProperty;
      // Compile Error
      var myProtectedInternalProperty = baz.MyProtectedInternalProperty;
      // Compile Error
      var myProtectedInternalNestedInstance =
      new Baz.MyProtectedInternalNestedClass();
    }
    void MyMethod2()
    {
      Foo foo = new Foo();
      var myPublicProperty = foo.MyPublicProperty;
      //Compile Error
      var myProtectedInternalProperty = foo.MyProtectedInternalProperty;
      // Compile Error
      var myProtectedInternalNestedInstance =
      new Foo.MyProtectedInternalNestedClass();
    }
  }</code></pre>

<h3>internal</h3>
<pre><code>The internal keyword makes a class (including nested classes), property, method or field available to every
  consumer in the same assembly:
  internal class Foo
  {
  internal string SomeProperty {get; set;}
  }
  internal class Bar
  {
  var myInstance = new Foo();
  internal string SomeField = foo.SomeProperty;
  internal class Baz
  {
  private string blah;
  public int N { get; set; }
  }
}
//This can be broken to allow a testing assembly to access the code via adding code to AssemblyInfo.cs file:
using System.Runtime.CompilerServices;
[assembly:InternalsVisibleTo("MyTests")]
</code></pre>

<h3>protected</h3>
<pre><code>The protected keyword marks field, methods properties and nested classes for use inside the same class and
  derived classes only:
  public class Foo()
  {
  protected void SomeFooMethod()
  {
  //do something
  }
  protected class Thing
  {
  private string blah;
  public int N { get; set; }
  }
  }
  public class Bar() : Foo
  {
    private void someBarMethod()
    {
      SomeFooMethod(); // inside derived class
      var thing = new Thing(); // can use nested class
    }
  }
  public class Baz()
  {
    private void someBazMethod()
    {
      var foo = new Foo();
      foo.SomeFooMethod(); //not accessible due to protected modifier
    }
  }
</code></pre>

</div>

<h2>Interfaces</h2>
<div>

<h3>Implementing an interface</h3>
<pre><code>with the keyword interface and a class can 'implement' it by adding: InterfaceName after the class name. A class
  can implement multiple interfaces by separating each interface with a comma.
  : InterfaceName, ISecondInterface
  public interface INoiseMaker
  {
    string MakeNoise();
  }
  public class Cat : INoiseMaker
  {
    public string MakeNoise()
    {
      return "Nyan";
    }
  }
  public class Dog : INoiseMaker
  {
    public string MakeNoise()
    {
      return "Woof";
    }
  }
  Because they implement INoiseMaker, both cat and dog are required to include the string MakeNoise() method
  and will fail to compile without it.</code></pre>

<h3>Explicit interface implementation</h3>
Explicit interface implementation is necessary when you implement multiple interfaces who define a common
method, but different implementations are required depending on which interface is being used to call the method
(note that you don't need explicit implementations if multiple interfaces share the same method and a common
implementation is possible).
<pre><code>
  interface IChauffeur
  {
    string Drive();
  }
  interface IGolfPlayer
  {
    string Drive();
  }
  class GolfingChauffeur : IChauffeur, IGolfPlayer
  {
    public string Drive()
    {
      return "Vroom!";
    }
    string IGolfPlayer.Drive()
    {
      return "Took a swing...";
    }
  }
  GolfingChauffeur obj = new GolfingChauffeur();
  IChauffeur chauffeur = obj;
  IGolfPlayer golfer = obj;
  Console.WriteLine(obj.Drive()); // Vroom!
  Console.WriteLine(chauffeur.Drive()); // Vroom!
  Console.WriteLine(golfer.Drive()); // Took a swing...
                     // The implementation cannot be called from anywhere else except by using the interface:
  public class Golfer : IGolfPlayer
  {
    string IGolfPlayer.Drive()
    {
      return "Swinging hard...";
    }
    public void Swing()
    {
      Drive(); // Compiler error: No such method
    }
  }
  /*
  Due to this, it may be advantageous to put complex implementation code of an explicitly implemented interface in
  a separate, private method.
  An explicit interface implementation can of course only be used for methods that actually exist for that interface:*/
  public class ProGolfer : IGolfPlayer
  {
  string IGolfPlayer.Swear() // Error
  {
  return "The ball is in the pit";
  }
  }
 
</code></pre>
  Similarly, using an explicit interface implementation without declaring that interface on the class causes an error,
  too.
  Hint:
  Implementing interfaces explicitly can also be used to avoid dead code. When a method is no longer needed and
  gets removed from the interface, the compiler will complain about each still existing implementation.
  Note:
  Programmers expect the contract to be the same regardless of the context of the type and explicit implementation
  should not expose different behavior when called. So unlike the example above, IGolfPlayer.Drive and Drive
  should do the same thing when possible.

<h3>Interface Basics</h3>
<pre><code>An Interface's function known as a "contract" of functionality. It means that it declares properties and methods but
  it doesn't implement them.
  So unlike classes Interfaces:
  Can't be instantiated
  Can't have any functionality
  Can only contain methods *(Properties and Events are methods internally)
  Inheriting an interface is called "Implementing"
  You can inherit from 1 class, but you can "Implement" multiple Interfaces
  public interface ICanDoThis
  {
    void TheThingICanDo();
    int SomeValueProperty { get; set; }
  }
  Things to notice:
  The "I" prefix is a naming convention used for interfaces.
  The function body is replaced with a semicolon ";".
  Properties are also allowed because internally they are also methods
  public class MyClass : ICanDoThis
  {
    public void TheThingICanDo()
    {
      // do the thing
    }
    public int SomeValueProperty { get; set; }
    public int SomeValueNotImplemtingAnything { get; set; }
  }
  .
  ICanDoThis obj = new MyClass();
  // ok
  obj.TheThingICanDo();
  // ok
  obj.SomeValueProperty = 5;
  // Error, this member doesn't exist in the interface
  obj.SomeValueNotImplemtingAnything = 5;
  // in order to access the property in the class you must "down cast" it
  ((MyClass)obj).SomeValueNotImplemtingAnything = 5; // ok
  This is especially useful when you're working with UI frameworks such as WinForms or WPF because it's mandatory
  to inherit from a base class to create user control and you loose the ability to create abstraction over different
  control types.An example? Coming up:
  public class MyTextBlock : TextBlock
  {
    public void SetText(string str)
    {
      this.Text = str;
    }
    GoalKicker.com – C# Notes for Professionals 170
  }
  public class MyButton : Button
  {
    public void SetText(string str)
    {
      this.Content = str;
    }
  }
  The problem proposed is that both contain some concept of "Text" but the property names differ.And you can't
  create create a abstract base class because they have a mandatory inheritance to 2 different classes.An interface
  can alleviate that
  public interface ITextControl
  {
    void SetText(string str);
  }
  public class MyTextBlock : TextBlock, ITextControl
  {
    public void SetText(string str)
    {
      this.Text = str;
    }
  }
  public class MyButton : Button, ITextControl
  {
    public void SetText(string str)
    {
      this.Content = str;
    }
    public int Clicks { get; set; }
  }
  Now MyButton and MyTextBlock is interchangeable.
  var controls = new List<ITextControls>{
  new MyTextBlock(),
  new MyButton()
  };
  foreach (var ctrl in controls)
  {
    ctrl.SetText("This text will be applied to both controls despite them being different");
    // Compiler Error, no such member in interface
    ctrl.Clicks = 0;
    // Runtime Error because 1 class is in fact not a button which makes this cast invalid
    ((MyButton)ctrl).Clicks = 0;
    /* the solution is to check the type first.
    This is usually considered bad practice since
    it's a symptom of poor abstraction */
    var button = ctrl as MyButton;
    if (button != null)
      button.Clicks = 0; // no errors
  }
  </code></pre>

<h3>IComparable<T> as an Example of Implementing
  an Interface</h3>
  Interfaces can seem abstract until you seem them in practice. 
  The IComparable and IComparable< T> are great
  examples of why interfaces can be helpful to us.
  Let's say that in a program for a online store, we have a variety of items you can buy. 
  Each item has a name, an ID
  number, and a price.
<pre><code>
  public class Item {
    public string name; // though public variables are generally bad practice,
    public int idNumber; // to keep this example simple we will use them instead
    public decimal price; // of a property.
    // body omitted for brevity
  }
  We have our Items stored inside of a List< Item>, and in our program somewhere, we want to sort our list by ID
  number from smallest to largest. Instead of writing our own sorting algorithm, we can instead use the Sort()
  method that List<T> already has. However, as our Item class is right now, there is no way for the List<T> to
  understand what order to sort the list. Here is where the IComparable interface comes in.
  To correctly implement the CompareTo method, CompareTo should return a positive number if the parameter is "less
  than" the current one, zero if they are equal, and a negative number if the parameter is "greater than".
  Item apple = new Item();
  apple.idNumber = 15;
  Item banana = new Item();
  banana.idNumber = 4;
  Item cow = new Item();
  cow.idNumber = 15;
  Item diamond = new Item();
  diamond.idNumber = 18;
  Console.WriteLine(apple.CompareTo(banana)); // 11
  Console.WriteLine(apple.CompareTo(cow)); // 0
  Console.WriteLine(apple.CompareTo(diamond)); // -3
  Here's the example Item's implementation of the interface:
  public class Item : IComparable< Item> {
    private string name;
    private int idNumber;
    private decimal price;
    public int CompareTo(Item otherItem) {
      return (this.idNumber - otherItem.idNumber);
    }
  // rest of code omitted for brevity
  }
</code></pre>
 
  On a surface level, the CompareTo method in our item simply returns the difference in their ID numbers, but what
  does the above do in practice?
  Now, when we call Sort() on a List< Item> object, the List will automatically call the Item's CompareTo method
  when it needs to determine what order to put objects in. Furthermore, besides List<T>, any other objects that
  need the ability to compare two objects will work with the Item because we have defined the ability for two
  different Items to be compared with one another.
<h3>Implementing multiple interfaces</h3>
<pre><code>public interface IAnimal
  {
    string Name { get; set; }
  }
  public interface INoiseMaker
  {
    string MakeNoise();
  }
  public class Cat : IAnimal, INoiseMaker
  {
    public Cat()
    {
      Name = "Cat";
    }
    public string Name { get; set; }
    public string MakeNoise()
    {
      return "Nyan";
    }
  }</code></pre>

<h3>Why we use interfaces</h3>
An interface is a definition of a contract between the user of the interface and the class that implement it. One way
to think of an interface is as a declaration that an object can perform certain functions.
Let's say that we define an interface IShape to represent different type of shapes, we expect a shape to have an
area, so we will define a method to force the interface implementations to return their area :
<pre><code>
  public interface IShape
  {
    double ComputeArea();
  }
  Let's that we have the following two shapes : a Rectangle and a Circle
    public class Rectangle : IShape
  {
    private double length;
    private double width;
    public Rectangle(double length, double width)
    {
      this.length = length;
      this.width = width;
    }
    public double ComputeArea()
    {
      return length * width;
    }
  }
  public class Circle : IShape
  {
    private double radius;
    public Circle(double radius)
    {
      this.radius = radius;
    }
    public double ComputeArea()
    {
      return Math.Pow(radius, 2.0) * Math.PI;
    }
  }
  // Each one of them have its own definition of its area, but both of them are shapes. 
  // So it's only logical to see them as IShape in our program :
  private static void Main(string[] args)
  {
    var shapes = new List< IShape>() { new Rectangle(5, 10), new Circle(5) };
    ComputeArea(shapes);
    Console.ReadKey();
  }
  private static void ComputeArea(IEnumerable< IShape> shapes)
  {
    foreach (shape in shapes)
    {
      Console.WriteLine("Area: {0:N}, shape.ComputeArea());
      }
  }
  // Output:
  // Area : 50.00
  // Area : 78.54
</code></pre>

<h3>"Hiding" members with Explicit Implementation</h3>
Don't you hate it when interfaces pollute you class with too many members you don't even care about? Well I got a
solution! Explicit Implementations
<pre><code>
  public interface IMessageService {
    void OnMessageRecieve();
    void SendMessage();
    string Result { get; set; }
    int Encoding { get; set; }
    // yadda yadda
  }
//Normally you'd implement the class like this
public class MyObjectWithMessages : IMessageService
{
  public void OnMessageRecieve()
  {
  }
  public void SendMessage()
  {
  }
  public string Result { get; set; }
  public int Encoding { get; set; }
}

Every member is public.
var obj = new MyObjectWithMessages();
// why would i want to call this function?
obj.OnMessageRecieve();
Answer: I don't. So neither should it be declared public but simply declaring the members as private will make the
compiler throw an error
The solution is to use explicit implementation:
public class MyObjectWithMessages : IMessageService{
void IMessageService.OnMessageRecieve() {
}
void IMessageService.SendMessage() {
}
string IMessageService.Result { get; set; }
int IMessageService.Encoding { get; set; }
}

So now you have implemented the members as required and they won't expose any members in as public.
var obj = new MyObjectWithMessages();
/* error member does not exist on type MyObjectWithMessages.
* We've succesfully made it "private" */
obj.OnMessageRecieve();
If you seriously still want to access the member even though is explicitly implement all you have to do is cast the
object to the interface and you good to go.
((IMessageService)obj).OnMessageRecieve();

</code></pre>

</div>

<h2>Static Classes</h2>
<div>

<h3>Static Classes</h3>
<pre><code>The "static" keyword when referring to a class has three effects:
  1. You cannot create an instance of a static class (this even removes the default constructor)
  2. All properties and methods in the class must be static as well.
  3. A static class is a sealed class, meaning it cannot be inherited.
  public static class Foo
  {
    //Notice there is no constructor as this cannot be an instance
    public static int Counter { get; set; }
    public static int GetCount()
    {
      return Counter;
    }
  }
  public class Program
  {
    static void Main(string[] args)
    {
      Foo.Counter++;
      Console.WriteLine(Foo.GetCount()); //this will print 1
                         //var foo1 = new Foo();
                         //this line would break the code as the Foo class does not have a constructor
    }
  }

</code></pre>

<h3>Static class lifetime</h3>
<pre><code>A static class is lazily initialized on member access and lives for the duration of the application domain.
  void Main()
  {
    Console.WriteLine("Static classes are lazily initialized");
    Console.WriteLine("The static constructor is only invoked when the class is first accessed");
    Foo.SayHi();
    Console.WriteLine("Reflecting on a type won't trigger its static .ctor");
    var barType = typeof(Bar);
    Console.WriteLine("However, you can manually trigger it with
  
    System.Runtime.CompilerServices.RuntimeHelpers");
  
    RuntimeHelpers.RunClassConstructor(barType.TypeHandle);
  }
  // Define other methods and classes here
  public static class Foo
  {
    static Foo()
    {
      Console.WriteLine("static Foo.ctor");
    }
    public static void SayHi()
    {
      Console.WriteLine("Foo: Hi");
    }
  }
  public static class Bar
  {
    static Bar()
    {
      Console.WriteLine("static Bar.ctor");
    }
  }
</code></pre>

<h3>Static keyword</h3>
The static keyword means 2 things:
1. This value does not change from object to object but rather changes on a class as a whole
2. Static properties and methods don't require an instance.
<pre><code>public class Foo
  {
    public Foo{
  Counter++;
  NonStaticCounter++;
  }
  public static int Counter { get; set; }
  public int NonStaticCounter { get; set; }
  }
  public class Program
  {
    static void Main(string[] args)
    {
      //Create an instance
      var foo1 = new Foo();
      Console.WriteLine(foo1.NonStaticCounter); //this will print "1"
                            //Notice this next call doesn't access the instance but calls by the class name.
      Console.WriteLine(Foo.Counter); //this will also print "1"
                      //Create a second instance
      var foo2 = new Foo();
      Console.WriteLine(foo2.NonStaticCounter); //this will print "1"
      Console.WriteLine(Foo.Counter); //this will now print "2"
                      //The static property incremented on both instances and can persist for the whole class
    }
  }</code></pre>

</div>
<h2>Singleton Implementation</h2>
<div>

<h3>Statically Initialized Singleton</h3>
<pre><code>public class Singleton
  {
  private readonly static Singleton instance = new Singleton();
  private Singleton() { }
  public static Singleton Instance => instance;
  }
  This implementation is thread-safe because in this case instance object is initialized in the static constructor. The
  CLR already ensures that all static constructors are executed thread-safe.
  Mutating instance is not a thread-safe operation, therefore the readonly attribute guarantees immutability after
  initialization.</code></pre>

<h3>Lazy, thread-safe Singleton (using Lazy<T>)</h3>
<pre><code>.Net 4.0 type Lazy guarantees thread-safe object initialization, so this type could be used to make Singletons.
  public class LazySingleton
  {
    private static readonly Lazy<LazySingleton> _instance =
    new Lazy<LazySingleton>(() => new LazySingleton());
    public static LazySingleton Instance
    {
      get { return _instance.Value; }
    }
    private LazySingleton() { }
  }
  Using Lazy<T> will make sure that the object is only instantiated when it is used somewhere in the calling code.
  A simple usage will be like:
  using System;
  public class Program
  {
    public static void Main()
    {
      var instance = LazySingleton.Instance;
    }
  }</code></pre>

<h3>Lazy, thread-safe Singleton (using Double
  Checked Locking)</h3>
<pre><code>This thread-safe version of a singleton was necessary in the early versions of .NET where static initialization was
  not guaranteed to be thread-safe. In more modern versions of the framework a statically initialized singleton is

  usually preferred because it is very easy to make implementation mistakes in the following pattern.
  public sealed class ThreadSafeSingleton
  {
    private static volatile ThreadSafeSingleton instance;
    private static object lockObject = new Object();
    private ThreadSafeSingleton()
    {
    }
    public static ThreadSafeSingleton Instance
    {
      get
      {
        if (instance == null)
        {
          lock (lockObject)
          {
            if (instance == null)
            {
              instance = new ThreadSafeSingleton();
            }
          }
        }
        return instance;
      }
    }
  }
</code></pre>
Notice that the if (instance == null) check is done twice: once before the lock is acquired, and once afterwards.
This implementation would still be thread-safe even without the first null check. However, that would mean that a
lock would be acquired every time the instance is requested, and that would cause performance to suffer. The first
null check is added so that the lock is not acquired unless it's necessary. The second null check makes sure that
only the first thread to acquire the lock then creates the instance. The other threads will find the instance to be
populated and skip ahead.
<h3>Lazy, thread safe singleton (for .NET 3.5 or
  older, alternate implementation)</h3>
<pre><code>Because in .NET 3.5 and older you don't have Lazy<T> class you use the following pattern:

    This is inspired from Jon Skeet's blog post.
    Because the Nested class is nested and private the instantiation of the singleton instance will not be triggered by
    accessing other members of the Sigleton class (such as a public readonly property, for example).

    public class Singleton
    {
      private Singleton() // prevents public instantiation
      {
      }
      public static Singleton Instance
      {
        get
        {
          return Nested.instance;
        }
      }
      private class Nested
      {
        // Explicit static constructor to tell C# compiler
        // not to mark type as beforefieldinit
        static Nested()
        {
        }
        internal static readonly Singleton instance = new Singleton();
      }
    }
  </code></pre>

</div>

<h2>Dependency Injection</h2>
<div>

<h3>Dependency Injection C# and ASP.NET with Unity</h3>
First why we should use depedency injection in our code ? 
We want to decouple other components from other classes in our program. 
For example we have class AnimalController which have code like this :
<pre><code>
  public class AnimalController()
  {
    private SantaAndHisReindeer _SantaAndHisReindeer = new SantaAndHisReindeer();
    public AnimalController(){
      Console.WriteLine("");
    } 
  }</code></pre>
  We look at this code and we think everything is ok but now our AnimalController is reliant on object
  _SantaAndHisReindeer. Automatically my Controller is bad to testing and reusability of my code will be very hard.
  Very good explanation why we should use Depedency Injection and interfaces here.
  If we want Unity to handle DI, the road to achieve this is very simple :) With NuGet( package manager) we can easily
  import unity to our code.
  in Visual Studio Tools -> NuGet Package Manager -> Manage Packages for Solution -> in search input write
  unity -> choose our project-> click install
  Now two files with nice comments will be created.
  in App-Data folder UnityConfig.cs and UnityMvcActivator.cs
  UnityConfig - in RegisterTypes method, we can see type that will be injection in our constructors.
  <pre><code>
    namespace Vegan.WebUi.App_Start
    {
      public class UnityConfig
      {
        #region Unity Container
        private static Lazy<IUnityContainer> container = new Lazy<IUnityContainer>(() =>
        {
          var container = new UnityContainer();
          RegisterTypes(container);
          return container;
        });
        /// <summary>
        /// Gets the configured Unity container.
        /// </summary>
        public static IUnityContainer GetConfiguredContainer()
        {
          return container.Value;
        }
        #endregion
        /// <summary>Registers the type mappings with the Unity container.</summary>
        /// <param name="container">The unity container to configure.</param>
        /// <remarks>There is no need to register concrete types such as controllers or API controllers
        (unless you want to
    /// change the defaults), as Unity allows resolving a concrete type even if it was not previously
    registered.</remarks>
    public static void RegisterTypes(IUnityContainer container)
        {
          // NOTE: To load from web.config uncomment the line below. Make sure to add a
          Microsoft.Practices.Unity.Configuration to the using statements.
          // container.LoadConfiguration();
          // TODO: Register your types here
          // container.RegisterType<IProductRepository, ProductRepository>();
          container.RegisterType<ISanta, SantaAndHisReindeer>();
        }
      }
    } 
  </code></pre>
  UnityMvcActivator - > also with nice comments which say that this class integrates Unity with ASP.NET
  MVC
<pre><code>void Main()
  {
  }
  
  [assembly:
  WebActivatorEx.PreApplicationStartMethod(typeof(Vegan.WebUi.App_Start.UnityWebActivator), "Start")]
  [assembly:
  WebActivatorEx.ApplicationShutdownMethod(typeof(Vegan.WebUi.App_Start.UnityWebActivator),
  "Shutdown")]
  namespace Vegan.WebUi.App_Start
  {
    /// <summary>Provides the bootstrapping for integrating Unity with ASP.NET MVC.</summary>
    public static class UnityWebActivator
    {
      /// <summary>Integrates Unity when the application starts.</summary>
      public static void Start()
      {
        var container = UnityConfig.GetConfiguredContainer();
        FilterProviders.Providers.Remove(FilterProviders.Providers.OfType<FilterAttributeFilterProvider>().
        First());
        FilterProviders.Providers.Add(new UnityFilterAttributeFilterProvider(container));
        DependencyResolver.SetResolver(new UnityDependencyResolver(container));
        // TODO: Uncomment if you want to use PerRequestLifetimeManager
        //
        Microsoft.Web.Infrastructure.DynamicModuleHelper.DynamicModuleUtility.RegisterModule(typeof(UnityPerR
        equestHttpModule));
      }
      /// <summary>Disposes the Unity container when the application is shut down.</summary>
      public static void Shutdown()
      {
        var container = UnityConfig.GetConfiguredContainer();
        container.Dispose();
      }
    }
  }
  //Now we can decouple our Controller from class SantAndHisReindeer :)
  public class AnimalController()
  {
  private readonly SantaAndHisReindeer _SantaAndHisReindeer;
  public AnimalController(SantaAndHisReindeer SantaAndHisReindeer)
  {
    _SantAndHisReindeer = SantaAndHisReindeer;
  }
  }</code></pre>
  There is one final thing we must do before running our application.
  In Global.asax.cs we must add new line: UnityWebActivator.Start() which will start, configure Unity and register our
  types.
 <pre><code>namespace Vegan.WebUi
  {
    public class MvcApplication : System.Web.HttpApplication
    {
      protected void Application_Start()
      {
        AreaRegistration.RegisterAllAreas();
        FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
        RouteConfig.RegisterRoutes(RouteTable.Routes);
        BundleConfig.RegisterBundles(BundleTable.Bundles);
        UnityWebActivator.Start();
      }
    }
  }</code></pre> 
<h3>Dependency injection using MEF</h3>
<pre><code>
  public interface ILogger
  {
    void Log(string message);
  }
  [Export(typeof(ILogger))]
  [ExportMetadata("Name", "Console")]
  public class ConsoleLogger : ILogger
  {
    public void Log(string message)
    {
      Console.WriteLine(message);
    }
  }
  [Export(typeof(ILogger))]
  [ExportMetadata("Name", "File")]
  public class FileLogger : ILogger
  {
    public void Log(string message)
    {
      //Write the message to file
    }
  }
  public class User
  {
    private readonly ILogger logger;
    public User(ILogger logger)
    {
      this.logger = logger;
    }
    public void LogUser(string message)
    {
      logger.Log(message);
    }
  }
  public interface ILoggerMetaData
  {
    string Name { get; }
  }
  internal class Program
  {
    private CompositionContainer _container;
    [ImportMany]
    private IEnumerable<Lazy<ILogger, ILoggerMetaData>> _loggers;
    private static void Main()
    {
      ComposeLoggers();
      Lazy<ILogger, ILoggerMetaData> loggerNameAndLoggerMapping = _ loggers.First((n) =>
      ((n.Metadata.Name.ToUpper() == "Console"));
      ILogger logger = loggerNameAndLoggerMapping.Value
    var user = new User(logger);
      user.LogUser("user name");
    }
    private void ComposeLoggers()
    {
      //An aggregate catalog that combines multiple catalogs
      var catalog = new AggregateCatalog();
      string loggersDllDirectory = Path.Combine(Utilities.GetApplicationDirectory(), "Loggers");
      if (!Directory.Exists(loggersDllDirectory))
      {
        Directory.CreateDirectory(loggersDllDirectory);
        GoalKicker.com – C# Notes for Professionals 184
  }
      //Adds all the parts found in the same assembly as the PluginManager class
      catalog.Catalogs.Add(new AssemblyCatalog(typeof(Program).Assembly));
      catalog.Catalogs.Add(new DirectoryCatalog(loggersDllDirectory));
      //Create the CompositionContainer with the parts in the catalog
      _container = new CompositionContainer(catalog);
      //Fill the imports of this object
      try
      {
        this._container.ComposeParts(this);
      }
      catch (CompositionException compositionException)
      {
        throw new CompositionException(compositionException.Message);
      }
    }
  }

</code></pre>
<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2>Partial class and methods</h2>
<div>
 Partial classes provides us an option to split classes into multiple parts and in multiple source files. All parts are
combined into one single class during compile time. All parts should contain the keyword partial,should be of the
same accessibility. All parts should be present in the same assembly for it to be included during compile time. 
<h3>Partial classes</h3>
Partial classes provide an ability to split class declaration (usually into separate files).
 A common problem that can
be solved with partial classes is allowing users to modify auto-generated code without fearing that their changes
will be overwritten if the code is regenerated.
 Also multiple developers can work on same class or methods.
<pre><code>namespace PartialClassAndMethods
  {
    public partial class PartialClass
    {
      public void ExampleMethod()
      {
        Console.WriteLine("Method call from the first declaration.");
      }
    }
    public partial class PartialClass
    {
      public void AnotherExampleMethod()
      {
        Console.WriteLine("Method call from the second declaration.");
      }
    }
    class Program
    {
      static void Main(string[] args)
      {
        PartialClass partial = new PartialClass();
        partial.ExampleMethod(); // outputs "Method call from the first declaration."
        partial.AnotherExampleMethod(); // outputs "Method call from the second declaration."
      }
    }
  }</code></pre>

<h3>Partial classes inheriting from a base class</h3>
When inheriting from any base class, only one partial class needs to have the base class specified.
<pre><code>
  // PartialClass1.cs
  public partial class PartialClass : BaseClass {}
  // PartialClass2.cs
  public partial class PartialClass {}
  You can specify the same base class in more than one partial class. It will get flagged as redundant by some IDE
  tools, but it does compile correctly.
  // PartialClass1.cs
  public partial class PartialClass : BaseClass {}
  // PartialClass2.cs
  public partial class PartialClass : BaseClass {} // base class here is redundant
  You cannot specify different base classes in multiple partial classes, it will result in a compiler error.
  // PartialClass1.cs
  public partial class PartialClass : BaseClass {} // compiler error
  // PartialClass2.cs
  public partial class PartialClass : OtherBaseClass {} // compiler error
</code></pre>

<h3>Partial methods</h3>
Partial method consists of the definition in one partial class declaration 
(as a common scenario - in the autogenerated one) and the implementation in another partial class declaration.
<pre><code>namespace PartialClassAndMethods
  {
    public partial class PartialClass // Auto-generated
    {
      partial void PartialMethod();
    }
    public partial class PartialClass // Human-written
    {
      public void PartialMethod()
      {
        Console.WriteLine("Partial method called.");
      }
    }
    class Program
    {
      static void Main(string[] args)
      {
        PartialClass partial = new PartialClass();
        partial.PartialMethod(); // outputs "Partial method called."
      }
    }
  }</code></pre>

</div>

<h2>Object initializers</h2>
<div>

<h3>Simple usage</h3>
Object initializers are handy when you need to create an object and set a couple of properties right away,
 but the available constructors are not sufficient. Say you have a class
<pre><code>
  public class Book
  {
  public string Title { get; set; }
  public string Author { get; set; }
  // the rest of class definition
  }
  // To initialize a new instance of the class with an initializer:
  Book theBook = new Book { Title = "Don Quixote", Author = "Miguel de Cervantes" };
  This is equivalent to
  Book theBook = new Book();
  theBook.Title = "Don Quixote";
  theBook.Author = "Miguel de Cervantes";
</code></pre>

<h3>Usage with non-default constructors</h3>
You can combine object initializers with constructors to initialize types if necessary. Take for example a class
  defined as such:
<pre><code>
  public class Book {
  public string Title { get; set; }
  public string Author { get; set; }
  public Book(int id) {
  //do things
  }
  // the rest of class definition
  }
  var someBook = new Book(16) { Title = "Don Quixote", Author = "Miguel de Cervantes" }

  //This will first instantiate a Book with the Book(int) constructor, then set each property in the initializer. 
  / It is equivalent to:
  var someBook = new Book(16);
  someBook.Title = "Don Quixote";
  someBook.Author = "Miguel de Cervantes";
</code></pre>

<h3>Usage with anonymous types</h3>
  Object initializers are the only way to initialize anonymous types, which are types generated by the compiler.
<pre><code>
  var album = new { Band = "Beatles", Title = "Abbey Road" };
</code></pre>
For that reason object initializers are widely used in LINQ select queries, 
since they provide a convenient way to
specify which parts of a queried object you are interested in.
<pre><code>var albumTitles = from a in albums
  select new
  {
  Title = a.Title,
  Artist = a.Band
  };</code></pre>
</div>

<h2>Methods</h2>
<div>
<h3>Calling a static Method</h3>
<pre><code>// Single argument
  System.Console.WriteLine("Hello World");
  // Multiple arguments
  string name = "User";
  System.Console.WriteLine("Hello, {0}!", name);
  Calling a static method and storing its return value:
  string input = System.Console.ReadLine();
  Calling an instance method:
  int x = 42;
  // The instance method called here is Int32.ToString()
  string xAsString = x.ToString();</code></pre>

<h3>Calling a generic method</h3>
<pre><code>// Assuming a method 'T[] CreateArray<T>(int size)'
  DateTime[] dates = CreateArray<DateTime>(8);</code></pre>

<h3>Anonymous method</h3>
Anonymous methods provide a technique to pass a code block as a delegate parameter.
 They are methods with a body, but no name.
<pre><code>delegate int IntOp(int lhs, int rhs);
  class Program
  {
    static void Main(string[] args)
    {
      // C# 2.0 definition
      IntOp add = delegate (int lhs, int rhs)
      {
        return lhs + rhs;
      };
      // C# 3.0 definition
      IntOp mul = (lhs, rhs) =>
      {
        return lhs * rhs;
      };
      // C# 3.0 definition - shorthand
      IntOp sub = (lhs, rhs) => lhs - rhs;
      // Calling each method
      Console.WriteLine("2 + 3 = " + add(2, 3));
      Console.WriteLine("2 * 3 = " + mul(2, 3));
      Console.WriteLine("2 - 3 = " + sub(2, 3));
    }
  }</code></pre>

<h3>Declaring a Method</h3>
Every method has a unique signature consisting of a accessor (public, private, ...) ,optional modifier (abstract), a
name and if needed method parameters. Note, that the return type is not part of the signature. A method
prototype looks like the following:
AccessModifier OptionalModifier ReturnType MethodName(InputParameters)
{
//Method body
}
AccessModifier can be public, protected, pirvate or by default internal.
OptionalModifier can be static abstract virtual override new or sealed.
ReturnType can be void for no return or can be any type from the basic ones, as int to complex classes.
a Method may have some or no input parameters. to set parameters for a method, you should declare each one
like normal variable declarations (like int a), and for more than one parameter you should use comma between
them (like int a, int b).
Parameters may have default values. for this you should set a value for the parameter (like int a = 0). if a
parameter has a default value, setting the input value is optional.
The following method example returns the sum of two integers:
<pre><code>private int Sum(int a, int b)
  {
  return a + b;
  }</code></pre>

<h3>Parameters and Arguments</h3>
A method can declare any number of parameters (in this example, i, s and o are the parameters):
<pre><code>
  static void DoSomething(int i, string s, object o) {
    Console.WriteLine(String.Format("i={0}, s={1}, o={2}", i, s, o));
  }
</code></pre>
  Parameters can be used to pass values into a method, so that the method can work with them. 
  This can be every kind of work like printing the values, 
  or making modifications to the object referenced by a parameter, or storing the values.
  When you call the method, you need to pass an actual value for every parameter.
   At this point, the values that you actually pass to the method call are called Arguments:
  DoSomething(x, "hello", new object());
<h3>Return Types</h3>
A method can return either nothing (void), or a value of a specified type:
<pre><code>// If you don't want to return a value, use void as return type.
  static void ReturnsNothing() {
    Console.WriteLine("Returns nothing");
  }
  // If you want to return a value, you need to specify its type.
  static string ReturnsHelloWorld() {
    return "Hello World";
  }</code></pre>
  If your method specifies a return value, the method must return a value. You do this using the return statement.
  Once a return statement has been reached, it returns the specified value and any code after it will not be run
  anymore (exceptions are finally blocks, which will still be executed before the method returns).
  If your method returns nothing (void), you can still use the return statement without a value if you want to return
  from the method immediately. At the end of such a method, a return statement would be unnecessary though.
  Examples of valid return statements:
  return;
  return 0;
  return x * 2;
  return Console.ReadLine();
  Throwing an exception can end method execution without returning a value. Also, there are iterator blocks, where
  return values are generated by using the yield keyword, but those are special cases that will not be explained at this
  point.

<h3>Default Parameters</h3>
You can use default parameters if you want to provide the option to leave out parameters:
<pre><code>static void SaySomething(string what = "ehh")
  {
    Console.WriteLine(what);
  }
  static void Main()
  {
    // prints "hello"
    SaySomething("hello");
    // prints "ehh"
    SaySomething(); // The compiler compiles this as if we had typed SaySomething("ehh")
  }</code></pre>
  When you call such a method and omit a parameter for which a default value is provided, 
  the compiler inserts that default value for you.
  Keep in mind that parameters with default values need to be written after parameters without default values.
<pre><code>static void SaySomething(string say, string what = "ehh")
  {
    //Correct
    Console.WriteLine(say + what);
  }
  static void SaySomethingElse(string what = "ehh", string say)
  {
    //Incorrect
    Console.WriteLine(say + what);
  }</code></pre>
  WARNING: Because it works that way, default values can be problematic in some cases. If you change the default
  value of a method parameter and don't recompile all callers of that method, those callers will still use the default
  value that was present when they were compiled, possibly causing inconsistencies
<h3>Method overloading</h3>
Definition : When multiple methods with the same name are declared with different parameters, it is referred to as
method overloading. Method overloading typically represents functions that are identical in their purpose but are
written to accept different data types as their parameters.
Factors affecting
  . Number of Arguments
  . Type of arguments
  . Return Type**
Consider a method named Area that will perform calculation functions, 
which will accepts various arguments and return the result.

Example
<pre><code>
  public string Area(int value1)
  {
    return String.Format("Area of Square is {0}", value1 * value1);
  }
  This method will accepts one argument and return a string, 
  if we call the method with an integer(say 5) the output
  will be "Area of Square is 25".
  
  public double Area(double value1, double value2)
  {
    return value1 * value2;
  }
  
  Similarly if we pass two double values to this method the output will be the product of the two values and are of type double. 
  This can be used of multiplication as well as finding the Area of rectangles
  public double Area(double value1)
  {
    return 3.14 * Math.Pow(value1,2);
  }
</code></pre>
This can be used specially for finding the area of circle, which will accepts a double value(radius) and return
another double value as its Area.
Each of these methods can be called normally without conflict - the compiler will examine the parameters of each
method call to determine which version of Area needs to be used.
<pre><code>string squareArea = Area(2);
  double rectangleArea = Area(32.0, 17.5);
  double circleArea = Area(5.0); // all of these are valid and will compile.

  public string Area(double width, double height) { ... }
  public double Area(double width, double height) { ... }
  // This will NOT compile.

  //If we need to have our class use the same method names that return different values,
  // we can remove the issues of ambiguity by implementing an interface 
  // and explicitly defining its usage.
  public interface IAreaCalculatorString {
    public string Area(double width, double height);
  }
  public class AreaCalculator : IAreaCalculatorString {
    public string IAreaCalculatorString.Area(double width, double height) { ... }
    // Note that the method call now explicitly says it will be used when called through
    // the IAreaCalculatorString interface, allowing us to resolve the ambiguity.
    public double Area(double width, double height) { ... }
</code></pre>

<h3>Access rights</h3>
<pre><code>// static: is callable on a class even when no instance of the class has been created
  public static void MyMethod()
  // virtual: can be called or overridden in an inherited class
  public virtual void MyMethod()
  // internal: access is limited within the current assembly
  internal void MyMethod()
  //private: access is limited only within the same class
  private void MyMethod()
  //public: access right from every class / assembly
  public void MyMethod()
  //protected: access is limited to the containing class or types derived from it
  protected void MyMethod()
  //protected internal: access is limited to the current assembly or types derived from the containing
  class.
  protected internal void MyMethod()</code></pre>


</div>

<h2>Extension Methods</h2>
<div>
-<b>this</b> : The first parameter of an extension method should always be preceded by the this keyword, 
followed by the identifier with which to refer to the "current" instance of the object you are extending
<h3>Extension methods - overview</h3>
Extension methods were introduced in C# 3.0. Extension methods extend and add behavior to existing types
without creating a new derived type, recompiling, or otherwise modifying the original type. They are especially
helpful when you cannot modify the source of a type you are looking to enhance. Extension methods may be created for
system types, types defined by third parties, and types that you have defined yourself. The extension method can
be invoked as though it were a member method of the original type. This allows for Method Chaining used to
implement a Fluent Interface.
An extension method is created by adding a static method to a static class which is distinct from the original type
being extended. The static class holding the extension method is often created for the sole purpose of holding
extension methods.
Extension methods take a special first parameter that designates the original type being extended. This first
parameter is decorated with the keyword this (which constitutes a special and distinct use of this in C#—it should
be understood as different from the use of this which allows referring to members of the current object instance).
In the following example, the original type being extended is the class string. String has been extended by a
method Shorten(), which provides the additional functionality of shortening. The static class StringExtensions
has been created to hold the extension method. The extension method Shorten() shows that it is an extension of
string via the specially marked first parameter. To show that the Shorten() method extends string, the first
parameter is marked with this. Therefore, the full signature of the first parameter is this string text, where
string is the original type being extended and text is the chosen parameter name.

<pre><code>static class StringExtensions
  {
    public static string Shorten(this string text, int length)
    {
      return text.Substring(0, length);
    }
  }
  class Program
  {
    static void Main()
    {
      // This calls method String.ToUpper()
      var myString = "Hello World!".ToUpper();
      // This calls the extension method StringExtensions.Shorten()
      var newString = myString.Shorten(5);
      // It is worth noting that the above call is purely syntactic sugar
      // and the assignment below is functionally equivalent
      var newString2 = StringExtensions.Shorten(myString, 5);
    }
  }</code></pre>
  The object passed as the first argument of an extension method (which is accompanied by the this keyword) is the
  instance the extension method is called upon.
  For example, when this code is executed:

  "some string".Shorten(5);
  
  The values of the arguments are as below:
  text: "some string"
  length: 5
  Note that extension methods are only usable if they are in the same namespace as their definition, if the namespace is
  imported explicitly by the code using the extension method, or if the extension class is namespace-less. The .NET
  framework guidelines recommend putting extension classes in their own namespace. However, this may lead to
  discovery issues.
  This results in no conflicts between the extension methods and the libraries being used, unless namespaces which
  might conflict are explicitly pulled in. For example LINQ Extensions:
<pre><code>using System.Linq; // Allows use of extension methods from the System.Linq namespace
  class Program
  {
    static void Main()
    {
      var ints = new int[] {1, 2, 3, 4};
      // Call Where() extension method from the System.Linq namespace
      var even = ints.Where(x => x % 2 == 0);
    }
  }</code></pre>
  Since C# 6.0, it is also possible to put a using static directive to the class containing the extension methods. For
  example, using static System.Linq.Enumerable;. This makes extension methods from that particular class
  available without bringing other types from the same namespace into scope.
  When a class method with the same signature is available, the compiler prioritizes it over the extension method
  call. For example:
 <pre><code>class Test
  {
    public void Hello()
    {
      Console.WriteLine("From Test");
    }
  }
  static class TestExtensions
  {
    public static void Hello(this Test test)
    {
      Console.WriteLine("From extension method");
    }
  }

  class Program
  {
    static void Main()
    {
      Test t = new Test();
      t.Hello(); // Prints "From Test"
    }
  }
</code></pre> 
Note that if there are two extension functions with the same signature, and one of them is in the same namespace,
then that one will be prioritized. On the other hand, if both of them are accessed by using, then a compile time
error will ensue with the message:
The call is ambiguous between the following methods or properties
Note that the syntactic convenience of calling an extension method via originalTypeInstance.ExtensionMethod()
is an optional convenience. The method can also be called in the traditional manner, so that the special first
parameter is used as a parameter to the method.
I.e., both of the following work:
<pre><code>//Calling as though method belongs to string--it seamlessly extends string
  String s = "Hello World";
  s.Shorten(5);
  //Calling as a traditional static method with two parameters
  StringExtensions.Shorten(s, 5);</code></pre>
<h3>Null checking</h3>
Extension methods are static methods which behave like instance methods. However, unlike what happens when
calling an instance method on a null reference, when an extension method is called with a null reference, it does
not throw a NullReferenceException. This can be quite useful in some scenarios.
For example, consider the following static class:
<pre><code>public static class StringExtensions
  {
    public static string EmptyIfNull(this string text)
    {
      return text ?? String.Empty;
    }
    public static string NullIfEmpty(this string text)
    {
      return String.Empty == text ? null : text;
    }
  }
  string nullString = null;
  string emptyString = nullString.EmptyIfNull();// will return ""
  string anotherNullString = emptyString.NullIfEmpty(); // will return null</code></pre>

<h3>Explicitly using an extension method</h3>
Extension methods can also be used like ordinary static class methods. 
This way of calling an extension method is
more verbose, but is necessary in some cases
<pre><code>static class StringExtensions
  {
    public static string Shorten(this string text, int length)
    {
      return text.Substring(0, length);
    }
  }</code></pre>
  Usage:
 
  <pre><code> var newString = StringExtensions.Shorten("Hello World", 5);</code></pre>
  When to call extension methods as static methods
  There are still scenarios where you would need to use an extension method as a static method:
    . Resolving conflict with a member method. 
      This can happen if a new version of a library introduces a new member method with the same signature. 
      In this case, the member method will be preferred by the compiler.
    . Resolving conflicts with another extension method with the same signature. 
      This can happen if two libraries include similar extension methods and 
      namespaces of both classes with extension methods are used in the same file.
    . Passing extension method as a method group into delegate parameter.
    . Doing your own binding through Reflection.
    . Using the extension method in the Immediate window in Visual Studio.
  Using static
    If a using static directive is used to bring static members of a static class into global scope, extension methods
    are skipped. Example:
    using static OurNamespace.StringExtensions; // refers to class in previous example
    // OK: extension method syntax still works.
    "Hello World".Shorten(5);
    // OK: static method syntax still works.
    OurNamespace.StringExtensions.Shorten("Hello World", 5);
    // Compile time error: extension methods can't be called as static without specifying class.
    Shorten("Hello World", 5);
    If you remove the this modifier from the first argument of the Shorten method, the last line will compile
<h3>Generic Extension Methods</h3>
Just like other methods, extension methods can use generics. For example:
<pre><code>static class Extensions
  {
    public static bool HasMoreThanThreeElements<T>(this IEnumerable<T> enumerable)
    {
      return enumerable.Take(4).Count() > 3;
    }
  }
  // and calling it would be like:
  IEnumerable<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
  var hasMoreThanThreeElements = numbers.HasMoreThanThreeElements();
  
  //Likewise for multiple Type Arguments:
  public static TU GenericExt<T, TU>(this T obj)
    {
      TU ret = default(TU);
      // do some stuff with obj
      return ret;
    }
  //Calling it would be like:
  IEnumerable<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
  var result = numbers.GenericExt<IEnumerable<int>, String>();
  
  // Likewise for multiple Type Arguments:
  public static TU GenericExt<T, TU>(this T obj)
    {
      TU ret = default(TU);
      // do some stuff with obj
      return ret;
    }
  // Calling it would be like:
  IEnumerable<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
  var result = numbers.GenericExt<IEnumerable<int>, String>();\
  //You can also specify type constraints with where :
  public static bool IsDefault<T>(this T obj) where T : struct, IEquatable<T>
  {
    return EqualityComparer<T>.Default.Equals(obj, default(T));
  }
  //Calling code:
  int number = 5;
  var IsDefault = number.IsDefault();
  </code></pre>

<h3>Extension methods can only see public (or
  internal) members of the extended class</h3>
<pre><code>public class SomeClass
  {
    public void DoStuff()
    {
    }
    protected void DoMagic()
    {
    }
  }
  public static class SomeClassExtensions
  {
    public static void DoStuffWrapper(this SomeClass someInstance)
    {
      someInstance.DoStuff(); // ok
    }
    public static void DoMagicWrapper(this SomeClass someInstance)
    {
      someInstance.DoMagic(); // compilation error
    }
  }</code></pre>
  Extension methods are just a syntactic sugar, and are not actually members of the class they extend. This means
  that they cannot break encapsulation—they only have access to public (or when implemented in the same
  assembly, internal) fields, properties and methods.
<h3>Extension methods for chaining</h3>

When an extension method returns a value that has the same type as its this argument, it can be used to "chain"
one or more method calls with a compatible signature. This can be useful for sealed and/or primitive types, and
allows the creation of so-called "fluent" APIs if the method names read like natural human language.
<pre><code>void Main()
  {
    int result = 5.Increment().Decrement().Increment();
    // result is now 6
  }
  public static class IntExtensions
  {
    public static int Increment(this int number)
    {
      return ++number;
    }
    public static int Decrement(this int number)
    {
      return --number;
    }
  }
//Or like this
void Main()
{
  int[] ints = new[] { 1, 2, 3, 4, 5, 6 };
  int[] a = ints.WhereEven();
  //a is { 2, 4, 6 };
  int[] b = ints.WhereEven().WhereGreaterThan(2);
  //b is { 4, 6 };
}
public static class IntArrayExtensions
{
  public static int[] WhereEven(this int[] array)
  {
    //Enumerable.* extension methods use a fluent approach
    return array.Where(i => (i % 2) == 0).ToArray();
  }
  public static int[] WhereGreaterThan(this int[] array, int value)
  {
    return array.Where(i => i > value).ToArray();
  }
}
</code></pre>

<h3>Extension methods with Enumeration</h3>
Extension methods are useful for adding functionality to enumerations.
One common use is to implement a conversion method
<pre><code>public enum YesNo
  {
    Yes,
    No,
  }
  public static class EnumExtentions
  {
    public static bool ToBool(this YesNo yn)
    {
      return yn == YesNo.Yes;
    }
    public static YesNo ToYesNo(this bool yn)
    {
      return yn ? YesNo.Yes : YesNo.No;
    }
  }
  // Now you can quickly convert your enum value to a different type.In this case a bool.
  bool yesNoBool = YesNo.Yes.ToBool(); // yesNoBool == true
  YesNo yesNoEnum = false.ToYesNo(); // yesNoEnum == YesNo.No
  // Alternatively extension methods can be used to add property like methods.
  public enum Element
  {
    Hydrogen,
    Helium,
    Lithium,
    Beryllium,
    Boron,
    Carbon,
    Nitrogen,
    Oxygen
    //Etc
  }
  public static class ElementExtensions
  {
    public static double AtomicMass(this Element element)
    {
      switch (element)
      {
        case Element.Hydrogen: return 1.00794;
        case Element.Helium: return 4.002602;
        case Element.Lithium: return 6.941;
        case Element.Beryllium: return 9.012182;
        case Element.Boron: return 10.811;
        case Element.Carbon: return 12.0107;
        case Element.Nitrogen: return 14.0067;
        case Element.Oxygen: return 15.9994;
          //Etc
      }
      return double.Nan;
    }
  }
  var massWater = 2 * Element.Hydrogen.AtomicMass() + Element.Oxygen.AtomicMass();
</code></pre>

<h3>Extension methods dispatch based on static</h3>
<pre><code>The static (compile-time) type is used rather than the dynamic(run - time type) to match parameters.
  public class Base
  {
    public virtual string GetName()
    {
      return "Base";
    }
  }
  public class Derived : Base
  {
    public override string GetName()
    {
      return "Derived";
    }
  }
  public static class Extensions
  {
    public static string GetNameByExtension(this Base item)
    {
      return "Base";
    }
    public static string GetNameByExtension(this Derived item)
    {
      return "Derived";
    }
  }
  public static class Program
  {
    public static void Main()
    {
      Derived derived = new Derived();
      Base @base = derived;
      // Use the instance method "GetName"
      Console.WriteLine(derived.GetName()); // Prints "Derived"
      Console.WriteLine(@base.GetName()); // Prints "Derived"
                        // Use the static extension method "GetNameByExtension"
      Console.WriteLine(derived.GetNameByExtension()); // Prints "Derived"
      Console.WriteLine(@base.GetNameByExtension()); // Prints "Base"
    }
  }
  //Also the dispatch based on static type does not allow an extension method to be called on a dynamic object:
  public class Person
  {
    public string Name { get; set; }
  }
  public static class ExtenionPerson
  {
    public static string GetPersonName(this Person person)
    {
      return person.Name;
    }
  }
  dynamic person = new Person { Name = "Jon" };
  var name = person.GetPersonName(); // RuntimeBinderException is thrown
</code></pre>

<h3>Extension methods on Interfaces</h3>
One useful feature of extension methods is that you can create common methods for an interface.
 Normally an interface cannot have shared implementations, but with extension methods they can
<pre><code>public interface IVehicle
  {
    int MilesDriven { get; set; }
  }
  public static class Extensions
  {
    public static int FeetDriven(this IVehicle vehicle)
    {
      return vehicle.MilesDriven * 5028;
    }
  }</code></pre>
  In this example, the method FeetDriven can be used on any IVehicle. 
  This logic in this method would apply to all
  IVehicles, so it can be done this way so that there doesn't have to be a FeetDriven in the IVehicle definition
  which would be implemented the same way for all children.
 <h3>Extension methods in combination with interfaces</h3>
 It is very convenient to use extension methods with interfaces as implementation can be stored outside of class and
 all it takes to add some functionality to class is to decorate class with interface.
<pre><code>{
  string Do()
}
public static class ExtensionMethods
{
  public static string DoWith(this IInterface obj)
  {
    //does something with IInterface instance
  }
}
public class Classy : IInterface
{
  // this is a wrapper method; you could also call DoWith() on a Classy instance directly,
  // provided you import the namespace containing the extension method
  public Do()
  {
    return this.DoWith();
  }
}
// use like:
var classy = new Classy();
classy.Do(); // will call the extension
classy.DoWith(); // Classy implements IInterface so it can also be called this way
</code></pre> 
<h3>Extension methods aren't supported by  dynamic code</h3>
<pre><code>
  class Program
  {
    static void Main()
    {
      dynamic dynamicObject = new ExpandoObject();
      string awesomeString = "Awesome";
      // Prints True
      Console.WriteLine(awesomeString.IsThisAwesome());
      dynamicObject.StringValue = awesomeString;
      // Prints True
      Console.WriteLine(StringExtensions.IsThisAwesome(dynamicObject.StringValue));
      // No compile time error or warning, but on runtime throws RuntimeBinderException
      Console.WriteLine(dynamicObject.StringValue.IsThisAwesome());
    }
  }
  static class StringExtensions
  {
    public static bool IsThisAwesome(this string value)
    {
      return value.Equals("Awesome");
    }
  }
</code></pre>

<h3>Extensions and interfaces together enable DRY code and mixin-like functionality</h3>
Extension methods enable you to simplify your interface definitions by only including core required functionality in
the interface itself and allowing you to define convenience methods and overloads as extension methods.
Interfaces with fewer methods are easier to implement in new classes. Keeping overloads as extensions rather than
including them in the interface directly saves you from copying boilerplate code into every implementation, helping
you keep your code DRY. This in fact is similar to the mixin pattern which C# does not support.
System.Linq.Enumerable’s extensions to IEnumerable< T> is a great example of this. IEnumerable<T> only requires
the implementing class to implement two methods: generic and non-generic GetEnumerator(). But
System.Linq.Enumerable provides countless useful utilities as extensions enabling concise and clear consumption
of IEnumerable< T>.
The following is a very simple interface with convenience overloads provided as extensions.
<pre><code>public interface ITimeFormatter
  {
    string Format(TimeSpan span);
  }
  public static class TimeFormatter
  {
    // Provide an overload to *all* implementers of ITimeFormatter.
    public static string Format(
    this ITimeFormatter formatter,
    int millisecondsSpan)
    => formatter.Format(TimeSpan.FromMilliseconds(millisecondsSpan));
  }
  // Implementations only need to provide one method. Very easy to
  // write additional implementations.
  {
    public string Format(TimeSpan span)
    {
      return $"{(int)span.TotalSeconds}s";
    }
  }
  class Program
  {
    static void Main(string[] args)
    {
      var formatter = new SecondsTimeFormatter();
      // Callers get two method overloads!
      Console.WriteLine($"4500ms is rougly {formatter.Format(4500)}");
      var span = TimeSpan.FromSeconds(5);
      Console.WriteLine($"{span} is formatted as {formatter.Format(span)}");
    }
  }</code></pre>

<h3>IList<T> Extension Method Example: Comparing 2 Lists</h3>
  You can use the following extension method for comparing the contents of two IList< T > instances of the same
  type.
  By default the items are compared based on their order within the list and the items themselves, passing false to
  the isOrdered parameter will compare only the items themselves regardless of their order.
  For this method to work, the generic type (T) must override both Equals and GetHashCode methods.
  Usage:
<pre><code>
  List< string> list1 = new List< string> {"a1", "a2", null, "a3"};
  List< string> list2 = new List< string> {"a1", "a2", "a3", null};
  list1.Compare(list2);//this gives false
  list1.Compare(list2, false);//this gives true. they are equal when the order is disregarded</code></pre>

Method:
<pre><code>
  public static bool Compare<T>(this IList<T> list1, IList<T> list2, bool isOrdered = true)
    {
      if (list1 == null && list2 == null)
        return true;
      if (list1 == null || list2 == null || list1.Count != list2.Count)
        return false;
      if (isOrdered)
      {
        for (int i = 0; i < list2.Count; i++)
        {
          var l1 = list1[i];
          var l2 = list2[i];
          if (
          (l1 == null && l2 != null) ||
          (l1 != null && l2 == null) ||
          (!l1.Equals(l2)))
          {
            return false;
          }
        }
        return true;
      }
      else
      {
        List<T> list2Copy = new List<T>(list2);
        //Can be done with Dictionary without O(n^2)
        for (int i = 0; i < list1.Count; i++)
        {
          if (!list2Copy.Remove(list1[i]))
            return false;
        }
        return true;
      }
    }
</code></pre>


<h3>Extension methods as strongly typed wrappers</h3>
Extension methods can be used for writing strongly typed wrappers for dictionary-like objects. 
For example a cache,
HttpContext.Items at cetera...
<pre><code>
  public static class CacheExtensions
  {
    public static void SetUserInfo(this Cache cache, UserInfo data) =>
       cache["UserInfo"] = data;
    public static UserInfo GetUserInfo(this Cache cache) =>
       cache["UserInfo"] as UserInfo;
  }
</code></pre>
This approach removes the need of using string literals as keys all over the codebase as well as the need of casting
to the required type during the read operation. 
Overall it creates a more secure, strongly typed way of interacting
with such loosely typed objects as Dictionaries.
<h3>Using Extension methods to create beautiful mapper classes</h3>
We can create a better mapper classes with extension methods, Suppose if i have some DTO classes like
<pre><code>class UserDTO
  {
    public AddressDTO Address { get; set; }
  }
  public class AddressDTO
  {
    public string Name { get; set; }
  }
  // and i need to map to corresponding view model classes
  public class UserViewModel
  {
    public AddressViewModel Address { get; set; }
  }

  public class AddressViewModel
  {
    public string Name { get; set; }
  }
  then I can create my mapper class like below
  public static class ViewModelMapper
  {
    public static UserViewModel ToViewModel(this UserDTO user)
    {
      return user == null ?
      null :
      new UserViewModel()
      {
        Address = user.Address.ToViewModel()
    // Job = user.Job.ToViewModel(),
    // Contact = user.Contact.ToViewModel() .. and so on
  };
    }
    public static AddressViewModel ToViewModel(this AddressDTO userAddr)
    {
      return userAddr == null ?
      null :
      new AddressViewModel()
      {
        Name = userAddr.Name
      };
    }
  }
  Then finally i can invoke my mapper like below
  UserDTO userDTOObj = new UserDTO()
  {
    Address = new AddressDTO()
    {
      Name = "Address of the user"
    }
  };
  UserViewModel user = userDTOObj.ToViewModel(); // My DTO mapped to Viewmodel
  The beauty here is all the mapping method have a common name(ToViewModel) and we can reuse it several ways
</code></pre>

<h3>Using Extension methods to build new collection types (e.g. DictList)</h3>
<pre><code>
  You can create extension methods to improve usability for nested collections like a Dictionary with a List < T >
  value.
  Consider the following extension methods:
  public static class DictListExtensions
  {
    public static void Add< TKey, TValue, TCollection>(this Dictionary< TKey, TCollection> dict, TKey
    key, TValue value)
    where TCollection : ICollection< TValue>, new()
    {
      TCollection list;
      if (!dict.TryGetValue(key, out list))
      {
        list = new TCollection();
        dict.Add(key, list);
      }
      list.Add(value);
    }
    public static bool Remove< TKey, TValue, TCollection>(this Dictionary< TKey, TCollection> dict,
    TKey key, TValue value)
    where TCollection : ICollection< TValue>
    {
      TCollection list;
      if (!dict.TryGetValue(key, out list))
      {
        return false;
      }
      var ret = list.Remove(value);
      if (list.Count == 0)
      {
        dict.Remove(key);
      }
      return ret;
    }
  }
  you can use the extension methods as follows:
  var dictList = new Dictionary< string, List< int>>();
  dictList.Add("example", 5);
  dictList.Add("example", 10);
  dictList.Add("example", 15);
  Console.WriteLine(String.Join(", ", dictList["example"])); // 5, 10, 15
  dictList.Remove("example", 5);
  dictList.Remove("example", 10);
  Console.WriteLine(String.Join(", ", dictList["example"])); // 15
  dictList.Remove("example", 15);
  Console.WriteLine(dictList.ContainsKey("example")); // False
</code></pre>

<h3>Extension methods for handling special cases</h3>
Extension methods can be used to "hide" processing of inelegant business rules that would otherwise require
cluttering up a calling function with if/then statements. This is similar to and analogous to handling nulls with
extension methods. For example,
<pre><code>public static class CakeExtensions
  {
    public static Cake EnsureTrueCake(this Cake cake)
    {
      //If the cake is a lie, substitute a cake from grandma, whose cakes aren't as tasty but are
      //known never to be lies.If the cake isn't a lie, don't do anything and return it.
  return CakeVerificationService.IsCakeLie(cake) ? GrandmasKitchen.Get1950sCake() : cake;
    }
  }
  Cake myCake = Bakery.GetNextCake().EnsureTrueCake();
  myMouth.Eat(myCake);//Eat the cake, confident that it is not a lie.</code></pre>

<h3>Using Extension methods with Static methods and Callbacks</h3>
Consider using Extension Methods as Functions which wrap other code, here's a great example that uses both a
static method and and extension method to wrap the Try Catch construct. Make your code Bullet Proof...
<pre><code>
  namespace Samples
  {
    /// <summary>
    /// Wraps a try catch statement as a static helper which uses
    /// Extension methods for the exception
    /// </summary>
    public static class Bullet
    {
      /// <summary>
      /// Wrapper for Try Catch Statement
      /// </summary>
      /// <param name="code">Call back for code</param>
      /// <param name="error">Already handled and logged exception</param>
      public static void Proof(Action code, Action<Exception> error)
      {
        try
        {
          code();
        }
        catch (Exception iox)
        {
          //extension method used here
          iox.Log("BP2200-ERR-Unexpected Error");
          //callback, exception already handled and logged
          error(iox);
        }
      }
      /// <summary>
      /// Example of a logging method helper, this is the extension method
      /// </summary>
      /// <param name="error">The Exception to log</param>
      /// <param name="messageID">A unique error ID header</param>
      public static void Log(this Exception error, string messageID)
      {
        Trace.WriteLine(messageID);
        Trace.WriteLine(error.Message);
        Trace.WriteLine(error.StackTrace);
        Trace.WriteLine("");
      }
    }
    /// <summary>
    /// Shows how to use both the wrapper and extension methods.
    /// </summary>
  public class UseBulletProofing
  {
  public UseBulletProofing()
    {
      var ok = false;
      var result = DoSomething();
      if (!result.Contains("ERR"))
      {
        ok = true;
        DoSomethingElse();
      }
    }
    /// <summary>
    /// How to use Bullet Proofing in your code.
    /// </summary>
    /// <returns>A string</returns>
    public string DoSomething()
    {
      string result = string.Empty;
      //Note that the Bullet.Proof method forces this construct.
      Bullet.Proof(() =>
      {
    //this is the code callback
    result = "DST5900-INF-No Exceptions in this code";
      }, error =>
      {
    //error is the already logged and handled exception
    //determine the base result
    result = "DTS6200-ERR-An exception happened look at console log";
        if (error.Message.Contains("SomeMarker"))
        {
      //filter the result for Something within the exception message
      result = "DST6500-ERR-Some marker was found in the exception";
        }
      });
      return result;
    }
    /// <summary>
    /// Next step in workflow
    /// </summary>
    public void DoSomethingElse()
    {
      //Only called if no exception was thrown before
    }
  }
  }
</code></pre>


</div>

<h2>Named Arguments</h2>
<div>


<h3>Argument order is not necessary</h3>
You can place named arguments in any order you want.
Sample Method:
<pre><code>
  public static string Sample(string left, string right)
  {
    return string.Join("-",left,right);
  }
  //Call Sample:
  Console.WriteLine (Sample(left:"A",right:"B"));
  Console.WriteLine (Sample(right:"A",left:"B"));
  /*Results:
  A-B
  B-A*/
</code></pre>

<h3>Named arguments and optional parameters</h3>
<pre><code>You can combine named arguments with optional parameters.
  Let see this method:
  public sealed class SmsUtil
  {
    public static bool SendMessage(string from, string to, string message, int retryCount = 5,
    object attachment = null)
    {
      // Some code
    }
  }
  When you want to call this method without set retryCount argument:
  var result = SmsUtil.SendMessage(
  from: "Cihan",
  to: "Yakar",
  message: "Hello there!",
  attachment: new object());</code></pre>

<h3>Named Arguments can make your code more
  clear</h3>
<pre><code>Consider this simple class:
  class SmsUtil
  {
    public bool SendMessage(string from, string to, string message, int retryCount, object
    attachment)
    {
      // Some code
    }
  }
  Before C# 3.0 it was:
  var result = SmsUtil.SendMessage("Mehran", "Maryam", "Hello there!", 12, null);
  you can make this method call even more clear with named arguments:
  var result = SmsUtil.SendMessage(
  from: "Mehran",
  to: "Maryam",
  message "Hello there!",
  retryCount: 12,
  attachment: null);</code></pre>
</div>

<h2>Named and Optional Arguments</h2>
<div>

<h3>Optional Arguments</h3> 
 Consider preceding is our function definition with optional arguments.
<pre><code>
  private static double FindAreaWithOptional(int length, int width = 56)
  {
    try
    {
      return (length * width);
    }
    catch (Exception)
    {
      throw new NotImplementedException();
    }
  }
  //Here we have set the value for width as optional and gave value as 56.
  //If you note, the IntelliSense itself shows you the optional argument as shown in the below image.
  Console.WriteLine("Area with Optional Argument : ");
  area = FindAreaWithOptional(120);
  Console.WriteLine(area);
  Console.Read();
</code></pre>
 Note that we did not get any error while compiling and it will give you an output as follows.
  <cl>Area with optional arguent:
    6720
  </cl>
  Using Optional Attribute.
  Another way of implementing the optional argument is by using the [Optional] keyword. If you do not pass the
  value for the optional argument, the default value of that datatype is assigned to that argument. The Optional
  keyword is present in “Runtime.InteropServices” namespace.
 <pre><code>private static double FindAreaWithOptional(int length, [Optional] int width)
  {
    try
    {
      return (length * width);
    }
    catch (Exception)
    {
      throw new NotImplementedException();
    }
  }
  area = FindAreaWithOptional(120); //area=0
  And when we call the function, we get 0 because the second argument is not passed and the default value of int is 0
  and so the product is 0.</code></pre> 
<h3>Named Arguments</h3>
<pre><code>Consider following is our function call.
  FindArea(120, 56);
  In this our first argument is length(ie 120) and second argument is width(ie 56). And we are calculating the area by
  that function.And following is the function definition.
  private static double FindArea(int length, int width)
  {
    try
    {
      return (length * width);
    }
    catch (Exception)
    {
      throw new NotImplementedException();
    }
  }
  So in the first function call, we just passed the arguments by its position.Right ?
  double area;
  Console.WriteLine("Area with positioned argument is: ");
  area = FindArea(120, 56);
  Console.WriteLine(area);
  Console.Read();
  If you run this, you will get an output as follows.
  GoalKicker.com – C# Notes for Professionals 215
  Now here it comes the features of a named arguments.Please see the preceding function call.
  Console.WriteLine("Area with Named argument is: ");
  area = FindArea(length: 120, width: 56);
  Console.WriteLine(area);
  Console.Read();
  Here we are giving the named arguments in the method call.
  area = FindArea(length: 120, width: 56);
  Now if you run this program, you will get the same result.We can give the names vice versa in the method call if we
  are using the named arguments.
  Console.WriteLine("Area with Named argument vice versa is: ");
  area = FindArea(width: 120, length: 56);
  Console.WriteLine(area);
  Console.Read();
  One of the important use of a named argument is, when you use this in your program it improves the readability of
  your code.It simply says what your argument is meant to be, or what it is?.
  You can give the positional arguments too.That means, a combination of both positional argument and named
  argument.
  Console.WriteLine("Area with Named argument Positional Argument : ");
  area = FindArea(120, width: 56);
  Console.WriteLine(area);
  Console.Read();
  In the above example we passed 120 as the length and 56 as a named argument for the parameter width.
  There are some limitations too.We will discuss the limitation of a named arguments now.
  Limitation of using a Named Argument
  Named argument specification must appear after all fixed arguments have been specified.
  
  If you use a named argument before a fixed argument you will get a compile time error as follows.
  Named argument specification must appear after all fixed arguments have been specified
  </code></pre>

</div>

<h2>Data Annotation</h2>
<div>

<h3>Data Annotation Basics</h3>
<pre><code>Data annotations are a way of adding more contextual information to classes or members of a class. There are
  three main categories of annotations:
  Validation Attributes: add validation criteria to data
  Display Attributes: specify how the data should be displayed to the user
  Modelling Attributes: add information on usage and relationship with other classes
  Usage
  Here is an example where two ValidationAttribute and one DisplayAttribute are used:
  class Kid
  {
    [Range(0, 18)] // The age cannot be over 18 and cannot be negative
    public int Age { get; set; }
    [StringLength(MaximumLength = 50, MinimumLength = 3)] // The name cannot be under 3 chars or
    more than 50 chars
  public string Name { get; set; }
    [DataType(DataType.Date)] // The birthday will be displayed as a date only (without the time)
    public DateTime Birthday { get; set; }
  }
  Data annotations are mostly used in frameworks such as ASP.NET.For example, in ASP.NET MVC, when a model is
  received by a controller method, ModelState.IsValid() can be used to tell if the received model respects all its
  ValidationAttribute.DisplayAttribute is also used in ASP.NET MVC to determine how to display values on a web
  page.</code></pre>

<h3>Creating a custom validation attribute</h3>
<pre><code>Custom validation attributes can be created by deriving from the ValidationAttribute base class, then overriding
  virtual methods as needed.
  [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
  public class NotABananaAttribute : ValidationAttribute
  {
    public override bool IsValid(object value)
    {
      var inputValue = value as string;
      var isValid = true;
      if (!string.IsNullOrEmpty(inputValue))
      {
        isValid = inputValue.ToUpperInvariant() != "BANANA";
      }
      return isValid;
    }
  }
  This attribute can then be used like this:
  public class Model
  {
    [NotABanana(ErrorMessage = "Bananas are not allowed.")]
    public string FavoriteFruit { get; set; }
  }</code></pre>

<h3>Manually Execute Validation Attributes</h3>
<pre><code>Most of the times, validation attributes are use inside frameworks (such as ASP.NET). Those frameworks take care
  of executing the validation attributes. But what if you want to execute validation attributes manually? Just use the
  Validator class (no reflection needed).
  Validation Context
  Any validation needs a context to give some information about what is being validated. This can include various
  information such as the object to be validated, some properties, the name to display in the error message, etc.
  ValidationContext vc = new ValidationContext(objectToValidate); // The simplest form of validation
  context. It contains only a reference to the object being validated.
  Once the context is created, there are multiple ways of doing validation.
  
  // Validate an Object and All of its Properties
  ICollection< ValidationResult> results = new List< ValidationResult>(); // Will contain the results
  of the validation
  bool isValid = Validator.TryValidateObject(objectToValidate, vc, results, true); // Validates the
  object and its properties using the previously created context.
  // The variable isValid will be true if everything is valid
  // The results variable contains the results of the validation
  
  // Validate a Property of an Object
  ICollection< ValidationResult> results = new List< ValidationResult>(); // Will contain the results
  of the validation
  bool isValid = Validator.TryValidatePropery(objectToValidate.PropertyToValidate, vc, results,
  true); // Validates the property using the previously created context.
  // The variable isValid will be true if everything is valid
  // The results variable contains the results of the validation</code></pre>

<h3>Validation Attributes</h3>
Validation attributes are used to enforce various validation rules in a declarative fashion on classes or class
members. All validation attributes derive from the ValidationAttribute base class.
Example: RequiredAttribute
When validated through the ValidationAttribute.Validate method, this attribute will return an error if the Name
property is null or contains only whitespace
<pre><code>{
  [Required(ErrorMessage = "Please provide a name.")]
  public string Name { get; set; }
}
Example: StringLengthAttribute
The StringLengthAttribute validates if a string is less than the maximum length of a string.It can optionally
specify a minimum length.Both values are inclusive.
public class ContactModel
{
  [StringLength(20, MinimumLength = 5, ErrorMessage = "A name must be between five and twenty
  characters.")]
  public string Name { get; set; }
}
Example: RangeAttribute
The RangeAttribute gives the maximum and minimum value for a numeric field.
public class Model
{
  [Range(0.01, 100.00, ErrorMessage = "Price must be between 0.01 and 100.00")]
  public decimal Price { get; set; }
}
Example: CustomValidationAttribute
The CustomValidationAttribute class allows a custom static method to be invoked for validation. The custom
method must be static ValidationResult[MethodName] (object input).
public class Model
{
  [CustomValidation(typeof(MyCustomValidation), "IsNotAnApple")]
  public string FavoriteFruit { get; set; }
}
Method declaration:
public static class MyCustomValidation
{
  public static ValidationResult IsNotAnApple(object input)
  {
    var result = ValidationResult.Success;
    if (input?.ToString()?.ToUpperInvariant() == "APPLE")
    {
      result = new ValidationResult("Apples are not allowed.");
    }
    return result;
  }
}
</code></pre>
<h3>EditableAttribute (data modeling attribute)</h3>
<pre><code>EditableAttribute sets whether users should be able to change the value of the class property.
  public class Employee
  {
    [Editable(false)]
    public string FirstName { get; set; }
  }
  Simple usage example in XAML application
  <Window x:Class= "WpfApplication.MainWindow"
  xmlns= "http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x= "http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:wpfApplication= "clr-namespace:WpfApplication"
  Height= "70" Width= "360" Title= "Display name example" >
  < Window.Resources >
  < wpfApplication:EditableConverter x:Key= "EditableConverter" />
  </ Window.Resources >
  < StackPanel Margin= "5" >
  < !--TextBox Text (FirstName property value) -->
  < !--TextBox IsEnabled(Editable attribute)-- >
  < TextBox Text = "{Binding Employee.FirstName, Mode=TwoWay,
  UpdateSourceTrigger = PropertyChanged}"
  IsEnabled = "{Binding Employee, Converter={StaticResource EditableConverter},
  ConverterParameter = FirstName}"/>
    </ StackPanel >
    </ Window >
  namespace WpfApplication
  {
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
      private Employee _employee = new Employee() { FirstName = "This is not editable" };
      public MainWindow()
      {
        InitializeComponent();
        DataContext = this;
      }
      public Employee Employee
      {
        get { return _employee; }
        set { _employee = value; }
      }
    }
  }

  namespace WpfApplication
  {
    public class EditableConverter : IValueConverter
    {
      public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
      {
        // return editable attribute's value for given instance property,
        // defaults to true if not found
        var attribute = value.GetType()
        .GetProperty(parameter.ToString())
        .GetCustomAttributes(false)
        .OfType<EditableAttribute>()
        .FirstOrDefault();
        return attribute != null ? attribute.AllowEdit : true;
      }
      public object ConvertBack(object value, Type targetType, object parameter, CultureInfo
      culture)
      {
        throw new NotImplementedException();
      }
    }
  }</code></pre>
</div>

<h2>Keywords</h2>
<div>
<h3>as</h3>
The as keyword is an operator similar to a cast. If a cast is not possible, using as produces null rather than
resulting in an InvalidCastException.
expression as type is equivalent to expression is type ? (type)expression : (type)null with the caveat that
as is only valid on reference conversions, nullable conversions, and boxing conversions. User-defined conversions
are not supported; a regular cast must be used instead.
For the expansion above, the compiler generates code such that expression will only be evaluated once and use
single dynamic type check (unlike the two in the sample above).
as can be useful when expecting an argument to facilitate several types. Specifically it grants the user multiple
options - rather than checking every possibility with is before casting, or just casting and catching exceptions. It is
best practice to use 'as' when casting/checking an object which will cause only one unboxing penalty. Using is to
check, then casting will cause two unboxing penalties.
If an argument is expected to be an instance of a specific type, a regular cast is preferred as its purpose is more
clear to the reader.
Because a call to as may produce null, always check the result to avoid a NullReferenceException.
<pre><code>Example usage
  object something = "Hello";
  Console.WriteLine(something as string); //Hello
  Console.Writeline(something as Nullable<int>); //null
  Console.WriteLine(something as int?); //null
                      //This does NOT compile:
                      //destination type must be a reference type (or a nullable value type)
  Console.WriteLine(something as int);
  Live Demo on.NET Fiddle
  Equivalent example without using as:
  Console.WriteLine(something is string ? (string)something : (string)null);
  This is useful when overriding the Equals function in custom classes.
  class MyCustomClass
  {
    public override bool Equals(object obj)
    {
      MyCustomClass customObject = obj as MyCustomClass;
      // if it is null it may be really null
      // or it may be of a different type
      if (Object.ReferenceEquals(null, customObject))
      {
        // If it is null then it is not equal to this instance.
        return false;
      }
      // Other equality controls specific to class
    }
  }</code></pre>

<h3>goto</h3>
<pre><code>goto can be used to jump to a specific line inside the code, specified by a label.
  goto as a:
  Label:
  void InfiniteHello()
  {
  sayHello:
    Console.WriteLine("Hello!");
    goto sayHello;
  }
  Live Demo on.NET Fiddle
  Case statement:
  enum Permissions { Read, Write };
  switch (GetRequestedPermission())
  {
    case Permissions.Read:
      GrantReadAccess();
      break;
    case Permissions.Write:
      GrantWriteAccess();
      goto case Permissions.Read; //People with write access also get read
  }
  Live Demo on.NET Fiddle
  This is particularly useful in executing multiple behaviors in a switch statement, as C# does not support fall-through
  case blocks.
  Exception Retry
  var exCount = 0;
  retry:
  try
  {
    //Do work
  }
  catch (IOException)
  {
    exCount++;
    if (exCount < 3)
    {
      Thread.Sleep(100);
      GoalKicker.com – C# Notes for Professionals 224
  goto retry;
    }
    throw;
  }
  Live Demo on.NET Fiddle
  Similar to many languages, use of goto keyword is discouraged except the cases below.
  Valid usages of goto which apply to C#:
  Fall-through case in switch statement.
  Multi - level break. LINQ can often be used instead, but it usually has worse performance.
  Resource deallocation when working with unwrapped low - level objects.In C#, low-level objects should
  usually be wrapped in separate classes.
  Finite state machines, for example, parsers; used internally by compiler generated async/ await state
  machines.</code></pre>

<h3>volatile</h3>
Adding the volatile keyword to a field indicates to the compiler that the field's value may be changed by multiple
separate threads. The primary purpose of the volatile keyword is to prevent compiler optimizations that assume
only single-threaded access. Using volatile ensures that the value of the field is the most recent value that is
available, and the value is not subject to the caching that non-volatile values are.
It is good practice to mark every variable that may be used by multiple threads as volatile to prevent unexpected
behavior due to behind-the-scenes optimizations. Consider the following code block:
<pre><code>public class Example
  {
    public int x;
    public void DoStuff()
    {
      x = 5;
      // the compiler will optimize this to y = 15
      var y = x + 10;
      /* the value of x will always be the current value, but y will always be "15" */
      Debug.WriteLine("x = " + x + ", y = " + y);
    }
  }
  In the above code-block, the compiler reads the statements x = 5 and y = x + 10 and determines that the value of
  y will always end up as 15.Thus, it will optimize the last statement as y = 15.However, the variable x is in fact a
  public field and the value of x may be modified at runtime through a different thread acting on this field
  separately. Now consider this modified code-block. Do note that the field x is now declared as volatile.
  public class Example
  {
    public volatile int x;
    public void DoStuff()
    {
      x = 5;
      // the compiler no longer optimizes this statement
      var y = x + 10;
      /* the value of x and y will always be the correct values */
      Debug.WriteLine("x = " + x + ", y = " + y);
    }
  }
  Now, the compiler looks for read usages of the field x and ensures that the current value of the field is always
  retrieved. This ensures that even if multiple threads are reading and writing to this field, the current value of x is
  always retrieved.
  volatile can only be used on fields within classes or structs. The following is not valid:
  public void MyMethod() { volatile int x; }
  volatile can only be applied to fields of following types:
  reference types or generic type parameters known to be reference types
  primitive types such as sbyte, byte, short, ushort, int, uint, char, float, and bool
  enums types based on byte, sbyte, short, ushort, int or uint
  IntPtr and UIntPtr
  Remarks:
  The volatile modifier is usually used for a field that is accessed by multiple threads without using the lock
  statement to serialize access.
  The volatile keyword can be applied to fields of reference types
  The volatile keyword will not make operating on 64-bit primitives on a 32-bit platform atomic. Interlocked
  operations such as Interlocked.Read and Interlocked.Exchange must still be used for safe multi-threaded
  access on these platforms.</code></pre>

<h3>checked, unchecked</h3>
The checked and unchecked keywords define how operations handle mathematical overflow. "Overflow" in the
context of the checked and unchecked keywords is when an integer arithmetic operation results in a value which is
greater in magnitude than the target data type can represent.
When overflow occurs within a checked block (or when the compiler is set to globally use checked arithmetic), an
exception is thrown to warn of undesired behavior. Meanwhile, in an unchecked block, overflow is silent: no
exceptions are thrown, and the value will simply wrap around to the opposite boundary. This can lead to subtle,
hard to find bugs.
Since most arithmetic operations are done on values that are not large or small enough to overflow, most of the
time, there is no need to explicitly define a block as checked. Care needs to be taken when doing arithmetic on
unbounded input that may cause overflow, for example when doing arithmetic in recursive functions or while
taking user input.
Neither checked nor unchecked affect floating point arithmetic operations.
When a block or expression is declared as unchecked, any arithmetic operations inside it are allowed to overflow
without causing an error. An example where this behavior is desired would be the calculation of a checksum, where the value is allowed to "wrap around" during calculation:
<pre><code>byte Checksum(byte[] data)
  {
    byte result = 0;
    for (int i = 0; i < data.Length; i++)
    {
      result = unchecked(result + data[i]); // unchecked expression
    }
    return result;
  }
  One of the most common uses for unchecked is implementing a custom override for object.GetHashCode(), a type
  of checksum.You can see the keyword's use in the answers to this question: What is the best algorithm for an
  overridden System.Object.GetHashCode?.
  When a block or expression is declared as checked, any arithmetic operation that causes an overflow results in an
  OverflowException being thrown.
  int SafeSum(int x, int y) {
      checked
      { // checked block
        return x + y;
      }
    }
  Both checked and unchecked may be in block and expression form.
  Checked and unchecked blocks do not affect called methods, only operators called directly in the current method.
  For example, Enum.ToObject(), Convert.ToInt32(), and user-defined operators are not affected by custom
  checked/ unchecked contexts.
  Note: The default overflow default behavior(checked vs. unchecked) may be changed in the Project Properties or
  through the / checked[+| -] command line switch.It is common to default to checked operations for debug builds and
   unchecked for release builds. The checked and unchecked keywords would then be used only where a default approach
   does not apply and you need an explicit behavior to ensure correctness.</code></pre>

<h3>virtual, override, new</h3>
<pre><code>
  virtual and override
  The virtual keyword allows a method, property, indexer or event to be overridden by derived classes and present
  polymorphic behavior. (Members are non-virtual by default in C#)
  public class BaseClass
  {
  public virtual void Foo()
  {
  Console.WriteLine("Foo from BaseClass");
  }
  }
  In order to override a member, the override keyword is used in the derived classes. (Note the signature of the
  members must be identical)
  public class DerivedClass: BaseClass
  {
  public override void Foo()
  {
  }
  The polymorphic behavior of virtual members means that when invoked, the actual member being executed is
  determined at runtime instead of at compile time. The overriding member in the most derived class the particular
  object is an instance of will be the one executed.
  In short, object can be declared of type BaseClass at compile time but if at runtime it is an instance of
  DerivedClass then the overridden member will be executed:
  BaseClass obj1 = new BaseClass();
  obj1.Foo(); //Outputs "Foo from BaseClass"
  obj1 = new DerivedClass();
  obj1.Foo(); //Outputs "Foo from DerivedClass"
  Overriding a method is optional:
  public class SecondDerivedClass : DerivedClass { }
  var obj1 = new SecondDerivedClass();
  obj1.Foo(); //Outputs "Foo from DerivedClass"
  new
  Since only members defined as virtual are overridable and polymorphic, a derived class redefining a non virtual
  member might lead to unexpected results.
  public class BaseClass
  {
    public void Foo()
    {
      Console.WriteLine("Foo from BaseClass");
    }
  }
  public class DerivedClass : BaseClass
  {
    public void Foo()
    {
      Console.WriteLine("Foo from DerivedClass");
    }
  }
  BaseClass obj1 = new BaseClass();
  obj1.Foo(); //Outputs "Foo from BaseClass"
  obj1 = new DerivedClass();
  obj1.Foo(); //Outputs "Foo from BaseClass" too!
  When this happens, the member executed is always determined at compile time based on the type of the object.
  If the object is declared of type BaseClass(even if at runtime is of a derived class) then the method of
  BaseClass is executed
  If the object is declared of type DerivedClass then the method of DerivedClass is executed.
  This is usually an accident(When a member is added to the base type after an identical one was added to the
  GoalKicker.com – C# Notes for Professionals 228
  derived type) and a compiler warning CS0108 is generated in those scenarios.
  If it was intentional, then the new keyword is used to suppress the compiler warning(And inform other developers
  of your intentions!). the behavior remains the same, the new keyword just suppresses the compiler warning.
  public class BaseClass
  {
    public void Foo()
    {
      Console.WriteLine("Foo from BaseClass");
    }
  }
  public class DerivedClass : BaseClass
  {
    public new void Foo()
    {
      Console.WriteLine("Foo from DerivedClass");
    }
  }
  BaseClass obj1 = new BaseClass();
  obj1.Foo(); //Outputs "Foo from BaseClass"
  obj1 = new DerivedClass();
  obj1.Foo(); //Outputs "Foo from BaseClass" too!
  The usage of override is not optional
  Unlike in C++, the usage of the override keyword is not optional:
  public class A
  {
    public virtual void Foo()
    {
    }
  }
  public class B : A
  {
    public void Foo() // Generates CS0108
    {
    }
  }
  The above example also causes warning CS0108, because B.Foo() is not automatically overriding A.Foo().Add
  override when the intention is to override the base class and cause polymorphic behavior, add new when you want
  non-polymorphic behavior and resolve the call using the static type.The latter should be used with caution, as it
  may cause severe confusion.
  The following code even results in an error:
  public class A
  {
    public void Foo()
    {
    }
  }
  public class B : A
  GoalKicker.com – C# Notes for Professionals 229
  {
    public override void Foo() // Error: Nothing to override
    {
    }
  }
  Derived classes can introduce polymorphism
  The following code is perfectly valid (although rare):
  public class A
  {
    public void Foo()
    {
      Console.WriteLine("A");
    }
  }
  public class B : A
  {
    public new virtual void Foo()
    {
      Console.WriteLine("B");
    }
  }
  Now all objects with a static reference of B (and its derivatives) use polymorphism to resolve Foo(), while
  references of A use A.Foo().
  A a = new A();
  a.Foo(); // Prints "A";
  a = new B();
  a.Foo(); // Prints "A";
  B b = new B();
  b.Foo(); // Prints "B";
  Virtual methods cannot be private
  The C# compiler is strict in preventing senseless constructs. Methods marked as virtual cannot be private.
  Because a private method cannot be seen from a derived type, it couldn't be overwritten either. This fails to
  compile:
  public class A
  {
    private virtual void Foo() // Error: virtual methods cannot be private
    {
    }
  }
  </code></pre>
<h3>stackalloc</h3>
The stackalloc keyword creates a region of memory on the stack and returns a pointer to the start of that
memory. Stack allocated memory is automatically removed when the scope it was created in is exited.
<pre><code>
  //Allocate 1024 bytes. This returns a pointer to the first byte.
  byte* ptr = stackalloc byte[1024];
  //Assign some values...
  ptr[0] = 109;
  ptr[1] = 13;
  ptr[2] = 232;
  ...
  Used in an unsafe context.
  As with all pointers in C# there is no bounds checking on reads and assignments. Reading beyond the bounds of
  the allocated memory will have unpredictable results - it may access some arbitrary location within memory or it
  may cause an access violation exception.
  //Allocate 1 byte
  byte* ptr = stackalloc byte[1]
  ;
  //Unpredictable results...
  ptr[10] = 1;
  ptr[-1] = 2;
  Stack allocated memory is automatically removed when the scope it was created in is exited.This means that you
  should never return the memory created with stackalloc or store it beyond the lifetime of the scope.
  unsafe IntPtr Leak()
  {
    //Allocate some memory on the stack
    var ptr = stackalloc byte[1024];
    //Return a pointer to that memory (this exits the scope of "Leak")
    return new IntPtr(ptr);
  }
  unsafe void Bad()
  {
    //ptr is now an invalid pointer, using it in any way will have
    //unpredictable results. This is exactly the same as accessing beyond
    //the bounds of the pointer.
    var ptr = Leak();
  }
  stackalloc can only be used when declaring and initialising variables.The following is not valid:
  byte* ptr;
  ...
  ptr = stackalloc byte[1024];
  Remarks:
  stackalloc should only be used for performance optimizations (either for computation or interop).This is due to
  the fact that:
  The garbage collector is not required as the memory is allocated on the stack rather than the heap -the
  memory is released as soon as the variable goes out of scope
  It is faster to allocate memory on the stack rather than the heap
  Increase the chance of cache hits on the CPU due to the locality of data
</code></pre>

<h3>break</h3>
In a loop (for, foreach, do, while) the break statement aborts the execution of the innermost loop and returns to the
code after it. Also it can be used with yield in which it specifies that an iterator has come to an end.

<pre><code>for (var i = 0; i < 10; i++)
  {
    if (i == 5)
    {
      break;
    }
    Console.WriteLine("This will appear only 5 times, as the break will stop the loop.");
  }
  foreach (var stuff in stuffCollection)
  {
    if (stuff.SomeStringProp == null)
      break;
    // If stuff.SomeStringProp for any "stuff" is null, the loop is aborted.
    Console.WriteLine(stuff.SomeStringProp);
  }
  The break-statement is also used in switch-case constructs to break out of a case or default segment.
  switch (a)
    {
      case 5:
        Console.WriteLine("a was 5!");
        break;
      default:
        Console.WriteLine("a was something else!");
        break;
    }
    In switch statements, the 'break' keyword is required at the end of each case statement.This is contrary to some
     languages that allow for 'falling through' to the next case statement in the series. Workarounds for this would
     include 'goto' statements or stacking the 'case' statements sequentially.
     Following code will give numbers 0, 1, 2, ..., 9 and the last line will not be executed.yield break signifies the
  end of the function(not just a loop).
  public static IEnumerable<int> GetNumbers()
  {
    int i = 0;
    while (true)
    {
      if (i < 10)
      {
        yield return i++;
      }
      else
      {
        yield break;
      }
    }
    Console.WriteLine("This line will not be executed");
  }
  Live Demo on.NET Fiddle
  Note that unlike some other languages, there is no way to label a particular break in C#. This means that in the case
  of nested loops, only the innermost loop will be stopped:
  foreach (var outerItem in outerList)
  {
    foreach (var innerItem in innerList)
      GoalKicker.com – C# Notes for Professionals 232
  {
      if (innerItem.ShoudBreakForWhateverReason)
        // This will only break out of the inner loop, the outer will continue:
        break;
    }
  }
  If you want to break out of the outer loop here, you can use one of several different strategies, such as:
  A goto statement to jump out of the whole looping structure.
  A specific flag variable(shouldBreak in the following example) that can be checked at the end of each
  iteration of the outer loop.
  Refactoring the code to use a return statement in the innermost loop body, or avoid the whole nested loop
  structure altogether.
  bool shouldBreak = false;
  while (comeCondition)
  {
    while (otherCondition)
    {
      if (conditionToBreak)
      {
        // Either tranfer control flow to the label below...
        goto endAllLooping;
        // OR use a flag, which can be checked in the outer loop:
        shouldBreak = true;
      }
    }
    if (shouldBreakNow)
    {
      break; // Break out of outer loop if flag was set to true
    }
  }
  endAllLooping: // label from where control flow will continue</code></pre>

<h3>const</h3>
<pre><code>const is used to represent values that will never change throughout the lifetime of the program. Its value is
  constant from compile-time, as opposed to the readonly keyword, whose value is constant from run-time.
  For example, since the speed of light will never change, we can store it in a constant.
  const double c = 299792458; // Speed of light
  double CalculateEnergy(double mass)
  {
  return mass * c * c;
  }
  This is essentially the same as having return mass * 299792458 * 299792458, as the compiler will directly
  substitute c with its constant value.
  As a result, c cannot be changed once declared. The following will produce a compile-time error:
  const double c = 299792458; // Speed of light
  c = 500; //compile-time error
  A constant can be prefixed with the same access modifiers as methods:
  private const double c = 299792458;
  public const double c = 299792458;
  internal const double c = 299792458;
  const members are static by nature. However using static explicitly is not permitted.
  You can also define method-local constants:
  double CalculateEnergy(double mass)
  {
  const c = 299792458;
  return mass * c * c;
  }
  These can not be prefixed with a private or public keyword, since they are implicitly local to the method they are
  defined in.
  Not all types can be used in a const declaration. The value types that are allowed, are the pre-defined types sbyte,
  byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, and all enum types. Trying to declare
  const members with other value types (such as TimeSpan or Guid) will fail at compile-time.
  For the special pre-defined reference type string, constants can be declared with any value. For all other reference
  types, constants can be declared but must always have the value null.
  Because const values are known at compile-time, they are allowed as case labels in a switch statement, as
  standard arguments for optional parameters, as arguments to attribute specifications, and so on.
  If const values are used across different assemblies, care must be taken with versioning. For example, if assembly A
  defines a public const int MaxRetries = 3;, and assembly B uses that constant, then if the value of MaxRetries
  is later changed to 5 in assembly A (which is then re-compiled), that change will not be effective in assembly B unless
  assembly B is also re-compiled (with a reference to the new version of A).
  For that reason, if a value might change in future revisions of the program, and if the value needs to be publicly
  visible, do not declare that value const unless you know that all dependent assemblies will be re-compiled
  whenever something is changed. The alternative is using static readonly instead of const, which is resolved at
  runtime.
</code></pre>

<h3>async, await</h3>
The await keyword was added as part of C# 5.0 release which is supported from Visual Studio 2012 onwards. It
leverages Task Parallel Library (TPL) which made the multi-threading relatively easier. The async and await
keywords are used in pair in the same function as shown below. The await keyword is used to pause the current
asynchronous method's execution until the awaited asynchronous task is completed and/or its results returned. In
order to use the await keyword, the method that uses it must be marked with the async keyword.
Using async with void is strongly discouraged. For more info you can look here.
<pre><code>public async Task DoSomethingAsync()
  {
    Console.WriteLine("Starting a useless process...");
    Stopwatch stopwatch = Stopwatch.StartNew();
    int delay = await UselessProcessAsync(1000);
    stopwatch.Stop();
    Console.WriteLine("A useless process took {0} milliseconds to execute.",
    stopwatch.ElapsedMilliseconds);
  }
  public async Task<int> UselessProcessAsync(int x)
  {
    await Task.Delay(x);
    return x;
  }
  Output:
  "Starting a useless process..."
  * *... 1 second delay... **
  "A useless process took 1000 milliseconds to execute."

  The keyword pairs async and await can be omitted if a Task or Task<T> returning method only returns a single
    asynchronous operation.
    Rather than this:
    public async Task PrintAndDelayAsync(string message, int delay)
    {
      Debug.WriteLine(message);
      await Task.Delay(x);
    }
    It is preferred to do this:
    public Task PrintAndDelayAsync(string message, int delay)
    {
      Debug.WriteLine(message);
      return Task.Delay(x);
    }
    Version = 5.0
    In C# 5.0 await cannot be used in catch and finally.
    Version ≥ 6.0
    With C# 6.0 await can be used in catch and finally.
</code></pre>

<h3>for</h3>
Syntax: for (initializer; condition; iterator)
  .The for loop is commonly used when the number of iterations is known.
  .The statements in the initializer section run only once, before you enter the loop.
  .The condition section contains a boolean expression that's evaluated at the end of every loop 
  .iteration to determine whether the loop should exit or should run again.
  .The iterator section defines what happens after each iteration of the body of the loop.
This example shows how for can be used to iterate over the characters of a string:
<pre><code>string str = "Hello";
  for (int i = 0; i < str.Length; i++)
  {
    Console.WriteLine(str[i]);
  }
  Output:
  H
  e
  l
  l
  o
  Live Demo on.NET Fiddle
  All of the expressions that define a for statement are optional; for example, the following statement is used to
  create an infinite loop:
  for (; ; )
    {
      // Your code here
    }
  The initializer section can contain multiple variables, so long as they are of the same type.The condition
  section can consist of any expression which can be evaluated to a bool.And the iterator section can perform
  multiple actions separated by comma:
  string hello = "hello";
  for (int i = 0, j = 1, k = 9; i < 3 && k > 0; i++, hello += i)
  {
    Console.WriteLine(hello);
  }
  Output:
  hello
  hello1
  hello12</code></pre>

<h3>abstract</h3>
A class marked with the keyword abstract cannot be instantiated.
A class must be marked as abstract if it contains abstract members or if it inherits abstract members that it doesn't
implement. A class may be marked as abstract even if no abstract members are involved.
Abstract classes are usually used as base classes when some part of the implementation needs to be specified by
another component.
<pre><code>abstract class Animal
  {
    string Name { get; set; }
    public abstract void MakeSound();
  }
  public class Cat : Animal
  {
    public override void MakeSound()
    {
      Console.WriteLine("Meov meov");
    }
  }
  public class Dog : Animal
  {
    public override void MakeSound()
    {
      Console.WriteLine("Bark bark");
    }
  }
  Animal cat = new Cat(); // Allowed due to Cat deriving from Animal
  cat.MakeSound(); // will print out "Meov meov"
  Animal dog = new Dog(); // Allowed due to Dog deriving from Animal
  dog.MakeSound(); // will print out "Bark bark"
  Animal animal = new Animal(); // Not allowed due to being an abstract class
  A method, property, or event marked with the keyword abstract indicates that the implementation for that
  member is expected to be provided in a subclass. As mentioned above, abstract members can only appear in
  abstract classes.
  abstract class Animal
  {
    public abstract string Name { get; set; }
  }
  public class Cat : Animal
  {
    public override string Name { get; set; }
  }
  public class Dog : Animal
  {
    public override string Name { get; set; }
  }</code></pre>

<h3>fixed</h3>
The fixed statement fixes memory in one location. Objects in memory are usually moving arround, this makes
garbage collection possible. But when we use unsafe pointers to memory addresses, that memory must not be
moved.
  . We use the fixed statement to ensure that the garbage collector does not relocate the string data.
<pre><code>
  // Fixed Variables
  var myStr = "Hello world!";
  fixed (char* ptr = myStr)
  {
  // myStr is now fixed (won't be [re]moved by the Garbage Collector).
  // We can now do something with ptr.
  }
  //Used in an unsafe context.
 
  // Fixed Array Size
  unsafe struct Example
  {
  public fixed byte SomeField[8];
  public fixed char AnotherField[64];
  }
  // fixed can only be used on fields in a struct (must also be used in an unsafe context)
</code></pre>

<h3>default</h3>
For classes, interfaces, delegate, array, nullable (such as int?) and pointer types, default(TheType) returns null:
<pre><code>class MyClass { }
  Debug.Assert(default(MyClass) == null);
  Debug.Assert(default(string) == null);
  For structs and enums, default(TheType) returns the same as new TheType():
  struct Coordinates
  {
    public int X { get; set; }
    public int Y { get; set; }
  }
  struct MyStruct
  {
    public string Name { get; set; }
    public Coordinates Location { get; set; }
    public Coordinates? SecondLocation { get; set; }
    public TimeSpan Duration { get; set; }
  }
  var defaultStruct = default(MyStruct);
  Debug.Assert(defaultStruct.Equals(new MyStruct()));
  Debug.Assert(defaultStruct.Location.Equals(new Coordinates()));
  Debug.Assert(defaultStruct.Location.X == 0);
  Debug.Assert(defaultStruct.Location.Y == 0);
  Debug.Assert(defaultStruct.SecondLocation == null);
  Debug.Assert(defaultStruct.Name == null);
  Debug.Assert(defaultStruct.Duration == TimeSpan.Zero);
  default(T) can be particularly useful when T is a generic parameter for which no constraint is present to decide
  whether T is a reference type or a value type, for example:

  public T GetResourceOrDefault<T>(string resourceName)
    {
      if (ResourceExists(resourceName))
      {
        return (T)GetResource(resourceName);
      }
      else
      {
        return default(T);
      }
    }
</code></pre>

<h3>sealed</h3>
<pre><code>When applied to a class, the sealed modifier prevents other classes from inheriting from it.
  class A { }
  sealed class B : A { }
  class C : B { } //error : Cannot derive from the sealed class
  When applied to a virtual method(or virtual property), the sealed modifier prevents this method (property) from
  being overridden in derived classes.
  public class A
  {
    public sealed override string ToString() // Virtual method inherited from class Object
    {
      return "Do not override me!";
    }
  }
  public class B : A
  {
    public override string ToString() // Compile time error
    {
      return "An attempt to override";
    }
  }</code></pre>

<h3>is</h3>
<pre><code>Checks if an object is compatible with a given type, i.e. if an object is an instance of the BaseInterface type, or a
  type that derives from BaseInterface:
  interface BaseInterface {}
  class BaseClass : BaseInterface {}
  class DerivedClass : BaseClass {}
  var d = new DerivedClass();
  Console.WriteLine(d is DerivedClass); // True
  Console.WriteLine(d is BaseClass); // True
  Console.WriteLine(d is BaseInterface); // True
  Console.WriteLine(d is object); // True
  Console.WriteLine(d is string); // False
  var b = new BaseClass();
  Console.WriteLine(b is DerivedClass); // False
  Console.WriteLine(b is BaseClass); // True
  Console.WriteLine(b is BaseInterface); // True
  Console.WriteLine(b is object); // True
  Console.WriteLine(b is string); // False
  //If the intent of the cast is to use the object, it is best practice to use the as keyword'
  interface BaseInterface {}
  class BaseClass : BaseInterface {}
  class DerivedClass : BaseClass {}
  var d = new DerivedClass();
  Console.WriteLine(d is DerivedClass); // True - valid use of 'is'
  Console.WriteLine(d is BaseClass); // True - valid use of 'is'
  if(d is BaseClass){
    var castedD = (BaseClass)d;
    castedD.Method(); // valid, but not best practice
  }
  var asD = d as BaseClass;
  if(asD!=null){
    asD.Method(); //preferred method since you incur only one unboxing penalty
  }
  But, from C# 7 pattern matching feature extends the is operator to check for a type and declare a new variable at
  the same time. Same code part with C# 7 :
  Version ≥ 7.0
  if(d is BaseClass asD ){
    asD.Method();
  }
</code></pre> 
<h3>this</h3>
<pre><code>The this keyword refers to the current instance of class(object).That way two variables with the same name, one at
  the class-level(a field) and one being a parameter(or local variable) of a method, can be distinguished.
  public MyClass
  {
    int a;
    void set_a(int a)
    {
      //this.a refers to the variable defined outside of the method,
      //while a refers to the passed parameter.
      this.a = a;
    }
  }
  Other usages of the keyword are chaining non-static constructor overloads:
  public MyClass(int arg) : this(arg, null)
  {
  }
  and writing indexers:
  public string this[int idx1, string idx2]
  {
    get { /* ... */ }
    set { /* ... */ }
  }
  and declaring extension methods:
  public static int Count<TItem>(this IEnumerable<TItem> source)
  {
    // ...
  }
  If there is no conflict with a local variable or parameter, it is a matter of style whether to use this or not, so
  this.MemberOfType and MemberOfType would be equivalent in that case. Also see base keyword.
  Note that if an extension method is to be called on the current instance, this is required.For example if your are
  inside a non-static method of a class which implements IEnumerable<> and you want to call the extension Count
  from before, you must use:
  this.Count() // works like StaticClassForExtensionMethod.Count(this)
  and this cannot be omitted there.</code></pre>

<h3>readonly</h3>
<pre><code>The readonly keyword is a field modifier.When a field declaration includes a readonly modifier, assignments to
  that field can only occur as part of the declaration or in a constructor in the same class.
  The readonly keyword is different from the const keyword.A const field can only be initialized at the declaration of
  the field. A readonly field can be initialized either at the declaration or in a constructor. Therefore, readonly fields
  can have different values depending on the constructor used.
  The readonly keyword is often used when injecting dependencies.
  class Person
  {
    readonly string _name;
    readonly string _surname = "Surname";
    Person(string name)
    {
      _name = name;
    }
    void ChangeName()
    {
      _name = "another name"; // Compile error
      _surname = "another surname"; // Compile error
    }
  }
  Note: Declaring a field readonly does not imply immutability. If the field is a reference type then the
  content of the object can be changed. Readonly is typically used to prevent having the object being
  overwritten and assigned only during instantiation of that object.
  Note: Inside the constructor a readonly field can be reassigned
  public class Car
  {
    public double Speed { get; set; }
  }
  //In code
  private readonly Car car = new Car();
  private void SomeMethod()
  {
    car.Speed = 100;
  }</code></pre> 
 <h3>typeof</h3>
<pre><code></code></pre>

<h3>typeof</h3>
<pre><code>Returns the Type of an object, without the need to instantiate it.
  Type type = typeof(string);
  Console.WriteLine(type.FullName); //System.String
  Console.WriteLine("Hello".GetType() == type); //True
  Console.WriteLine("Hello".GetType() == typeof(string)); //True</code></pre> 

<h3>foreach</h3>
<pre><code>foreach is used to iterate over the elements of an array or the items within a collection which implements
IEnumerable✝.
var lines = new string[] {
"Hello world!",
"How are you doing today?",
"Goodbye"
};
foreach (string line in lines)
{
  Console.WriteLine(line);
}
This will output
"Hello world!"
"How are you doing today?"
"Goodbye"
Live Demo on.NET Fiddle
You can exit the foreach loop at any point by using the break keyword or move on to the next iteration using the
continue keyword.
var numbers = new int[] { 1, 2, 3, 4, 5, 6 };
foreach (var number in numbers)
{
  // Skip if 2
  if (number == 2)
    continue;
  // Stop iteration if 5
  if (number == 5)
    break;
  Console.Write(number + ", ");
}
// Prints: 1, 3, 4,
Live Demo on.NET Fiddle
Notice that the order of iteration is guaranteed only for certain collections such as arrays and List, but not
guaranteed for many other collections.
✝ While IEnumerable is typically used to indicate enumerable collections, foreach only requires that the collection
expose publicly the object GetEnumerator() method, which should return an object that exposes the bool
MoveNext() method and the object Current { get; }
property.</code></pre>
<h3>dynamic</h3>
<pre><code>The dynamic keyword is used with dynamically typed objects.Objects declared as dynamic forego compile-time
  static checks, and are instead evaluated at runtime.
  using System;
  using System.Dynamic;
  dynamic info = new ExpandoObject();
  info.Id = 123;
  info.Another = 456;
  Console.WriteLine(info.Another);
  // 456
  Console.WriteLine(info.DoesntExist);
  // Throws RuntimeBinderException
  The following example uses dynamic with Newtonsoft's library Json.NET, in order to easily read data from a
  deserialized JSON file.
  try
  {
    string json = @"{ x : 10, y : ""ho""}";
    dynamic deserializedJson = JsonConvert.DeserializeObject(json);
    int x = deserializedJson.x;
    string y = deserializedJson.y;
    // int z = deserializedJson.z; // throws RuntimeBinderException
  }
  catch (RuntimeBinderException e)
  {
    // This exception is thrown when a property
    // that wasn't assigned to a dynamic variable is used
  }
  
  There are some limitations associated with the dynamic keyword.One of them is the use of extension methods.
  The following example adds an extension method for string: SayHello.
  static class StringExtensions
  {
    public static string SayHello(this string s) => $"Hello {s}!";
  }
  The first approach will be to call it as usual (as for a string):
  var person = "Person";
  Console.WriteLine(person.SayHello());
  dynamic manager = "Manager";
  Console.WriteLine(manager.SayHello()); // RuntimeBinderException
  No compilation error, but at runtime you get a RuntimeBinderException.The workaround for this will be to call the
  extension method via the static class:
  var helloManager = StringExtensions.SayHello(manager);
  Console.WriteLine(helloManager);</code></pre>

<h3>try, catch, finally, throw</h3>
<pre><code>try, catch, finally, and throw allow you to handle exceptions in your code.
  var processor = new InputProcessor();
  // The code within the try block will be executed. If an exception occurs during execution of
  // this code, execution will pass to the catch block corresponding to the exception type.
  try
  {
    processor.Process(input);
  }
  // If a FormatException is thrown during the try block, then this catch block
  // will be executed.
  catch (FormatException ex)
  {
    // Throw is a keyword that will manually throw an exception, triggering any catch block that is
    // waiting for that exception type.
    throw new InvalidOperationException("Invalid input", ex);
  }
  // catch can be used to catch all or any specific exceptions. This catch block,
  // with no type specified, catches any exception that hasn't already been caught
  // in a prior catch block.
  catch
  {
    LogUnexpectedException();
    throw; // Re-throws the original exception.
  }
  // The finally block is executed after all try-catch blocks have been; either after the try has
  // succeeded in running all commands or after all exceptions have been caught.
  finally
  {
    processor.Dispose();
  }
  Note: The return keyword can be used in try block, and the finally block will still be executed(just before
  
  returning).For example:
  try
  {
    connection.Open();
    return connection.Get(query);
  }
  finally
  {
    connection.Close();
  }
  The statement connection.Close() will execute before the result of connection.Get(query) is returned.</code></pre>

<h3>void</h3>
<pre><code>The reserved word "void" is an alias of System.Void type, and has two uses:
  1. Declare a method that doesn't have a return value:
  public void DoSomething()
  {
    // Do some work, don't return any value to the caller.
  }
  A method with a return type of void can still have the return keyword in its body.This is useful when you want to
  exit the method's execution and return the flow to the caller:
  public void DoSomething()
  {
    // Do some work...
    if (condition)
      return;
    // Do some more work if the condition evaluated to false.
  }
  2.Declare a pointer to an unknown type in an unsafe context.
  In an unsafe context, a type may be a pointer type, a value type, or a reference type.A pointer type declaration is
  usually type* identifier, where the type is a known type - i.e int* myInt, but can also be void* identifier,
  where the type is unknown.
  Note that declaring a void pointer type is discouraged by Microsoft.</code></pre>

<h3>namespace</h3>
<pre><code>
  The namespace keyword is an organization construct that helps us understand how a codebase is arranged.
  Namespaces in C# are virtual spaces rather than being in a physical folder.
  namespace StackOverflow
  {
    namespace Documentation
    {
      namespace CSharp.Keywords
      {
        public class Program
        {
          public static void Main()
          {
            Console.WriteLine(typeof(Program).Namespace);
            //StackOverflow.Documentation.CSharp.Keywords
          }
        }
      }
    }
  }
  Namespaces in C# can also be written in chained syntax. The following is equivalent to above:
  namespace StackOverflow.Documentation.CSharp.Keywords
  {
    public class Program
    {
      public static void Main()
      {
        Console.WriteLine(typeof(Program).Namespace);
        //StackOverflow.Documentation.CSharp.Keywords
      }
    }
  }
</code></pre>

<h3>ref, out</h3>
<pre><code>The ref and out keywords cause an argument to be passed by reference, not by value. For value types, this means
  that the value of the variable can be changed by the callee.
  int x = 5;
  ChangeX(ref x);
  // The value of x could be different now
  For reference types, the instance in the variable can not only be modified (as is the case without ref), but it can also
  be replaced altogether:
  Address a = new Address();
  ChangeFieldInAddress(a);
  // a will be the same instance as before, even if it is modified
  CreateANewInstance(ref a);
  // a could be an entirely new instance now
  The main difference between the out and ref keyword is that ref requires the variable to be initialized by the
  caller, while out passes that responsibility to the callee.
  To use an out parameter, both the method definition and the calling method must explicitly use the out keyword.
  int number = 1;
  Console.WriteLine("Before AddByRef: " + number); // number = 1
  AddOneByRef(ref number);
  Console.WriteLine("After AddByRef: " + number); // number = 2
  SetByOut(out number);
  Console.WriteLine("After SetByOut: " + number); // number = 34
  void AddOneByRef(ref int value)
  {
    value++;
  }
  void SetByOut(out int value)
  {
    value = 34;
  }
  Live Demo on .NET Fiddle
  The following does not compile, because out parameters must have a value assigned before the method returns (it
  would compile using ref instead):
  void PrintByOut(out int value)
  {
    Console.WriteLine("Hello!");
  }
  using out keyword as Generic Modifier
  out keyword can also be used in generic type parameters when defining generic interfaces and delegates. In this
  case, the out keyword specifies that the type parameter is covariant.
  Covariance enables you to use a more derived type than that specified by the generic parameter. This
  allows for implicit conversion of classes that implement variant interfaces and implicit conversion of
  delegate types. Covariance and contravariance are supported for reference types, but they are not
  supported for value types. - MSDN
  //if we have an interface like this
  interface ICovariant< out R> { }
  //and two variables like
  ICovariant< Object> iobj = new Sample< Object>();
  ICovariant< String> istr = new Sample< String>();
  // then the following statement is valid
  // without the out keyword this would have thrown error
  iobj = istr; // implicit conversion occurs here
</code></pre>

<h3>base</h3>
<pre><code>
  The base keyword is used to access members from a base class. It is commonly used to call base implementations
  of virtual methods, or to specify which base constructor should be called.
  Choosing a constructor
  public class Child : SomeBaseClass
  {
    public Child() : base("some string for the base class")
    {
    }
  }
  public class SomeBaseClass
  {
    public SomeBaseClass()
    {
      // new Child() will not call this constructor, as it does not have a parameter
    }
    public SomeBaseClass(string message)
    {
      // new Child() will use this base constructor because of the specified parameter in Child's
      constructor
    Console.WriteLine(message);
    }
  }
  Calling base implementation of virtual method
  public override void SomeVirtualMethod()
  {
    // Do something, then call base implementation
    base.SomeVirtualMethod();
  }
  It is possible to use the base keyword to call a base implementation from any method.This ties the method call
  directly to the base implementation, which means that even if new child classes override a virtual method, the base
  implementation will still be called so this needs to be used with caution.
  public class Parent
  {
    public virtual int VirtualMethod()
    {
      return 1;
    }
  }
  public class Child : Parent
  {
    public override int VirtualMethod()
    {
      return 11;
    }
    public int NormalMethod()
    {
      return base.VirtualMethod();
    }
    public void CallMethods()
    {
      Assert.AreEqual(11, VirtualMethod());
      Assert.AreEqual(1, NormalMethod());
      Assert.AreEqual(1, base.VirtualMethod());
    }
  }
  public class GrandChild : Child
  {
    public override int VirtualMethod()
    {
      return 21;
    }
    public void CallAgain()
    {
      Assert.AreEqual(21, VirtualMethod());
      Assert.AreEqual(11, base.VirtualMethod());
      GoalKicker.com – C# Notes for Professionals 248
  // Notice that the call to NormalMethod below still returns the value
  // from the extreme base class even though the method has been overridden
  // in the child class.
      Assert.AreEqual(1, NormalMethod());
    }
  }
</code></pre>

<h3>float, double, decimal</h3>
<pre><code>float
  float is an alias to the .NET datatype System.Single. It allows IEEE 754 single-precision floating point numbers to
  be stored. This data type is present in mscorlib.dll which is implicitly referenced by every C# project when you
  create them.
  Approximate range: -3.4 × 1038 to 3.4 × 1038
  Decimal precision: 6-9 significant digits
  Notation:
  float f = 0.1259;
  var f1 = 0.7895f; // f is literal suffix to represent float values
  It should be noted that the float type often results in significant rounding errors. In applications where
  precision is important, other data types should be considered.
  double
  double is an alias to the .NET datatype System.Double. It represents a double-precision 64-bit floating-point
  number. This datatype is present in mscorlib.dll which is implicitly referenced in any C# project.
  Range: ±5.0 × 10−324 to ±1.7 × 10308
  Decimal precision: 15-16 significant digits
  Notation:
  double distance = 200.34; // a double value
  double salary = 245; // an integer implicitly type-casted to double value
  var marks = 123.764D; // D is literal suffix to represent double values
  decimal
  decimal is an alias to the .NET datatype System.Decimal. It represents a keyword indicates a 128-bit data type.
  Compared to floating-point types, the decimal type has more precision and a smaller range, which makes it
  appropriate for financial and monetary calculations. This datatype is present in mscorlib.dll which is implicitly
  referenced in any C# project.
  Range: -7.9 × 1028 to 7.9 × 1028
  Decimal precision: 28-29 significant digits

  Notation:
  decimal payable = 152.25m; // a decimal value
  var marks = 754.24m; // m is literal suffix to represent decimal values
</code></pre>

<h3>operator</h3>
<pre><code>Most of the built-in operators(including conversion operators) can be overloaded by using the operator keyword
  along with the public and static modifiers.
  The operators comes in three forms: unary operators, binary operators and conversion operators.
  Unary and binary operators requires at least one parameter of same type as the containing type, and some
  requires a complementary matching operator.
  Conversion operators must convert to or from the enclosing type.
  public struct Vector32
  {
    public Vector32(int x, int y)
    {
      X = x;
      Y = y;
    }
    public int X { get; }
    public int Y { get; }
    public static bool operator ==(Vector32 left, Vector32 right)
    => left.X == right.X && left.Y == right.Y;
    public static bool operator !=(Vector32 left, Vector32 right)
    => !(left == right);
    public static Vector32 operator +(Vector32 left, Vector32 right)
    => new Vector32(left.X + right.X, left.Y + right.Y);
    public static Vector32 operator +(Vector32 left, int right)
    => new Vector32(left.X + right, left.Y + right);
    public static Vector32 operator +(int left, Vector32 right)
    => right + left;
    public static Vector32 operator -(Vector32 left, Vector32 right)
    => new Vector32(left.X - right.X, left.Y - right.Y);
    public static Vector32 operator -(Vector32 left, int right)
    => new Vector32(left.X - right, left.Y - right);
    public static Vector32 operator -(int left, Vector32 right)
    => right - left;
    public static implicit operator Vector64(Vector32 vector)
    => new Vector64(vector.X, vector.Y);
    public override string ToString() => $"{{{X}, {Y}}}";
  }
  
  public struct Vector64
  {
    public Vector64(long x, long y)
    {
      X = x;
      Y = y;
    }
    public long X { get; }
    public long Y { get; }
    public override string ToString() => $"{{{X}, {Y}}}";
  }
  Example
  var vector1 = new Vector32(15, 39);
  var vector2 = new Vector32(87, 64);
  Console.WriteLine(vector1 == vector2); // false
  Console.WriteLine(vector1 != vector2); // true
  Console.WriteLine(vector1 + vector2); // {102, 103}
  Console.WriteLine(vector1 - vector2); // {-72, -25}</code></pre>

<h3>char</h3>
<pre><code>A char is single letter stored inside a variable.It is built-in value type which takes two bytes of memory space.It
  represents System.Char data type found in mscorlib.dll which is implicitly referenced by every C# project when
  you create them.
  There are multiple ways to do this.
  1. char c = 'c';
  2. char c = '\u0063'; //Unicode
  3. char c = '\x0063'; //Hex
  4. char c = (char)99;//Integral
  A char can be implicitly converted to ushort, int, uint, long, ulong, float, double, or decimal and it will
  return the integer value of that char.
  ushort u = c;
  returns 99 etc.
  However, there are no implicit conversions from other types to char. Instead you must cast them.
  ushort u = 99;
  char c = (char)u;</code></pre>

<h3>params</h3>
<pre><code>
  params allows a method parameter to receive a variable number of arguments, i.e. zero, one or multiple arguments
  are allowed for that parameter
  static int AddAll(params int[] numbers)
  {
    int total = 0;
    foreach (int number in numbers)
    {
      total += number;
    }
    return total;
  }
  This method can now be called with a typical list of int arguments, or an array of ints.
  AddAll(5, 10, 15, 20); // 50
  AddAll(new int[] { 5, 10, 15, 20 }); // 50
  params must appear at most once and if used, it must be last in the argument list, even if the succeeding type is
  different to that of the array.
  Be careful when overloading functions when using the params keyword.C# prefers matching more specific
  overloads before resorting to trying to use overloads with params. For example if you have two methods:
  static double Add(params double[] numbers)
  {
    Console.WriteLine("Add with array of doubles");
    double total = 0.0;
    foreach (double number in numbers)
    {
      total += number;
    }
    return total;
  }
  static int Add(int a, int b)
  {
    Console.WriteLine("Add with 2 ints");
    return a + b;
  }
  Then the specific 2 argument overload will take precedence before trying the params overload.
  Add(2, 3); //prints "Add with 2 ints"
  Add(2, 3.0); //prints "Add with array of doubles" (doubles are not ints)
  Add(2, 3, 4); //prints "Add with array of doubles" (no 3 argument overload)
</code></pre>

<h3>while</h3>
<pre><code>
  The while operator iterates over a block of code until the conditional query equals false or the code is interrupted
  with a goto, return, break or throw statement.
  Syntax for while keyword:
  while( condition ) { code block; }
  Example:
  int i = 0;
  while (i++ < 5)
  {
    Console.WriteLine("While is on loop number {0}.", i);
  }
  Output:
  "While is on loop number 1."
  "While is on loop number 2."
  "While is on loop number 3."
  "While is on loop number 4."
  "While is on loop number 5."
  A while loop is Entry Controlled, as the condition is checked before the execution of the enclosed code block. This
  means that the while loop wouldn't execute its statements if the condition is false.
  bool a = false;
  while (a == true)
  {
  Console.WriteLine("This will never be printed.");
  }
  Giving a while condition without provisioning it to become false at some point will result in an infinite or endless
  loop. As far as possible, this should be avoided, however, there may be some exceptional circumstances when you
  need this.
  You can create such a loop as follows:
  while (true)
  {
  //...
  }
  Note that the C# compiler will transform loops such as
  while (true)
  {
  // ...
  }
  or
  for(;;)
  {
  // ...
  }
  into
  {
  :label

  // ...
  goto label;
  }
  Note that a while loop may have any condition, no matter how complex, as long as it evaluates to (or returns) a
  boolean value (bool). It may also contain a function that returns a boolean value (as such a function evaluates to the
  same type as an expression such as `a==x'). For example,
  while (AgriculturalService.MoreCornToPick(myFarm.GetAddress()))
  {
  myFarm.PickCorn();
  }
</code></pre>

<h3>null</h3>
<pre><code>A variable of a reference type can hold either a valid reference to an instance or a null reference. The null reference
  is the default value of reference type variables, as well as nullable value types.
  null is the keyword that represents a null reference.
  As an expression, it can be used to assign the null reference to variables of the aforementioned types:
  object a = null;
  string b = null;
  int? c = null;
  List<int> d = null;
  Non-nullable value types cannot be assigned a null reference. All the following assignments are invalid:
  int a = null;
  float b = null;
  decimal c = null;
  The null reference should not be confused with valid instances of various types such as:
  an empty list (new List<int>())
  an empty string ("")
  the number zero (0, 0f, 0m)
  the null character ( '\0' )
  Sometimes, it is meaningful to check if something is either null or an empty/default object. The
  System.String.IsNullOrEmpty(String) method may be used to check this, or you may implement your own equivalent
  method.
  private void GreetUser(string userName)
  {
  if (String.IsNullOrEmpty(userName))
  {
  //The method that called us either sent in an empty string, or they sent us a null reference.
  Either way, we need to report the problem.
  throw new InvalidOperationException("userName may not be null or empty.");
  }
  else
  {
  //userName is acceptable.
  Console.WriteLine("Hello, " + userName + "!");
  }
  GoalKicker.com – C# Notes for Professionals 254
  }</code></pre>

<h3>continue</h3>
<pre><code>Immediately pass control to the next iteration of the enclosing loop construct (for, foreach, do, while):
  for (var i = 0; i < 10; i++)
  {
  if (i < 5)
  {
  continue;
  }
  Console.WriteLine(i);
  }
  Output:
  5
  6
  7
  8
  9
  Live Demo on .NET Fiddle
  var stuff = new [] {"a", "b", null, "c", "d"};
  foreach (var s in stuff)
  {
  if (s == null)
  {
  continue;
  }
  Console.WriteLine(s);
  }
  Output:
  a
  b
  c
  d
  Live Demo on .NET Fiddle
  Section 52.33: string
  string is an alias to the .NET datatype System.String, which allows text (sequences of characters) to be stored.
  Notation:
  string a = "Hello";
  var b = "world";

  var f = new string(new []{ 'h', 'i', '!' }); // hi!
  Each character in the string is encoded in UTF-16, which means that each character will require a minimum 2 bytes
  of storage space.</code></pre>

<h3>return</h3>
<pre><code>MSDN: The return statement terminates execution of the method in which it appears and returns control
  to the calling method. It can also return an optional value. If the method is a void type, the return
  statement can be omitted.
  public int Sum(int valueA, int valueB)
  {
  return valueA + valueB;
  }
  public void Terminate(bool terminateEarly)
  {
  if (terminateEarly) return; // method returns to caller if true was passed in
  else Console.WriteLine("Not early"); // prints only if terminateEarly was false
  }</code></pre>

<h3>unsafe</h3>
<pre><code>
  The unsafe keyword can be used in type or method declarations or to declare an inline block.
  The purpose of this keyword is to enable the use of the unsafe subset of C# for the block in question. The unsafe
  subset includes features like pointers, stack allocation, C-like arrays, and so on.
  Unsafe code is not verifiable and that's why its usage is discouraged. Compilation of unsafe code requires passing a
  switch to the C# compiler. Additionally, the CLR requires that the running assembly has full trust.
  Despite these limitations, unsafe code has valid usages in making some operations more performant (e.g. array
  indexing) or easier (e.g. interop with some unmanaged libraries).
  As a very simple example
  // compile with /unsafe
  class UnsafeTest
  {
    unsafe static void SquarePtrParam(int* p)
    {
      *p *= *p; // the '*' dereferences the pointer.
            //Since we passed in "the address of i", this becomes "i *= i"
    }
    unsafe static void Main()
    {
      int i = 5;
      // Unsafe method: uses address-of operator (&):
      SquarePtrParam(&i); // "&i" means "the address of i". The behavior is similar to "ref i"
      Console.WriteLine(i); // Output: 25
    }
  }

  While working with pointers, we can change the values of memory locations directly, rather than having to address
  them by name.Note that this often requires the use of the fixed keyword to prevent possible memory corruption
  as the garbage collector moves things around(otherwise, you may get error CS0212).Since a variable that has been
  "fixed" cannot be written to, we also often have to have a second pointer that starts out pointing to the same
  location as the first.
  void Main()
  {
  int[] intArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  UnsafeSquareArray(intArray);
  foreach (int i in intArray)
    Console.WriteLine(i);
  }
  unsafe static void UnsafeSquareArray(int[] pArr)
  {
    int len = pArr.Length;
    //in C or C++, we could say
    // int* a = &(pArr[0])
    // however, C# requires you to "fix" the variable first
    fixed (int* fixedPointer = &(pArr[0]))
    {
      //Declare a new int pointer because "fixedPointer" cannot be written to.
      // "p" points to the same address space, but we can modify it
      int* p = fixedPointer;
      for (int i = 0; i < len; i++)
      {
        *p *= *p; //square the value, just like we did in SquarePtrParam, above
        p++; //move the pointer to the next memory space.
           // NOTE that the pointer will move 4 bytes since "p" is an
           // int pointer and an int takes 4 bytes
           //the above 2 lines could be written as one, like this:
           // "*p *= *p++;"
      }
    }
  }
  Output:
  1
  4
  9
  16
  25
  36
  49
  64
  81
  100
  unsafe also allows the use of stackalloc which will allocate memory on the stack like _alloca in the C run-time
  library. We can modify the above example to use stackalloc as follows:
  unsafe void Main()
  {
    GoalKicker.com – C# Notes for Professionals 257
  const int len = 10;
    int* seedArray = stackalloc int[len];
    //We can no longer use the initializer "{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}" as before.
    // We have at least 2 options to populate the array. The end result of either
    // option will be the same (doing both will also be the same here).
    //FIRST OPTION:
    int* p = seedArray; // we don't want to lose where the array starts, so we
              // create a shadow copy of the pointer
    for (int i = 1; i <= len; i++)
      *p++ = i;
    //end of first option
    //SECOND OPTION:
    for (int i = 0; i < len; i++)
      seedArray[i] = i + 1;
    //end of second option
    UnsafeSquareArray(seedArray, len);
    for (int i = 0; i < len; i++)
      Console.WriteLine(seedArray[i]);
  }
  //Now that we are dealing directly in pointers, we don't need to mess around with
  // "fixed", which dramatically simplifies the code
  unsafe static void UnsafeSquareArray(int* p, int len)
  {
    for (int i = 0; i < len; i++)
      *p *= *p++;
  }
  (Output is the same as above)
</code></pre>

<h3>switch</h3>
<pre><code>The switch statement is a control statement that selects a switch section to execute from a list of candidates.A
  switch statement includes one or more switch sections.Each switch section contains one or more case labels
  followed by one or more statements.If no case label contains a matching value, control is transferred to the
  default section, if there is one.Case fall - through is not supported in C#, strictly speaking. However, if 1 or more
  case labels are empty, execution will follow the code of the next case block which contains code.This allows
  grouping of multiple case labels with the same implementation.In the following example, if month equals 12, the
  code in case 2 will be executed since the case labels 12 1 and 2 are grouped. If a case block is not empty, a break
  must be present before the next case label, otherwise the compiler will flag an error.
  int month = DateTime.Now.Month; // this is expected to be 1-12 for Jan-Dec
  switch (month)
  {
    case 12:
    case 1:
    case 2:
      Console.WriteLine("Winter");
      break;
    case 3:
    case 4:
    case 5:
      Console.WriteLine("Spring");
      break;
    case 6:
    case 7:
    case 8:
      Console.WriteLine("Summer");
      break;
    case 9:
    case 10:
    case 11:
      Console.WriteLine("Autumn");
      break;
    default:
      Console.WriteLine("Incorrect month index");
      break;
  }
  A case can only be labeled by a value known at compile time(e.g. 1, "str", Enum.A), so a variable isn't a valid case
  label, but a const or an Enum value is (as well as any literal value).</code></pre>


<h3>var</h3>
<pre><code>
  An implicitly-typed local variable that is strongly typed just as if the user had declared the type.
  Unlike other variable declarations, the compiler determines the type of variable that this represents based on the value that is
  assigned to it.
  var i = 10; // implicitly typed, the compiler must determine what type of variable this is
  int i = 10; // explicitly typed, the type of variable is explicitly stated to the compiler
        // Note that these both represent the same type of variable (int) with the same value (10).
  Unlike other types of variables, variable definitions with this keyword need to be initialized when declared.This is
  due to the var keyword representing an implicitly-typed variable.
  var i;
  i = 10;
  // This code will not run as it is not initialized upon declaration.
  The var keyword can also be used to create new datatypes on the fly. These new datatypes are known as
  anonymous types. They are quite useful, as they allow a user to define a set of properties without having to explicitly
  declare any kind of object type first.
  Plain anonymous type
  var a = new { number = 1, text = "hi" };
  LINQ query that returns an anonymous type
  public class Dog
  {
    public string Name { get; set; }
    public int Age { get; set; }
  }
  public class DogWithBreed
  {
    public Dog Dog { get; set; }
    public string BreedName { get; set; }
  }
  public void GetDogsWithBreedNames()
  {
    var db = new DogDataContext(ConnectString);
    var result = from d in db.Dogs
           join b in db.Breeds on d.BreedId equals b.BreedId
           select new
           {
             DogName = d.Name,
             BreedName = b.BreedName
           };
    DoStuff(result);
  }
  You can use var keyword in foreach statement
  public bool hasItemInList(List< String> list, string stringToSearch)
    {
      foreach (var item in list)
      {
        if (((string)item).equals(stringToSearch))
          return true;
      }
      return false;
    }
</code></pre>

<h3>when</h3>
<pre><code>The when is a keyword added in C# 6, and it is used for exception filtering.
  Before the introduction of the when keyword, you could have had one catch clause for each type of exception; with
  the addition of the keyword, a more fine-grained control is now possible.
  A when expression is attached to a catch branch, and only if the when condition is true, the catch clause will be
  executed.It is possible to have several catch clauses with the same exception class types, and different when
  conditions.
  private void CatchException(Action action)
  {
    try
    {
      action.Invoke();
    }
    // exception filter
    catch (Exception ex) when (ex.Message.Contains("when"))
    {
      Console.WriteLine("Caught an exception with when");
    }
    catch (Exception ex)
    {
      Console.WriteLine("Caught an exception without when");
    }
  }
  private void Method1() { throw new Exception("message for exception with when"); }
  private void Method2() { throw new Exception("message for general exception"); }
  CatchException(Method1);
  CatchException(Method2);
</code></pre>

<h3>lock</h3>
<pre><code>
  lock provides thread - safety for a block of code, so that it can be accessed by only one thread within the same
    process.Example:
  private static object _lockObj = new object();
  static void Main(string[] args)
  {
    Task.Run(() => TaskWork());
    Task.Run(() => TaskWork());
    Task.Run(() => TaskWork());
    Console.ReadKey();
  }
  private static void TaskWork()
  {
    lock (_lockObj)
    {
      Console.WriteLine("Entered");
      Task.Delay(3000);
      Console.WriteLine("Done Delaying");
      // Access shared resources safely
      Console.WriteLine("Leaving");
    }
  }
  Output:
  Entered
  Done Delaying
  Leaving
  Entered
  Done Delaying
  Leaving
  Entered
  Done Delaying
  Leaving
  Use cases:
  Whenever you have a block of code that might produce side - effects if executed by multiple threads at the same
  time.The lock keyword along with a shared synchronization object(_objLock in the example) can be used to
  prevent that.
  Note that _objLock can't be null and multiple threads executing the code must use the same object instance
  (either by making it a static field, or by using the same class instance for both threads)
    From the compiler side, the lock keyword is a syntactic sugar that is replaced by Monitor.Enter(_lockObj); and

  Monitor.Exit(_lockObj);. So if you replace the lock by surrounding the block of code with these two methods,
  you would get the same results.You can see actual code in Syntactic sugar in C# - lock example
</code></pre>

<h3>uint</h3>
<pre><code></code></pre>

<h3></h3>
An unsigned integer, or uint, is a numeric datatype that only can hold positive integers. Like it's name suggests, it
represents an unsigned 32-bit integer. The uint keyword itself is an alias for the Common Type System type
System.UInt32. This datatype is present in mscorlib.dll, which is implicitly referenced by every C# project when
you create them. It occupies four bytes of memory space.
Unsigned integers can hold any value from 0 to 4,294,967,295.
Examples on how and now not to declare unsigned integers

<pre><code>uint i = 425697; // Valid expression, explicitly stated to compiler
var i1 = 789247U; // Valid expression, suffix allows compiler to determine datatype
uint x = 3.0; // Error, there is no implicit conversion
</code></pre>
Please note: According to Microsoft, it is recommended to use the int datatype wherever possible as the uint
datatype is not CLS-compliant.

<h3>if, if...else, if... else if</h3>
<pre><code>
  The if statement is used to control the flow of the program.An if statement identifies which statement to run
  based on the value of a Boolean expression.
  For a single statement, the braces{ }
  are optional but recommended.
  int a = 4;
  if (a % 2 == 0)
  {
    Console.WriteLine("a contains an even number");
  }
  // output: "a contains an even number"
  The if can also have an else clause, that will be executed in case the condition evaluates to false:
  int a = 5;
  if (a % 2 == 0)
  {
    Console.WriteLine("a contains an even number");
  }
  else
  {
    Console.WriteLine("a contains an odd number");
  }
  // output: "a contains an odd number"
  The if...else if construct lets you specify multiple conditions:
  int a = 9;
  if (a % 2 == 0)
  {
    Console.WriteLine("a contains an even number");
  }
  else if (a % 3 == 0)
  {
    Console.WriteLine("a contains an odd number that is a multiple of 3");
  }
  else
  {
    Console.WriteLine("a contains an odd number");
  }
  // output: "a contains an odd number that is a multiple of 3"
  Important to note that if a condition is met in the above example , the control skips other tests and jumps to
  the end of that particular if else construct.So, the order of tests is important if you are using if .. else if
  construct
  C# Boolean expressions use short-circuit evaluation. This is important in cases where evaluating conditions may
  have side effects:
  if (someBooleanMethodWithSideEffects() && someOtherBooleanMethodWithSideEffects()) {
   //...
  }
  There's no guarantee that someOtherBooleanMethodWithSideEffects will actually run.
  It's also important in cases where earlier conditions ensure that it's "safe" to evaluate later ones. For example:
  if (someCollection != null && someCollection.Count > 0) {
    // ..
  }
  The order is very important in this case because, if we reverse the order:
  if (someCollection.Count > 0 && someCollection != null) {
  it will throw a NullReferenceException if someCollection is null.
</code></pre>

<h3>static</h3>
<pre><code>The static modifier is used to declare a static member, which does not need to be instantiated in order to be
  accessed, but instead is accessed simply through its name, i.e.DateTime.Now.
  static can be used with classes, fields, methods, properties, operators, events, and constructors.
  While an instance of a class contains a separate copy of all instance fields of the class, there is only one copy of
  each static field.
  class A
  {
    static public int count = 0;
    public A()
    {
      count++;
    }
  }
  class Program
  {
    static void Main(string[] args)
    {
      A a = new A();
      A b = new A();
      A c = new A();
      Console.WriteLine(A.count); // 3
    }
  }
  count equals to the total number of instances of A class.
  The static modifier can also be used to declare a static constructor for a class, to initialize static data or run code
  that only needs to be called once. Static constructors are called before the class is referenced for the first time.
  class A
  {
    static public DateTime InitializationTime;
    // Static constructor
    static A()
    {
      InitializationTime = DateTime.Now;
      // Guaranteed to only run once
      Console.WriteLine(InitializationTime.ToString());
    }
  }
  A static class is marked with the static keyword, and can be used as a beneficial container for a set of methods
  that work on parameters, but don't necessarily require being tied to an instance. Because of the static nature of
  the class, it cannot be instantiated, but it can contain a static constructor.Some features of a static class
  include :
  Can't be inherited
  Can't inherit from anything other than Object
  Can contain a static constructor but not an instance constructor
  Can only contain static members
  Is sealed
  The compiler is also friendly and will let the developer know if any instance members exist within the class. An
  example would be a static class that converts between US and Canadian metrics:
  static class ConversionHelper
  {
    private static double oneGallonPerLitreRate = 0.264172;
    public static double litreToGallonConversion(int litres)
    {
      return litres * oneGallonPerLitreRate;
    }
  }
  When classes are declared static:
  public static class Functions
  {
    public static int Double(int value)
    {
      return value + value;
    }
    GoalKicker.com – C# Notes for Professionals 264
  }
  all function, properties or members within the class also need to be declared static. No instance of the class can be
  created.In essence a static class allows you to create bundles of functions that are grouped together logically.
  Since C#6 static can also be used alongside using to import static members and methods. They can be used then
  without class name.
  Old way, without using static:
  using System;
  public class ConsoleApplication
  {
    public static void Main()
    {
      Console.WriteLine("Hello World!"); //Writeline is method belonging to static class Console
    }
  }
  Example with using static
  using static System.Console;
  public class ConsoleApplication
  {
    public static void Main()
    {
      WriteLine("Hello World!"); //Writeline is method belonging to static class Console
    }
  }
  Drawbacks
  While static classes can be incredibly useful, they do come with their own caveats:
  Once the static class has been called, the class is loaded into memory and cannot be run through the
  garbage collector until the AppDomain housing the static class is unloaded.
  A static class cannot implement an interface.</code></pre>

<h3>internal</h3>
<pre><code>
  The internal keyword is an access modifier for types and type members. Internal types or members are
  accessible only within files in the same assembly
  usage:
  public class BaseClass
  {
  // Only accessible within the same assembly
  internal static int x = 0;
  }
  The difference between different access modifiers is clarified here
  Access modifiers
  public
  The type or member can be accessed by any other code in the same assembly or another assembly that
  references it.
  private
  The type or member can only be accessed by code in the same class or struct.
  protected
  The type or member can only be accessed by code in the same class or struct, or in a derived class.
  internal
  The type or member can be accessed by any code in the same assembly, but not from another assembly.
  protected internal
  The type or member can be accessed by any code in the same assembly, or by any derived class in
  another assembly.
  When no access modifier is set, a default access modifier is used. So there is always some form of access modifier
  even if it's not set.
</code></pre>

<h3>using</h3>
<pre><code>There are two types of using keyword usage, using statement and using directive:
  1. using statement:
  The using keyword ensures that objects that implement the IDisposable interface are properly disposed
  after usage. There is a separate topic for the using statement
  2. using directive
  The using directive has three usages, see the msdn page for the using directive. There is a separate topic for
  the using directive.</code></pre>

<h3>where</h3>
where can serve two purposes in C#: type constraining in a generic argument, and filtering LINQ queries.
<pre><code>
  In a generic class, let's consider
  public class Cup<T>
  {
    // ...
  }
  T is called a type parameter.The class definition can impose constraints on the actual types that can be supplied for
  T.
  The following kinds of constraints can be applied:
  value type
  reference type
  default constructor
  inheritance and implementation
  value type
  In this case only structs(this includes 'primitive' data types such as int, boolean etc) can be supplied
  public class Cup<T> where T : struct
  {
    // ...
  }
  reference type
  In this case only class types can be supplied
  public class Cup<T> where T : class
  {
    // ...
  }
  hybrid value/ reference type
   Occasionally it is desired to restrict type arguments to those available in a database, and these will usually map to
   value types and strings.As all type restrictions must be met, it is not possible to specify where T: struct or
  string(this is not valid syntax).A workaround is to restrict type arguments to IConvertible which has built in
  types of "... Boolean, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, DateTime,
  Char, and String." It is possible other objects will implement IConvertible, though this is rare in practice.
  public class Cup<T> where T : IConvertible
  {
    // ...
  }
  default constructor
  Only types that contain a default constructor will be allowed.This includes value types and classes that contain a
  default (parameterless) constructor
  public class Cup<T> where T : new
  {
    // ...
   
  }
  inheritance and implementation
  Only types that inherit from a certain base class or implement a certain interface can be supplied.
  public class Cup<T> where T : Beverage
  {
    // ...
  }
  public class Cup<T> where T : IBeer
  {
    // ...
  }
  The constraint can even reference another type parameter:
  public class Cup<T, U> where U : T
  {
    // ...
  }
  Multiple constraints can be specified for a type argument:
  public class Cup<T> where T : class, new()
  {
    // ...
  }
  The previous examples show generic constraints on a class definition, but constraints can be used
  anywhere a type argument is supplied: classes, structs, interfaces, methods, etc.
  where can also be a LINQ clause.In this case it is analogous to WHERE in SQL:
  int[] nums = { 5, 2, 1, 3, 9, 8, 6, 7, 2, 0 };
  var query =
  from num in nums
  where num < 5
  select num;
  foreach (var n in query)
  {
    Console.Write(n + " ");
  }
  // prints 2 1 3 2 0
</code></pre>

<h3>int</h3>
<pre><code>
  int is an alias for System.Int32, which is a data type for signed 32-bit integers. This data type can be found in
  mscorlib.dll which is implicitly referenced by every C# project when you create them.
  Range: -2,147,483,648 to 2,147,483,647
  int int1 = -10007;
  var int2 = 2132012521;
</code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
<h2></h2>
<div>

</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

<h2></h2>
<div>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>

<h3></h3>
<pre><code></code></pre>
</div>

</body>

</html>
<!--script>
 //$('code').addClass('language-csharp hljs');
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((el) => {
    hljs.highlightElement(el);
  });
});
</script-->